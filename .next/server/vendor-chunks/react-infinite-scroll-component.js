"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-infinite-scroll-component";
exports.ids = ["vendor-chunks/react-infinite-scroll-component"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-infinite-scroll-component/dist/index.es.js":
/*!***********************************************************************!*\
  !*** ./node_modules/react-infinite-scroll-component/dist/index.es.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */ /* global Reflect, Promise */ var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || ({\n        __proto__: []\n    }) instanceof Array && function(d, b) {\n        d.__proto__ = b;\n    } || function(d, b) {\n        for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n};\nfunction __extends(d, b) {\n    extendStatics(d, b);\n    function __() {\n        this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar __assign = function() {\n    __assign = Object.assign || function __assign(t) {\n        for(var s, i = 1, n = arguments.length; i < n; i++){\n            s = arguments[i];\n            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n/* eslint-disable no-undefined,no-param-reassign,no-shadow */ /**\n * Throttle execution of a function. Especially useful for rate limiting\n * execution of handlers on events like resize and scroll.\n *\n * @param  {Number}    delay          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\n * @param  {Boolean}   [noTrailing]   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds while the\n *                                    throttled-function is being called. If noTrailing is false or unspecified, callback will be executed one final time\n *                                    after the last throttled-function call. (After the throttled-function has not been called for `delay` milliseconds,\n *                                    the internal counter is reset)\n * @param  {Function}  callback       A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\n *                                    to `callback` when the throttled-function is executed.\n * @param  {Boolean}   [debounceMode] If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is false (at end),\n *                                    schedule `callback` to execute after `delay` ms.\n *\n * @return {Function}  A new, throttled, function.\n */ function throttle(delay, noTrailing, callback, debounceMode) {\n    /*\n   * After wrapper has stopped being called, this timeout ensures that\n   * `callback` is executed at the proper times in `throttle` and `end`\n   * debounce modes.\n   */ var timeoutID;\n    var cancelled = false; // Keep track of the last time `callback` was executed.\n    var lastExec = 0; // Function to clear existing timeout\n    function clearExistingTimeout() {\n        if (timeoutID) {\n            clearTimeout(timeoutID);\n        }\n    } // Function to cancel next exec\n    function cancel() {\n        clearExistingTimeout();\n        cancelled = true;\n    } // `noTrailing` defaults to falsy.\n    if (typeof noTrailing !== \"boolean\") {\n        debounceMode = callback;\n        callback = noTrailing;\n        noTrailing = undefined;\n    }\n    /*\n   * The `wrapper` function encapsulates all of the throttling / debouncing\n   * functionality and when executed will limit the rate at which `callback`\n   * is executed.\n   */ function wrapper() {\n        var self = this;\n        var elapsed = Date.now() - lastExec;\n        var args = arguments;\n        if (cancelled) {\n            return;\n        } // Execute `callback` and update the `lastExec` timestamp.\n        function exec() {\n            lastExec = Date.now();\n            callback.apply(self, args);\n        }\n        /*\n     * If `debounceMode` is true (at begin) this is used to clear the flag\n     * to allow future `callback` executions.\n     */ function clear() {\n            timeoutID = undefined;\n        }\n        if (debounceMode && !timeoutID) {\n            /*\n       * Since `wrapper` is being called for the first time and\n       * `debounceMode` is true (at begin), execute `callback`.\n       */ exec();\n        }\n        clearExistingTimeout();\n        if (debounceMode === undefined && elapsed > delay) {\n            /*\n       * In throttle mode, if `delay` time has been exceeded, execute\n       * `callback`.\n       */ exec();\n        } else if (noTrailing !== true) {\n            /*\n       * In trailing throttle mode, since `delay` time has not been\n       * exceeded, schedule `callback` to execute `delay` ms after most\n       * recent execution.\n       *\n       * If `debounceMode` is true (at begin), schedule `clear` to execute\n       * after `delay` ms.\n       *\n       * If `debounceMode` is false (at end), schedule `callback` to\n       * execute after `delay` ms.\n       */ timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);\n        }\n    }\n    wrapper.cancel = cancel; // Return the wrapper function.\n    return wrapper;\n}\nvar ThresholdUnits = {\n    Pixel: \"Pixel\",\n    Percent: \"Percent\"\n};\nvar defaultThreshold = {\n    unit: ThresholdUnits.Percent,\n    value: 0.8\n};\nfunction parseThreshold(scrollThreshold) {\n    if (typeof scrollThreshold === \"number\") {\n        return {\n            unit: ThresholdUnits.Percent,\n            value: scrollThreshold * 100\n        };\n    }\n    if (typeof scrollThreshold === \"string\") {\n        if (scrollThreshold.match(/^(\\d*(\\.\\d+)?)px$/)) {\n            return {\n                unit: ThresholdUnits.Pixel,\n                value: parseFloat(scrollThreshold)\n            };\n        }\n        if (scrollThreshold.match(/^(\\d*(\\.\\d+)?)%$/)) {\n            return {\n                unit: ThresholdUnits.Percent,\n                value: parseFloat(scrollThreshold)\n            };\n        }\n        console.warn('scrollThreshold format is invalid. Valid formats: \"120px\", \"50%\"...');\n        return defaultThreshold;\n    }\n    console.warn(\"scrollThreshold should be string or number\");\n    return defaultThreshold;\n}\nvar InfiniteScroll = /** @class */ function(_super) {\n    __extends(InfiniteScroll, _super);\n    function InfiniteScroll(props) {\n        var _this = _super.call(this, props) || this;\n        _this.lastScrollTop = 0;\n        _this.actionTriggered = false;\n        // variables to keep track of pull down behaviour\n        _this.startY = 0;\n        _this.currentY = 0;\n        _this.dragging = false;\n        // will be populated in componentDidMount\n        // based on the height of the pull down element\n        _this.maxPullDownDistance = 0;\n        _this.getScrollableTarget = function() {\n            if (_this.props.scrollableTarget instanceof HTMLElement) return _this.props.scrollableTarget;\n            if (typeof _this.props.scrollableTarget === \"string\") {\n                return document.getElementById(_this.props.scrollableTarget);\n            }\n            if (_this.props.scrollableTarget === null) {\n                console.warn(\"You are trying to pass scrollableTarget but it is null. This might\\n        happen because the element may not have been added to DOM yet.\\n        See https://github.com/ankeetmaini/react-infinite-scroll-component/issues/59 for more info.\\n      \");\n            }\n            return null;\n        };\n        _this.onStart = function(evt) {\n            if (_this.lastScrollTop) return;\n            _this.dragging = true;\n            if (evt instanceof MouseEvent) {\n                _this.startY = evt.pageY;\n            } else if (evt instanceof TouchEvent) {\n                _this.startY = evt.touches[0].pageY;\n            }\n            _this.currentY = _this.startY;\n            if (_this._infScroll) {\n                _this._infScroll.style.willChange = \"transform\";\n                _this._infScroll.style.transition = \"transform 0.2s cubic-bezier(0,0,0.31,1)\";\n            }\n        };\n        _this.onMove = function(evt) {\n            if (!_this.dragging) return;\n            if (evt instanceof MouseEvent) {\n                _this.currentY = evt.pageY;\n            } else if (evt instanceof TouchEvent) {\n                _this.currentY = evt.touches[0].pageY;\n            }\n            // user is scrolling down to up\n            if (_this.currentY < _this.startY) return;\n            if (_this.currentY - _this.startY >= Number(_this.props.pullDownToRefreshThreshold)) {\n                _this.setState({\n                    pullToRefreshThresholdBreached: true\n                });\n            }\n            // so you can drag upto 1.5 times of the maxPullDownDistance\n            if (_this.currentY - _this.startY > _this.maxPullDownDistance * 1.5) return;\n            if (_this._infScroll) {\n                _this._infScroll.style.overflow = \"visible\";\n                _this._infScroll.style.transform = \"translate3d(0px, \" + (_this.currentY - _this.startY) + \"px, 0px)\";\n            }\n        };\n        _this.onEnd = function() {\n            _this.startY = 0;\n            _this.currentY = 0;\n            _this.dragging = false;\n            if (_this.state.pullToRefreshThresholdBreached) {\n                _this.props.refreshFunction && _this.props.refreshFunction();\n                _this.setState({\n                    pullToRefreshThresholdBreached: false\n                });\n            }\n            requestAnimationFrame(function() {\n                // this._infScroll\n                if (_this._infScroll) {\n                    _this._infScroll.style.overflow = \"auto\";\n                    _this._infScroll.style.transform = \"none\";\n                    _this._infScroll.style.willChange = \"unset\";\n                }\n            });\n        };\n        _this.onScrollListener = function(event) {\n            if (typeof _this.props.onScroll === \"function\") {\n                // Execute this callback in next tick so that it does not affect the\n                // functionality of the library.\n                setTimeout(function() {\n                    return _this.props.onScroll && _this.props.onScroll(event);\n                }, 0);\n            }\n            var target = _this.props.height || _this._scrollableNode ? event.target : document.documentElement.scrollTop ? document.documentElement : document.body;\n            // return immediately if the action has already been triggered,\n            // prevents multiple triggers.\n            if (_this.actionTriggered) return;\n            var atBottom = _this.props.inverse ? _this.isElementAtTop(target, _this.props.scrollThreshold) : _this.isElementAtBottom(target, _this.props.scrollThreshold);\n            // call the `next` function in the props to trigger the next data fetch\n            if (atBottom && _this.props.hasMore) {\n                _this.actionTriggered = true;\n                _this.setState({\n                    showLoader: true\n                });\n                _this.props.next && _this.props.next();\n            }\n            _this.lastScrollTop = target.scrollTop;\n        };\n        _this.state = {\n            showLoader: false,\n            pullToRefreshThresholdBreached: false,\n            prevDataLength: props.dataLength\n        };\n        _this.throttledOnScrollListener = throttle(150, _this.onScrollListener).bind(_this);\n        _this.onStart = _this.onStart.bind(_this);\n        _this.onMove = _this.onMove.bind(_this);\n        _this.onEnd = _this.onEnd.bind(_this);\n        return _this;\n    }\n    InfiniteScroll.prototype.componentDidMount = function() {\n        if (typeof this.props.dataLength === \"undefined\") {\n            throw new Error('mandatory prop \"dataLength\" is missing. The prop is needed' + \" when loading more content. Check README.md for usage\");\n        }\n        this._scrollableNode = this.getScrollableTarget();\n        this.el = this.props.height ? this._infScroll : this._scrollableNode || window;\n        if (this.el) {\n            this.el.addEventListener(\"scroll\", this.throttledOnScrollListener);\n        }\n        if (typeof this.props.initialScrollY === \"number\" && this.el && this.el instanceof HTMLElement && this.el.scrollHeight > this.props.initialScrollY) {\n            this.el.scrollTo(0, this.props.initialScrollY);\n        }\n        if (this.props.pullDownToRefresh && this.el) {\n            this.el.addEventListener(\"touchstart\", this.onStart);\n            this.el.addEventListener(\"touchmove\", this.onMove);\n            this.el.addEventListener(\"touchend\", this.onEnd);\n            this.el.addEventListener(\"mousedown\", this.onStart);\n            this.el.addEventListener(\"mousemove\", this.onMove);\n            this.el.addEventListener(\"mouseup\", this.onEnd);\n            // get BCR of pullDown element to position it above\n            this.maxPullDownDistance = this._pullDown && this._pullDown.firstChild && this._pullDown.firstChild.getBoundingClientRect().height || 0;\n            this.forceUpdate();\n            if (typeof this.props.refreshFunction !== \"function\") {\n                throw new Error('Mandatory prop \"refreshFunction\" missing.\\n          Pull Down To Refresh functionality will not work\\n          as expected. Check README.md for usage\\'');\n            }\n        }\n    };\n    InfiniteScroll.prototype.componentWillUnmount = function() {\n        if (this.el) {\n            this.el.removeEventListener(\"scroll\", this.throttledOnScrollListener);\n            if (this.props.pullDownToRefresh) {\n                this.el.removeEventListener(\"touchstart\", this.onStart);\n                this.el.removeEventListener(\"touchmove\", this.onMove);\n                this.el.removeEventListener(\"touchend\", this.onEnd);\n                this.el.removeEventListener(\"mousedown\", this.onStart);\n                this.el.removeEventListener(\"mousemove\", this.onMove);\n                this.el.removeEventListener(\"mouseup\", this.onEnd);\n            }\n        }\n    };\n    InfiniteScroll.prototype.componentDidUpdate = function(prevProps) {\n        // do nothing when dataLength is unchanged\n        if (this.props.dataLength === prevProps.dataLength) return;\n        this.actionTriggered = false;\n        // update state when new data was sent in\n        this.setState({\n            showLoader: false\n        });\n    };\n    InfiniteScroll.getDerivedStateFromProps = function(nextProps, prevState) {\n        var dataLengthChanged = nextProps.dataLength !== prevState.prevDataLength;\n        // reset when data changes\n        if (dataLengthChanged) {\n            return __assign(__assign({}, prevState), {\n                prevDataLength: nextProps.dataLength\n            });\n        }\n        return null;\n    };\n    InfiniteScroll.prototype.isElementAtTop = function(target, scrollThreshold) {\n        if (scrollThreshold === void 0) {\n            scrollThreshold = 0.8;\n        }\n        var clientHeight = target === document.body || target === document.documentElement ? window.screen.availHeight : target.clientHeight;\n        var threshold = parseThreshold(scrollThreshold);\n        if (threshold.unit === ThresholdUnits.Pixel) {\n            return target.scrollTop <= threshold.value + clientHeight - target.scrollHeight + 1;\n        }\n        return target.scrollTop <= threshold.value / 100 + clientHeight - target.scrollHeight + 1;\n    };\n    InfiniteScroll.prototype.isElementAtBottom = function(target, scrollThreshold) {\n        if (scrollThreshold === void 0) {\n            scrollThreshold = 0.8;\n        }\n        var clientHeight = target === document.body || target === document.documentElement ? window.screen.availHeight : target.clientHeight;\n        var threshold = parseThreshold(scrollThreshold);\n        if (threshold.unit === ThresholdUnits.Pixel) {\n            return target.scrollTop + clientHeight >= target.scrollHeight - threshold.value;\n        }\n        return target.scrollTop + clientHeight >= threshold.value / 100 * target.scrollHeight;\n    };\n    InfiniteScroll.prototype.render = function() {\n        var _this = this;\n        var style = __assign({\n            height: this.props.height || \"auto\",\n            overflow: \"auto\",\n            WebkitOverflowScrolling: \"touch\"\n        }, this.props.style);\n        var hasChildren = this.props.hasChildren || !!(this.props.children && this.props.children instanceof Array && this.props.children.length);\n        // because heighted infiniteScroll visualy breaks\n        // on drag down as overflow becomes visible\n        var outerDivStyle = this.props.pullDownToRefresh && this.props.height ? {\n            overflow: \"auto\"\n        } : {};\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n            style: outerDivStyle,\n            className: \"infinite-scroll-component__outerdiv\"\n        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n            className: \"infinite-scroll-component \" + (this.props.className || \"\"),\n            ref: function(infScroll) {\n                return _this._infScroll = infScroll;\n            },\n            style: style\n        }, this.props.pullDownToRefresh && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n            style: {\n                position: \"relative\"\n            },\n            ref: function(pullDown) {\n                return _this._pullDown = pullDown;\n            }\n        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n            style: {\n                position: \"absolute\",\n                left: 0,\n                right: 0,\n                top: -1 * this.maxPullDownDistance\n            }\n        }, this.state.pullToRefreshThresholdBreached ? this.props.releaseToRefreshContent : this.props.pullDownToRefreshContent)), this.props.children, !this.state.showLoader && !hasChildren && this.props.hasMore && this.props.loader, this.state.showLoader && this.props.hasMore && this.props.loader, !this.props.hasMore && this.props.endMessage));\n    };\n    return InfiniteScroll;\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (InfiniteScroll); //# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtaW5maW5pdGUtc2Nyb2xsLWNvbXBvbmVudC9kaXN0L2luZGV4LmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF5QztBQUV6Qzs7Ozs7Ozs7Ozs7Ozs4RUFhOEUsR0FDOUUsMkJBQTJCLEdBRTNCLElBQUlFLGdCQUFnQixTQUFTQyxDQUFDLEVBQUVDLENBQUM7SUFDN0JGLGdCQUFnQkcsT0FBT0MsY0FBYyxJQUNoQztRQUFFQyxXQUFXLEVBQUU7SUFBQyxjQUFhQyxTQUFTLFNBQVVMLENBQUMsRUFBRUMsQ0FBQztRQUFJRCxFQUFFSSxTQUFTLEdBQUdIO0lBQUcsS0FDMUUsU0FBVUQsQ0FBQyxFQUFFQyxDQUFDO1FBQUksSUFBSyxJQUFJSyxLQUFLTCxFQUFHLElBQUlBLEVBQUVNLGNBQWMsQ0FBQ0QsSUFBSU4sQ0FBQyxDQUFDTSxFQUFFLEdBQUdMLENBQUMsQ0FBQ0ssRUFBRTtJQUFFO0lBQzdFLE9BQU9QLGNBQWNDLEdBQUdDO0FBQzVCO0FBRUEsU0FBU08sVUFBVVIsQ0FBQyxFQUFFQyxDQUFDO0lBQ25CRixjQUFjQyxHQUFHQztJQUNqQixTQUFTUTtRQUFPLElBQUksQ0FBQ0MsV0FBVyxHQUFHVjtJQUFHO0lBQ3RDQSxFQUFFVyxTQUFTLEdBQUdWLE1BQU0sT0FBT0MsT0FBT1UsTUFBTSxDQUFDWCxLQUFNUSxDQUFBQSxHQUFHRSxTQUFTLEdBQUdWLEVBQUVVLFNBQVMsRUFBRSxJQUFJRixJQUFHO0FBQ3RGO0FBRUEsSUFBSUksV0FBVztJQUNYQSxXQUFXWCxPQUFPWSxNQUFNLElBQUksU0FBU0QsU0FBU0UsQ0FBQztRQUMzQyxJQUFLLElBQUlDLEdBQUdDLElBQUksR0FBR0MsSUFBSUMsVUFBVUMsTUFBTSxFQUFFSCxJQUFJQyxHQUFHRCxJQUFLO1lBQ2pERCxJQUFJRyxTQUFTLENBQUNGLEVBQUU7WUFDaEIsSUFBSyxJQUFJWCxLQUFLVSxFQUFHLElBQUlkLE9BQU9TLFNBQVMsQ0FBQ0osY0FBYyxDQUFD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RixLQUFLLFNBQVVHLFFBQVE7Z0JBQUksT0FBUXhGLE1BQU04RCxTQUFTLEdBQUcwQjtZQUFXO1FBQUUsaUJBQzdKdEosMERBQW1CLENBQUMsT0FBTztZQUFFaUYsT0FBTztnQkFDNUJvRSxVQUFVO2dCQUNWRSxNQUFNO2dCQUNOQyxPQUFPO2dCQUNQQyxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUNyRixtQkFBbUI7WUFDdEM7UUFBRSxHQUFHLElBQUksQ0FBQ3dCLEtBQUssQ0FBQ0osOEJBQThCLEdBQzVDLElBQUksQ0FBQzNCLEtBQUssQ0FBQzZGLHVCQUF1QixHQUNsQyxJQUFJLENBQUM3RixLQUFLLENBQUM4Rix3QkFBd0IsSUFDN0MsSUFBSSxDQUFDOUYsS0FBSyxDQUFDa0YsUUFBUSxFQUNuQixDQUFDLElBQUksQ0FBQ25ELEtBQUssQ0FBQ2lCLFVBQVUsSUFDbEIsQ0FBQ2lDLGVBQ0QsSUFBSSxDQUFDakYsS0FBSyxDQUFDK0MsT0FBTyxJQUNsQixJQUFJLENBQUMvQyxLQUFLLENBQUMrRixNQUFNLEVBQ3JCLElBQUksQ0FBQ2hFLEtBQUssQ0FBQ2lCLFVBQVUsSUFBSSxJQUFJLENBQUNoRCxLQUFLLENBQUMrQyxPQUFPLElBQUksSUFBSSxDQUFDL0MsS0FBSyxDQUFDK0YsTUFBTSxFQUNoRSxDQUFDLElBQUksQ0FBQy9GLEtBQUssQ0FBQytDLE9BQU8sSUFBSSxJQUFJLENBQUMvQyxLQUFLLENBQUNnRyxVQUFVO0lBQ3hEO0lBQ0EsT0FBT2xHO0FBQ1gsRUFBRTFELDRDQUFTQTtBQUVYLGlFQUFlMEQsY0FBY0EsRUFBQyxDQUM5QixvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9GTEFBS0tPLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWluZmluaXRlLXNjcm9sbC1jb21wb25lbnQvZGlzdC9pbmRleC5lcy5qcz9hYmIyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmaW5lZCxuby1wYXJhbS1yZWFzc2lnbixuby1zaGFkb3cgKi9cblxuLyoqXG4gKiBUaHJvdHRsZSBleGVjdXRpb24gb2YgYSBmdW5jdGlvbi4gRXNwZWNpYWxseSB1c2VmdWwgZm9yIHJhdGUgbGltaXRpbmdcbiAqIGV4ZWN1dGlvbiBvZiBoYW5kbGVycyBvbiBldmVudHMgbGlrZSByZXNpemUgYW5kIHNjcm9sbC5cbiAqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgIGRlbGF5ICAgICAgICAgIEEgemVyby1vci1ncmVhdGVyIGRlbGF5IGluIG1pbGxpc2Vjb25kcy4gRm9yIGV2ZW50IGNhbGxiYWNrcywgdmFsdWVzIGFyb3VuZCAxMDAgb3IgMjUwIChvciBldmVuIGhpZ2hlcikgYXJlIG1vc3QgdXNlZnVsLlxuICogQHBhcmFtICB7Qm9vbGVhbn0gICBbbm9UcmFpbGluZ10gICBPcHRpb25hbCwgZGVmYXVsdHMgdG8gZmFsc2UuIElmIG5vVHJhaWxpbmcgaXMgdHJ1ZSwgY2FsbGJhY2sgd2lsbCBvbmx5IGV4ZWN1dGUgZXZlcnkgYGRlbGF5YCBtaWxsaXNlY29uZHMgd2hpbGUgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm90dGxlZC1mdW5jdGlvbiBpcyBiZWluZyBjYWxsZWQuIElmIG5vVHJhaWxpbmcgaXMgZmFsc2Ugb3IgdW5zcGVjaWZpZWQsIGNhbGxiYWNrIHdpbGwgYmUgZXhlY3V0ZWQgb25lIGZpbmFsIHRpbWVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgdGhlIGxhc3QgdGhyb3R0bGVkLWZ1bmN0aW9uIGNhbGwuIChBZnRlciB0aGUgdGhyb3R0bGVkLWZ1bmN0aW9uIGhhcyBub3QgYmVlbiBjYWxsZWQgZm9yIGBkZWxheWAgbWlsbGlzZWNvbmRzLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgaW50ZXJuYWwgY291bnRlciBpcyByZXNldClcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSAgY2FsbGJhY2sgICAgICAgQSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBhZnRlciBkZWxheSBtaWxsaXNlY29uZHMuIFRoZSBgdGhpc2AgY29udGV4dCBhbmQgYWxsIGFyZ3VtZW50cyBhcmUgcGFzc2VkIHRocm91Z2gsIGFzLWlzLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBgY2FsbGJhY2tgIHdoZW4gdGhlIHRocm90dGxlZC1mdW5jdGlvbiBpcyBleGVjdXRlZC5cbiAqIEBwYXJhbSAge0Jvb2xlYW59ICAgW2RlYm91bmNlTW9kZV0gSWYgYGRlYm91bmNlTW9kZWAgaXMgdHJ1ZSAoYXQgYmVnaW4pLCBzY2hlZHVsZSBgY2xlYXJgIHRvIGV4ZWN1dGUgYWZ0ZXIgYGRlbGF5YCBtcy4gSWYgYGRlYm91bmNlTW9kZWAgaXMgZmFsc2UgKGF0IGVuZCksXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlIGBjYWxsYmFja2AgdG8gZXhlY3V0ZSBhZnRlciBgZGVsYXlgIG1zLlxuICpcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSAgQSBuZXcsIHRocm90dGxlZCwgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHRocm90dGxlIChkZWxheSwgbm9UcmFpbGluZywgY2FsbGJhY2ssIGRlYm91bmNlTW9kZSkge1xuICAvKlxuICAgKiBBZnRlciB3cmFwcGVyIGhhcyBzdG9wcGVkIGJlaW5nIGNhbGxlZCwgdGhpcyB0aW1lb3V0IGVuc3VyZXMgdGhhdFxuICAgKiBgY2FsbGJhY2tgIGlzIGV4ZWN1dGVkIGF0IHRoZSBwcm9wZXIgdGltZXMgaW4gYHRocm90dGxlYCBhbmQgYGVuZGBcbiAgICogZGVib3VuY2UgbW9kZXMuXG4gICAqL1xuICB2YXIgdGltZW91dElEO1xuICB2YXIgY2FuY2VsbGVkID0gZmFsc2U7IC8vIEtlZXAgdHJhY2sgb2YgdGhlIGxhc3QgdGltZSBgY2FsbGJhY2tgIHdhcyBleGVjdXRlZC5cblxuICB2YXIgbGFzdEV4ZWMgPSAwOyAvLyBGdW5jdGlvbiB0byBjbGVhciBleGlzdGluZyB0aW1lb3V0XG5cbiAgZnVuY3Rpb24gY2xlYXJFeGlzdGluZ1RpbWVvdXQoKSB7XG4gICAgaWYgKHRpbWVvdXRJRCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJRCk7XG4gICAgfVxuICB9IC8vIEZ1bmN0aW9uIHRvIGNhbmNlbCBuZXh0IGV4ZWNcblxuXG4gIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICBjbGVhckV4aXN0aW5nVGltZW91dCgpO1xuICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gIH0gLy8gYG5vVHJhaWxpbmdgIGRlZmF1bHRzIHRvIGZhbHN5LlxuXG5cbiAgaWYgKHR5cGVvZiBub1RyYWlsaW5nICE9PSAnYm9vbGVhbicpIHtcbiAgICBkZWJvdW5jZU1vZGUgPSBjYWxsYmFjaztcbiAgICBjYWxsYmFjayA9IG5vVHJhaWxpbmc7XG4gICAgbm9UcmFpbGluZyA9IHVuZGVmaW5lZDtcbiAgfVxuICAvKlxuICAgKiBUaGUgYHdyYXBwZXJgIGZ1bmN0aW9uIGVuY2Fwc3VsYXRlcyBhbGwgb2YgdGhlIHRocm90dGxpbmcgLyBkZWJvdW5jaW5nXG4gICAqIGZ1bmN0aW9uYWxpdHkgYW5kIHdoZW4gZXhlY3V0ZWQgd2lsbCBsaW1pdCB0aGUgcmF0ZSBhdCB3aGljaCBgY2FsbGJhY2tgXG4gICAqIGlzIGV4ZWN1dGVkLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBlbGFwc2VkID0gRGF0ZS5ub3coKSAtIGxhc3RFeGVjO1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuXG4gICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRXhlY3V0ZSBgY2FsbGJhY2tgIGFuZCB1cGRhdGUgdGhlIGBsYXN0RXhlY2AgdGltZXN0YW1wLlxuXG5cbiAgICBmdW5jdGlvbiBleGVjKCkge1xuICAgICAgbGFzdEV4ZWMgPSBEYXRlLm5vdygpO1xuICAgICAgY2FsbGJhY2suYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgfVxuICAgIC8qXG4gICAgICogSWYgYGRlYm91bmNlTW9kZWAgaXMgdHJ1ZSAoYXQgYmVnaW4pIHRoaXMgaXMgdXNlZCB0byBjbGVhciB0aGUgZmxhZ1xuICAgICAqIHRvIGFsbG93IGZ1dHVyZSBgY2FsbGJhY2tgIGV4ZWN1dGlvbnMuXG4gICAgICovXG5cblxuICAgIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdGltZW91dElEID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChkZWJvdW5jZU1vZGUgJiYgIXRpbWVvdXRJRCkge1xuICAgICAgLypcbiAgICAgICAqIFNpbmNlIGB3cmFwcGVyYCBpcyBiZWluZyBjYWxsZWQgZm9yIHRoZSBmaXJzdCB0aW1lIGFuZFxuICAgICAgICogYGRlYm91bmNlTW9kZWAgaXMgdHJ1ZSAoYXQgYmVnaW4pLCBleGVjdXRlIGBjYWxsYmFja2AuXG4gICAgICAgKi9cbiAgICAgIGV4ZWMoKTtcbiAgICB9XG5cbiAgICBjbGVhckV4aXN0aW5nVGltZW91dCgpO1xuXG4gICAgaWYgKGRlYm91bmNlTW9kZSA9PT0gdW5kZWZpbmVkICYmIGVsYXBzZWQgPiBkZWxheSkge1xuICAgICAgLypcbiAgICAgICAqIEluIHRocm90dGxlIG1vZGUsIGlmIGBkZWxheWAgdGltZSBoYXMgYmVlbiBleGNlZWRlZCwgZXhlY3V0ZVxuICAgICAgICogYGNhbGxiYWNrYC5cbiAgICAgICAqL1xuICAgICAgZXhlYygpO1xuICAgIH0gZWxzZSBpZiAobm9UcmFpbGluZyAhPT0gdHJ1ZSkge1xuICAgICAgLypcbiAgICAgICAqIEluIHRyYWlsaW5nIHRocm90dGxlIG1vZGUsIHNpbmNlIGBkZWxheWAgdGltZSBoYXMgbm90IGJlZW5cbiAgICAgICAqIGV4Y2VlZGVkLCBzY2hlZHVsZSBgY2FsbGJhY2tgIHRvIGV4ZWN1dGUgYGRlbGF5YCBtcyBhZnRlciBtb3N0XG4gICAgICAgKiByZWNlbnQgZXhlY3V0aW9uLlxuICAgICAgICpcbiAgICAgICAqIElmIGBkZWJvdW5jZU1vZGVgIGlzIHRydWUgKGF0IGJlZ2luKSwgc2NoZWR1bGUgYGNsZWFyYCB0byBleGVjdXRlXG4gICAgICAgKiBhZnRlciBgZGVsYXlgIG1zLlxuICAgICAgICpcbiAgICAgICAqIElmIGBkZWJvdW5jZU1vZGVgIGlzIGZhbHNlIChhdCBlbmQpLCBzY2hlZHVsZSBgY2FsbGJhY2tgIHRvXG4gICAgICAgKiBleGVjdXRlIGFmdGVyIGBkZWxheWAgbXMuXG4gICAgICAgKi9cbiAgICAgIHRpbWVvdXRJRCA9IHNldFRpbWVvdXQoZGVib3VuY2VNb2RlID8gY2xlYXIgOiBleGVjLCBkZWJvdW5jZU1vZGUgPT09IHVuZGVmaW5lZCA/IGRlbGF5IC0gZWxhcHNlZCA6IGRlbGF5KTtcbiAgICB9XG4gIH1cblxuICB3cmFwcGVyLmNhbmNlbCA9IGNhbmNlbDsgLy8gUmV0dXJuIHRoZSB3cmFwcGVyIGZ1bmN0aW9uLlxuXG4gIHJldHVybiB3cmFwcGVyO1xufVxuXG52YXIgVGhyZXNob2xkVW5pdHMgPSB7XHJcbiAgICBQaXhlbDogJ1BpeGVsJyxcclxuICAgIFBlcmNlbnQ6ICdQZXJjZW50JyxcclxufTtcclxudmFyIGRlZmF1bHRUaHJlc2hvbGQgPSB7XHJcbiAgICB1bml0OiBUaHJlc2hvbGRVbml0cy5QZXJjZW50LFxyXG4gICAgdmFsdWU6IDAuOCxcclxufTtcclxuZnVuY3Rpb24gcGFyc2VUaHJlc2hvbGQoc2Nyb2xsVGhyZXNob2xkKSB7XHJcbiAgICBpZiAodHlwZW9mIHNjcm9sbFRocmVzaG9sZCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB1bml0OiBUaHJlc2hvbGRVbml0cy5QZXJjZW50LFxyXG4gICAgICAgICAgICB2YWx1ZTogc2Nyb2xsVGhyZXNob2xkICogMTAwLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIHNjcm9sbFRocmVzaG9sZCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBpZiAoc2Nyb2xsVGhyZXNob2xkLm1hdGNoKC9eKFxcZCooXFwuXFxkKyk/KXB4JC8pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB1bml0OiBUaHJlc2hvbGRVbml0cy5QaXhlbCxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJzZUZsb2F0KHNjcm9sbFRocmVzaG9sZCksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzY3JvbGxUaHJlc2hvbGQubWF0Y2goL14oXFxkKihcXC5cXGQrKT8pJSQvKSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdW5pdDogVGhyZXNob2xkVW5pdHMuUGVyY2VudCxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJzZUZsb2F0KHNjcm9sbFRocmVzaG9sZCksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnNvbGUud2Fybignc2Nyb2xsVGhyZXNob2xkIGZvcm1hdCBpcyBpbnZhbGlkLiBWYWxpZCBmb3JtYXRzOiBcIjEyMHB4XCIsIFwiNTAlXCIuLi4nKTtcclxuICAgICAgICByZXR1cm4gZGVmYXVsdFRocmVzaG9sZDtcclxuICAgIH1cclxuICAgIGNvbnNvbGUud2Fybignc2Nyb2xsVGhyZXNob2xkIHNob3VsZCBiZSBzdHJpbmcgb3IgbnVtYmVyJyk7XHJcbiAgICByZXR1cm4gZGVmYXVsdFRocmVzaG9sZDtcclxufVxuXG52YXIgSW5maW5pdGVTY3JvbGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoSW5maW5pdGVTY3JvbGwsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBJbmZpbml0ZVNjcm9sbChwcm9wcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmxhc3RTY3JvbGxUb3AgPSAwO1xyXG4gICAgICAgIF90aGlzLmFjdGlvblRyaWdnZXJlZCA9IGZhbHNlO1xyXG4gICAgICAgIC8vIHZhcmlhYmxlcyB0byBrZWVwIHRyYWNrIG9mIHB1bGwgZG93biBiZWhhdmlvdXJcclxuICAgICAgICBfdGhpcy5zdGFydFkgPSAwO1xyXG4gICAgICAgIF90aGlzLmN1cnJlbnRZID0gMDtcclxuICAgICAgICBfdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgICAgIC8vIHdpbGwgYmUgcG9wdWxhdGVkIGluIGNvbXBvbmVudERpZE1vdW50XHJcbiAgICAgICAgLy8gYmFzZWQgb24gdGhlIGhlaWdodCBvZiB0aGUgcHVsbCBkb3duIGVsZW1lbnRcclxuICAgICAgICBfdGhpcy5tYXhQdWxsRG93bkRpc3RhbmNlID0gMDtcclxuICAgICAgICBfdGhpcy5nZXRTY3JvbGxhYmxlVGFyZ2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuc2Nyb2xsYWJsZVRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnByb3BzLnNjcm9sbGFibGVUYXJnZXQ7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgX3RoaXMucHJvcHMuc2Nyb2xsYWJsZVRhcmdldCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChfdGhpcy5wcm9wcy5zY3JvbGxhYmxlVGFyZ2V0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuc2Nyb2xsYWJsZVRhcmdldCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiWW91IGFyZSB0cnlpbmcgdG8gcGFzcyBzY3JvbGxhYmxlVGFyZ2V0IGJ1dCBpdCBpcyBudWxsLiBUaGlzIG1pZ2h0XFxuICAgICAgICBoYXBwZW4gYmVjYXVzZSB0aGUgZWxlbWVudCBtYXkgbm90IGhhdmUgYmVlbiBhZGRlZCB0byBET00geWV0LlxcbiAgICAgICAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmtlZXRtYWluaS9yZWFjdC1pbmZpbml0ZS1zY3JvbGwtY29tcG9uZW50L2lzc3Vlcy81OSBmb3IgbW9yZSBpbmZvLlxcbiAgICAgIFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIF90aGlzLm9uU3RhcnQgPSBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5sYXN0U2Nyb2xsVG9wKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBfdGhpcy5kcmFnZ2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmIChldnQgaW5zdGFuY2VvZiBNb3VzZUV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGFydFkgPSBldnQucGFnZVk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZXZ0IGluc3RhbmNlb2YgVG91Y2hFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuc3RhcnRZID0gZXZ0LnRvdWNoZXNbMF0ucGFnZVk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMuY3VycmVudFkgPSBfdGhpcy5zdGFydFk7XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5faW5mU2Nyb2xsKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5faW5mU2Nyb2xsLnN0eWxlLndpbGxDaGFuZ2UgPSAndHJhbnNmb3JtJztcclxuICAgICAgICAgICAgICAgIF90aGlzLl9pbmZTY3JvbGwuc3R5bGUudHJhbnNpdGlvbiA9IFwidHJhbnNmb3JtIDAuMnMgY3ViaWMtYmV6aWVyKDAsMCwwLjMxLDEpXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIF90aGlzLm9uTW92ZSA9IGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICAgICAgaWYgKCFfdGhpcy5kcmFnZ2luZylcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgaWYgKGV2dCBpbnN0YW5jZW9mIE1vdXNlRXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmN1cnJlbnRZID0gZXZ0LnBhZ2VZO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGV2dCBpbnN0YW5jZW9mIFRvdWNoRXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmN1cnJlbnRZID0gZXZ0LnRvdWNoZXNbMF0ucGFnZVk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdXNlciBpcyBzY3JvbGxpbmcgZG93biB0byB1cFxyXG4gICAgICAgICAgICBpZiAoX3RoaXMuY3VycmVudFkgPCBfdGhpcy5zdGFydFkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5jdXJyZW50WSAtIF90aGlzLnN0YXJ0WSA+PVxyXG4gICAgICAgICAgICAgICAgTnVtYmVyKF90aGlzLnByb3BzLnB1bGxEb3duVG9SZWZyZXNoVGhyZXNob2xkKSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgICAgICAgICAgIHB1bGxUb1JlZnJlc2hUaHJlc2hvbGRCcmVhY2hlZDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHNvIHlvdSBjYW4gZHJhZyB1cHRvIDEuNSB0aW1lcyBvZiB0aGUgbWF4UHVsbERvd25EaXN0YW5jZVxyXG4gICAgICAgICAgICBpZiAoX3RoaXMuY3VycmVudFkgLSBfdGhpcy5zdGFydFkgPiBfdGhpcy5tYXhQdWxsRG93bkRpc3RhbmNlICogMS41KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMuX2luZlNjcm9sbCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2luZlNjcm9sbC5zdHlsZS5vdmVyZmxvdyA9ICd2aXNpYmxlJztcclxuICAgICAgICAgICAgICAgIF90aGlzLl9pbmZTY3JvbGwuc3R5bGUudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUzZCgwcHgsIFwiICsgKF90aGlzLmN1cnJlbnRZIC1cclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdGFydFkpICsgXCJweCwgMHB4KVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBfdGhpcy5vbkVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMuc3RhcnRZID0gMDtcclxuICAgICAgICAgICAgX3RoaXMuY3VycmVudFkgPSAwO1xyXG4gICAgICAgICAgICBfdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUucHVsbFRvUmVmcmVzaFRocmVzaG9sZEJyZWFjaGVkKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5yZWZyZXNoRnVuY3Rpb24gJiYgX3RoaXMucHJvcHMucmVmcmVzaEZ1bmN0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgcHVsbFRvUmVmcmVzaFRocmVzaG9sZEJyZWFjaGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzLl9pbmZTY3JvbGxcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5faW5mU2Nyb2xsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2luZlNjcm9sbC5zdHlsZS5vdmVyZmxvdyA9ICdhdXRvJztcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5faW5mU2Nyb2xsLnN0eWxlLnRyYW5zZm9ybSA9ICdub25lJztcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5faW5mU2Nyb2xsLnN0eWxlLndpbGxDaGFuZ2UgPSAndW5zZXQnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIF90aGlzLm9uU2Nyb2xsTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBfdGhpcy5wcm9wcy5vblNjcm9sbCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgLy8gRXhlY3V0ZSB0aGlzIGNhbGxiYWNrIGluIG5leHQgdGljayBzbyB0aGF0IGl0IGRvZXMgbm90IGFmZmVjdCB0aGVcclxuICAgICAgICAgICAgICAgIC8vIGZ1bmN0aW9uYWxpdHkgb2YgdGhlIGxpYnJhcnkuXHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnByb3BzLm9uU2Nyb2xsICYmIF90aGlzLnByb3BzLm9uU2Nyb2xsKGV2ZW50KTsgfSwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IF90aGlzLnByb3BzLmhlaWdodCB8fCBfdGhpcy5fc2Nyb2xsYWJsZU5vZGVcclxuICAgICAgICAgICAgICAgID8gZXZlbnQudGFyZ2V0XHJcbiAgICAgICAgICAgICAgICA6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3BcclxuICAgICAgICAgICAgICAgICAgICA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgIDogZG9jdW1lbnQuYm9keTtcclxuICAgICAgICAgICAgLy8gcmV0dXJuIGltbWVkaWF0ZWx5IGlmIHRoZSBhY3Rpb24gaGFzIGFscmVhZHkgYmVlbiB0cmlnZ2VyZWQsXHJcbiAgICAgICAgICAgIC8vIHByZXZlbnRzIG11bHRpcGxlIHRyaWdnZXJzLlxyXG4gICAgICAgICAgICBpZiAoX3RoaXMuYWN0aW9uVHJpZ2dlcmVkKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB2YXIgYXRCb3R0b20gPSBfdGhpcy5wcm9wcy5pbnZlcnNlXHJcbiAgICAgICAgICAgICAgICA/IF90aGlzLmlzRWxlbWVudEF0VG9wKHRhcmdldCwgX3RoaXMucHJvcHMuc2Nyb2xsVGhyZXNob2xkKVxyXG4gICAgICAgICAgICAgICAgOiBfdGhpcy5pc0VsZW1lbnRBdEJvdHRvbSh0YXJnZXQsIF90aGlzLnByb3BzLnNjcm9sbFRocmVzaG9sZCk7XHJcbiAgICAgICAgICAgIC8vIGNhbGwgdGhlIGBuZXh0YCBmdW5jdGlvbiBpbiB0aGUgcHJvcHMgdG8gdHJpZ2dlciB0aGUgbmV4dCBkYXRhIGZldGNoXHJcbiAgICAgICAgICAgIGlmIChhdEJvdHRvbSAmJiBfdGhpcy5wcm9wcy5oYXNNb3JlKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5hY3Rpb25UcmlnZ2VyZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBzaG93TG9hZGVyOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMubmV4dCAmJiBfdGhpcy5wcm9wcy5uZXh0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMubGFzdFNjcm9sbFRvcCA9IHRhcmdldC5zY3JvbGxUb3A7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgc2hvd0xvYWRlcjogZmFsc2UsXHJcbiAgICAgICAgICAgIHB1bGxUb1JlZnJlc2hUaHJlc2hvbGRCcmVhY2hlZDogZmFsc2UsXHJcbiAgICAgICAgICAgIHByZXZEYXRhTGVuZ3RoOiBwcm9wcy5kYXRhTGVuZ3RoLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgX3RoaXMudGhyb3R0bGVkT25TY3JvbGxMaXN0ZW5lciA9IHRocm90dGxlKDE1MCwgX3RoaXMub25TY3JvbGxMaXN0ZW5lcikuYmluZChfdGhpcyk7XHJcbiAgICAgICAgX3RoaXMub25TdGFydCA9IF90aGlzLm9uU3RhcnQuYmluZChfdGhpcyk7XHJcbiAgICAgICAgX3RoaXMub25Nb3ZlID0gX3RoaXMub25Nb3ZlLmJpbmQoX3RoaXMpO1xyXG4gICAgICAgIF90aGlzLm9uRW5kID0gX3RoaXMub25FbmQuYmluZChfdGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgSW5maW5pdGVTY3JvbGwucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5wcm9wcy5kYXRhTGVuZ3RoID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYW5kYXRvcnkgcHJvcCBcXFwiZGF0YUxlbmd0aFxcXCIgaXMgbWlzc2luZy4gVGhlIHByb3AgaXMgbmVlZGVkXCIgK1xyXG4gICAgICAgICAgICAgICAgXCIgd2hlbiBsb2FkaW5nIG1vcmUgY29udGVudC4gQ2hlY2sgUkVBRE1FLm1kIGZvciB1c2FnZVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fc2Nyb2xsYWJsZU5vZGUgPSB0aGlzLmdldFNjcm9sbGFibGVUYXJnZXQoKTtcclxuICAgICAgICB0aGlzLmVsID0gdGhpcy5wcm9wcy5oZWlnaHRcclxuICAgICAgICAgICAgPyB0aGlzLl9pbmZTY3JvbGxcclxuICAgICAgICAgICAgOiB0aGlzLl9zY3JvbGxhYmxlTm9kZSB8fCB3aW5kb3c7XHJcbiAgICAgICAgaWYgKHRoaXMuZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzXHJcbiAgICAgICAgICAgICAgICAudGhyb3R0bGVkT25TY3JvbGxMaXN0ZW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5wcm9wcy5pbml0aWFsU2Nyb2xsWSA9PT0gJ251bWJlcicgJiZcclxuICAgICAgICAgICAgdGhpcy5lbCAmJlxyXG4gICAgICAgICAgICB0aGlzLmVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiZcclxuICAgICAgICAgICAgdGhpcy5lbC5zY3JvbGxIZWlnaHQgPiB0aGlzLnByb3BzLmluaXRpYWxTY3JvbGxZKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWwuc2Nyb2xsVG8oMCwgdGhpcy5wcm9wcy5pbml0aWFsU2Nyb2xsWSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnByb3BzLnB1bGxEb3duVG9SZWZyZXNoICYmIHRoaXMuZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vblN0YXJ0KTtcclxuICAgICAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uTW92ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLm9uRW5kKTtcclxuICAgICAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uU3RhcnQpO1xyXG4gICAgICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3ZlKTtcclxuICAgICAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbkVuZCk7XHJcbiAgICAgICAgICAgIC8vIGdldCBCQ1Igb2YgcHVsbERvd24gZWxlbWVudCB0byBwb3NpdGlvbiBpdCBhYm92ZVxyXG4gICAgICAgICAgICB0aGlzLm1heFB1bGxEb3duRGlzdGFuY2UgPVxyXG4gICAgICAgICAgICAgICAgKHRoaXMuX3B1bGxEb3duICYmXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHVsbERvd24uZmlyc3RDaGlsZCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3B1bGxEb3duLmZpcnN0Q2hpbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmhlaWdodCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAwO1xyXG4gICAgICAgICAgICB0aGlzLmZvcmNlVXBkYXRlKCk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5wcm9wcy5yZWZyZXNoRnVuY3Rpb24gIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1hbmRhdG9yeSBwcm9wIFxcXCJyZWZyZXNoRnVuY3Rpb25cXFwiIG1pc3NpbmcuXFxuICAgICAgICAgIFB1bGwgRG93biBUbyBSZWZyZXNoIGZ1bmN0aW9uYWxpdHkgd2lsbCBub3Qgd29ya1xcbiAgICAgICAgICBhcyBleHBlY3RlZC4gQ2hlY2sgUkVBRE1FLm1kIGZvciB1c2FnZSdcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSW5maW5pdGVTY3JvbGwucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpc1xyXG4gICAgICAgICAgICAgICAgLnRocm90dGxlZE9uU2Nyb2xsTGlzdGVuZXIpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5wdWxsRG93blRvUmVmcmVzaCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vblN0YXJ0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5vbk1vdmUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMub25FbmQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uU3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW92ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uRW5kKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBJbmZpbml0ZVNjcm9sbC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xyXG4gICAgICAgIC8vIGRvIG5vdGhpbmcgd2hlbiBkYXRhTGVuZ3RoIGlzIHVuY2hhbmdlZFxyXG4gICAgICAgIGlmICh0aGlzLnByb3BzLmRhdGFMZW5ndGggPT09IHByZXZQcm9wcy5kYXRhTGVuZ3RoKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdGhpcy5hY3Rpb25UcmlnZ2VyZWQgPSBmYWxzZTtcclxuICAgICAgICAvLyB1cGRhdGUgc3RhdGUgd2hlbiBuZXcgZGF0YSB3YXMgc2VudCBpblxyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgICBzaG93TG9hZGVyOiBmYWxzZSxcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBJbmZpbml0ZVNjcm9sbC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBmdW5jdGlvbiAobmV4dFByb3BzLCBwcmV2U3RhdGUpIHtcclxuICAgICAgICB2YXIgZGF0YUxlbmd0aENoYW5nZWQgPSBuZXh0UHJvcHMuZGF0YUxlbmd0aCAhPT0gcHJldlN0YXRlLnByZXZEYXRhTGVuZ3RoO1xyXG4gICAgICAgIC8vIHJlc2V0IHdoZW4gZGF0YSBjaGFuZ2VzXHJcbiAgICAgICAgaWYgKGRhdGFMZW5ndGhDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcHJldlN0YXRlKSwgeyBwcmV2RGF0YUxlbmd0aDogbmV4dFByb3BzLmRhdGFMZW5ndGggfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIEluZmluaXRlU2Nyb2xsLnByb3RvdHlwZS5pc0VsZW1lbnRBdFRvcCA9IGZ1bmN0aW9uICh0YXJnZXQsIHNjcm9sbFRocmVzaG9sZCkge1xyXG4gICAgICAgIGlmIChzY3JvbGxUaHJlc2hvbGQgPT09IHZvaWQgMCkgeyBzY3JvbGxUaHJlc2hvbGQgPSAwLjg7IH1cclxuICAgICAgICB2YXIgY2xpZW50SGVpZ2h0ID0gdGFyZ2V0ID09PSBkb2N1bWVudC5ib2R5IHx8IHRhcmdldCA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XHJcbiAgICAgICAgICAgID8gd2luZG93LnNjcmVlbi5hdmFpbEhlaWdodFxyXG4gICAgICAgICAgICA6IHRhcmdldC5jbGllbnRIZWlnaHQ7XHJcbiAgICAgICAgdmFyIHRocmVzaG9sZCA9IHBhcnNlVGhyZXNob2xkKHNjcm9sbFRocmVzaG9sZCk7XHJcbiAgICAgICAgaWYgKHRocmVzaG9sZC51bml0ID09PSBUaHJlc2hvbGRVbml0cy5QaXhlbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKHRhcmdldC5zY3JvbGxUb3AgPD1cclxuICAgICAgICAgICAgICAgIHRocmVzaG9sZC52YWx1ZSArIGNsaWVudEhlaWdodCAtIHRhcmdldC5zY3JvbGxIZWlnaHQgKyAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICh0YXJnZXQuc2Nyb2xsVG9wIDw9XHJcbiAgICAgICAgICAgIHRocmVzaG9sZC52YWx1ZSAvIDEwMCArIGNsaWVudEhlaWdodCAtIHRhcmdldC5zY3JvbGxIZWlnaHQgKyAxKTtcclxuICAgIH07XHJcbiAgICBJbmZpbml0ZVNjcm9sbC5wcm90b3R5cGUuaXNFbGVtZW50QXRCb3R0b20gPSBmdW5jdGlvbiAodGFyZ2V0LCBzY3JvbGxUaHJlc2hvbGQpIHtcclxuICAgICAgICBpZiAoc2Nyb2xsVGhyZXNob2xkID09PSB2b2lkIDApIHsgc2Nyb2xsVGhyZXNob2xkID0gMC44OyB9XHJcbiAgICAgICAgdmFyIGNsaWVudEhlaWdodCA9IHRhcmdldCA9PT0gZG9jdW1lbnQuYm9keSB8fCB0YXJnZXQgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFxyXG4gICAgICAgICAgICA/IHdpbmRvdy5zY3JlZW4uYXZhaWxIZWlnaHRcclxuICAgICAgICAgICAgOiB0YXJnZXQuY2xpZW50SGVpZ2h0O1xyXG4gICAgICAgIHZhciB0aHJlc2hvbGQgPSBwYXJzZVRocmVzaG9sZChzY3JvbGxUaHJlc2hvbGQpO1xyXG4gICAgICAgIGlmICh0aHJlc2hvbGQudW5pdCA9PT0gVGhyZXNob2xkVW5pdHMuUGl4ZWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuICh0YXJnZXQuc2Nyb2xsVG9wICsgY2xpZW50SGVpZ2h0ID49IHRhcmdldC5zY3JvbGxIZWlnaHQgLSB0aHJlc2hvbGQudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKHRhcmdldC5zY3JvbGxUb3AgKyBjbGllbnRIZWlnaHQgPj1cclxuICAgICAgICAgICAgKHRocmVzaG9sZC52YWx1ZSAvIDEwMCkgKiB0YXJnZXQuc2Nyb2xsSGVpZ2h0KTtcclxuICAgIH07XHJcbiAgICBJbmZpbml0ZVNjcm9sbC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHN0eWxlID0gX19hc3NpZ24oeyBoZWlnaHQ6IHRoaXMucHJvcHMuaGVpZ2h0IHx8ICdhdXRvJywgb3ZlcmZsb3c6ICdhdXRvJywgV2Via2l0T3ZlcmZsb3dTY3JvbGxpbmc6ICd0b3VjaCcgfSwgdGhpcy5wcm9wcy5zdHlsZSk7XHJcbiAgICAgICAgdmFyIGhhc0NoaWxkcmVuID0gdGhpcy5wcm9wcy5oYXNDaGlsZHJlbiB8fFxyXG4gICAgICAgICAgICAhISh0aGlzLnByb3BzLmNoaWxkcmVuICYmXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLmNoaWxkcmVuIGluc3RhbmNlb2YgQXJyYXkgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuY2hpbGRyZW4ubGVuZ3RoKTtcclxuICAgICAgICAvLyBiZWNhdXNlIGhlaWdodGVkIGluZmluaXRlU2Nyb2xsIHZpc3VhbHkgYnJlYWtzXHJcbiAgICAgICAgLy8gb24gZHJhZyBkb3duIGFzIG92ZXJmbG93IGJlY29tZXMgdmlzaWJsZVxyXG4gICAgICAgIHZhciBvdXRlckRpdlN0eWxlID0gdGhpcy5wcm9wcy5wdWxsRG93blRvUmVmcmVzaCAmJiB0aGlzLnByb3BzLmhlaWdodFxyXG4gICAgICAgICAgICA/IHsgb3ZlcmZsb3c6ICdhdXRvJyB9XHJcbiAgICAgICAgICAgIDoge307XHJcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgc3R5bGU6IG91dGVyRGl2U3R5bGUsIGNsYXNzTmFtZTogXCJpbmZpbml0ZS1zY3JvbGwtY29tcG9uZW50X19vdXRlcmRpdlwiIH0sXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiaW5maW5pdGUtc2Nyb2xsLWNvbXBvbmVudCBcIiArICh0aGlzLnByb3BzLmNsYXNzTmFtZSB8fCAnJyksIHJlZjogZnVuY3Rpb24gKGluZlNjcm9sbCkgeyByZXR1cm4gKF90aGlzLl9pbmZTY3JvbGwgPSBpbmZTY3JvbGwpOyB9LCBzdHlsZTogc3R5bGUgfSxcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMucHVsbERvd25Ub1JlZnJlc2ggJiYgKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBzdHlsZTogeyBwb3NpdGlvbjogJ3JlbGF0aXZlJyB9LCByZWY6IGZ1bmN0aW9uIChwdWxsRG93bikgeyByZXR1cm4gKF90aGlzLl9wdWxsRG93biA9IHB1bGxEb3duKTsgfSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IC0xICogdGhpcy5tYXhQdWxsRG93bkRpc3RhbmNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IH0sIHRoaXMuc3RhdGUucHVsbFRvUmVmcmVzaFRocmVzaG9sZEJyZWFjaGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5wcm9wcy5yZWxlYXNlVG9SZWZyZXNoQ29udGVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMucHJvcHMucHVsbERvd25Ub1JlZnJlc2hDb250ZW50KSkpLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5jaGlsZHJlbixcclxuICAgICAgICAgICAgICAgICF0aGlzLnN0YXRlLnNob3dMb2FkZXIgJiZcclxuICAgICAgICAgICAgICAgICAgICAhaGFzQ2hpbGRyZW4gJiZcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLmhhc01vcmUgJiZcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLmxvYWRlcixcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc2hvd0xvYWRlciAmJiB0aGlzLnByb3BzLmhhc01vcmUgJiYgdGhpcy5wcm9wcy5sb2FkZXIsXHJcbiAgICAgICAgICAgICAgICAhdGhpcy5wcm9wcy5oYXNNb3JlICYmIHRoaXMucHJvcHMuZW5kTWVzc2FnZSkpKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gSW5maW5pdGVTY3JvbGw7XHJcbn0oQ29tcG9uZW50KSk7XG5cbmV4cG9ydCBkZWZhdWx0IEluZmluaXRlU2Nyb2xsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXMuanMubWFwXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJDb21wb25lbnQiLCJleHRlbmRTdGF0aWNzIiwiZCIsImIiLCJPYmplY3QiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsIkFycmF5IiwicCIsImhhc093blByb3BlcnR5IiwiX19leHRlbmRzIiwiX18iLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsImNyZWF0ZSIsIl9fYXNzaWduIiwiYXNzaWduIiwidCIsInMiLCJpIiwibiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImNhbGwiLCJhcHBseSIsInRocm90dGxlIiwiZGVsYXkiLCJub1RyYWlsaW5nIiwiY2FsbGJhY2siLCJkZWJvdW5jZU1vZGUiLCJ0aW1lb3V0SUQiLCJjYW5jZWxsZWQiLCJsYXN0RXhlYyIsImNsZWFyRXhpc3RpbmdUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiY2FuY2VsIiwidW5kZWZpbmVkIiwid3JhcHBlciIsInNlbGYiLCJlbGFwc2VkIiwiRGF0ZSIsIm5vdyIsImFyZ3MiLCJleGVjIiwiY2xlYXIiLCJzZXRUaW1lb3V0IiwiVGhyZXNob2xkVW5pdHMiLCJQaXhlbCIsIlBlcmNlbnQiLCJkZWZhdWx0VGhyZXNob2xkIiwidW5pdCIsInZhbHVlIiwicGFyc2VUaHJlc2hvbGQiLCJzY3JvbGxUaHJlc2hvbGQiLCJtYXRjaCIsInBhcnNlRmxvYXQiLCJjb25zb2xlIiwid2FybiIsIkluZmluaXRlU2Nyb2xsIiwiX3N1cGVyIiwicHJvcHMiLCJfdGhpcyIsImxhc3RTY3JvbGxUb3AiLCJhY3Rpb25UcmlnZ2VyZWQiLCJzdGFydFkiLCJjdXJyZW50WSIsImRyYWdnaW5nIiwibWF4UHVsbERvd25EaXN0YW5jZSIsImdldFNjcm9sbGFibGVUYXJnZXQiLCJzY3JvbGxhYmxlVGFyZ2V0IiwiSFRNTEVsZW1lbnQiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwib25TdGFydCIsImV2dCIsIk1vdXNlRXZlbnQiLCJwYWdlWSIsIlRvdWNoRXZlbnQiLCJ0b3VjaGVzIiwiX2luZlNjcm9sbCIsInN0eWxlIiwid2lsbENoYW5nZSIsInRyYW5zaXRpb24iLCJvbk1vdmUiLCJOdW1iZXIiLCJwdWxsRG93blRvUmVmcmVzaFRocmVzaG9sZCIsInNldFN0YXRlIiwicHVsbFRvUmVmcmVzaFRocmVzaG9sZEJyZWFjaGVkIiwib3ZlcmZsb3ciLCJ0cmFuc2Zvcm0iLCJvbkVuZCIsInN0YXRlIiwicmVmcmVzaEZ1bmN0aW9uIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwib25TY3JvbGxMaXN0ZW5lciIsImV2ZW50Iiwib25TY3JvbGwiLCJ0YXJnZXQiLCJoZWlnaHQiLCJfc2Nyb2xsYWJsZU5vZGUiLCJkb2N1bWVudEVsZW1lbnQiLCJzY3JvbGxUb3AiLCJib2R5IiwiYXRCb3R0b20iLCJpbnZlcnNlIiwiaXNFbGVtZW50QXRUb3AiLCJpc0VsZW1lbnRBdEJvdHRvbSIsImhhc01vcmUiLCJzaG93TG9hZGVyIiwibmV4dCIsInByZXZEYXRhTGVuZ3RoIiwiZGF0YUxlbmd0aCIsInRocm90dGxlZE9uU2Nyb2xsTGlzdGVuZXIiLCJiaW5kIiwiY29tcG9uZW50RGlkTW91bnQiLCJFcnJvciIsImVsIiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsImluaXRpYWxTY3JvbGxZIiwic2Nyb2xsSGVpZ2h0Iiwic2Nyb2xsVG8iLCJwdWxsRG93blRvUmVmcmVzaCIsIl9wdWxsRG93biIsImZpcnN0Q2hpbGQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJmb3JjZVVwZGF0ZSIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNvbXBvbmVudERpZFVwZGF0ZSIsInByZXZQcm9wcyIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsIm5leHRQcm9wcyIsInByZXZTdGF0ZSIsImRhdGFMZW5ndGhDaGFuZ2VkIiwiY2xpZW50SGVpZ2h0Iiwic2NyZWVuIiwiYXZhaWxIZWlnaHQiLCJ0aHJlc2hvbGQiLCJyZW5kZXIiLCJXZWJraXRPdmVyZmxvd1Njcm9sbGluZyIsImhhc0NoaWxkcmVuIiwiY2hpbGRyZW4iLCJvdXRlckRpdlN0eWxlIiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZSIsInJlZiIsImluZlNjcm9sbCIsInBvc2l0aW9uIiwicHVsbERvd24iLCJsZWZ0IiwicmlnaHQiLCJ0b3AiLCJyZWxlYXNlVG9SZWZyZXNoQ29udGVudCIsInB1bGxEb3duVG9SZWZyZXNoQ29udGVudCIsImxvYWRlciIsImVuZE1lc3NhZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-infinite-scroll-component/dist/index.es.js\n");

/***/ })

};
;