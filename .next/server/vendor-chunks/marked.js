"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/marked";
exports.ids = ["vendor-chunks/marked"];
exports.modules = {

/***/ "(ssr)/./node_modules/marked/lib/marked.esm.js":
/*!***********************************************!*\
  !*** ./node_modules/marked/lib/marked.esm.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hooks: () => (/* binding */ _Hooks),\n/* harmony export */   Lexer: () => (/* binding */ _Lexer),\n/* harmony export */   Marked: () => (/* binding */ Marked),\n/* harmony export */   Parser: () => (/* binding */ _Parser),\n/* harmony export */   Renderer: () => (/* binding */ _Renderer),\n/* harmony export */   TextRenderer: () => (/* binding */ _TextRenderer),\n/* harmony export */   Tokenizer: () => (/* binding */ _Tokenizer),\n/* harmony export */   defaults: () => (/* binding */ _defaults),\n/* harmony export */   getDefaults: () => (/* binding */ _getDefaults),\n/* harmony export */   lexer: () => (/* binding */ lexer),\n/* harmony export */   marked: () => (/* binding */ marked),\n/* harmony export */   options: () => (/* binding */ options),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   parseInline: () => (/* binding */ parseInline),\n/* harmony export */   parser: () => (/* binding */ parser),\n/* harmony export */   setOptions: () => (/* binding */ setOptions),\n/* harmony export */   use: () => (/* binding */ use),\n/* harmony export */   walkTokens: () => (/* binding */ walkTokens)\n/* harmony export */ });\n/**\n * marked v15.0.4 - a markdown parser\n * Copyright (c) 2011-2024, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */ /**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */ /**\n * Gets the original marked default options.\n */ function _getDefaults() {\n    return {\n        async: false,\n        breaks: false,\n        extensions: null,\n        gfm: true,\n        hooks: null,\n        pedantic: false,\n        renderer: null,\n        silent: false,\n        tokenizer: null,\n        walkTokens: null\n    };\n}\nlet _defaults = _getDefaults();\nfunction changeDefaults(newDefaults) {\n    _defaults = newDefaults;\n}\nconst noopTest = {\n    exec: ()=>null\n};\nfunction edit(regex, opt = \"\") {\n    let source = typeof regex === \"string\" ? regex : regex.source;\n    const obj = {\n        replace: (name, val)=>{\n            let valSource = typeof val === \"string\" ? val : val.source;\n            valSource = valSource.replace(other.caret, \"$1\");\n            source = source.replace(name, valSource);\n            return obj;\n        },\n        getRegex: ()=>{\n            return new RegExp(source, opt);\n        }\n    };\n    return obj;\n}\nconst other = {\n    codeRemoveIndent: /^(?: {1,4}| {0,3}\\t)/gm,\n    outputLinkReplace: /\\\\([\\[\\]])/g,\n    indentCodeCompensation: /^(\\s+)(?:```)/,\n    beginningSpace: /^\\s+/,\n    endingHash: /#$/,\n    startingSpaceChar: /^ /,\n    endingSpaceChar: / $/,\n    nonSpaceChar: /[^ ]/,\n    newLineCharGlobal: /\\n/g,\n    tabCharGlobal: /\\t/g,\n    multipleSpaceGlobal: /\\s+/g,\n    blankLine: /^[ \\t]*$/,\n    doubleBlankLine: /\\n[ \\t]*\\n[ \\t]*$/,\n    blockquoteStart: /^ {0,3}>/,\n    blockquoteSetextReplace: /\\n {0,3}((?:=+|-+) *)(?=\\n|$)/g,\n    blockquoteSetextReplace2: /^ {0,3}>[ \\t]?/gm,\n    listReplaceTabs: /^\\t+/,\n    listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,\n    listIsTask: /^\\[[ xX]\\] /,\n    listReplaceTask: /^\\[[ xX]\\] +/,\n    anyLine: /\\n.*\\n/,\n    hrefBrackets: /^<(.*)>$/,\n    tableDelimiter: /[:|]/,\n    tableAlignChars: /^\\||\\| *$/g,\n    tableRowBlankLine: /\\n[ \\t]*$/,\n    tableAlignRight: /^ *-+: *$/,\n    tableAlignCenter: /^ *:-+: *$/,\n    tableAlignLeft: /^ *:-+ *$/,\n    startATag: /^<a /i,\n    endATag: /^<\\/a>/i,\n    startPreScriptTag: /^<(pre|code|kbd|script)(\\s|>)/i,\n    endPreScriptTag: /^<\\/(pre|code|kbd|script)(\\s|>)/i,\n    startAngleBracket: /^</,\n    endAngleBracket: />$/,\n    pedanticHrefTitle: /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/,\n    unicodeAlphaNumeric: /[\\p{L}\\p{N}]/u,\n    escapeTest: /[&<>\"']/,\n    escapeReplace: /[&<>\"']/g,\n    escapeTestNoEncode: /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/,\n    escapeReplaceNoEncode: /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/g,\n    unescapeTest: /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig,\n    caret: /(^|[^\\[])\\^/g,\n    percentDecode: /%25/g,\n    findPipe: /\\|/g,\n    splitPipe: / \\|/,\n    slashPipe: /\\\\\\|/g,\n    carriageReturn: /\\r\\n|\\r/g,\n    spaceLine: /^ +$/gm,\n    notSpaceStart: /^\\S*/,\n    endingNewline: /\\n$/,\n    listItemRegex: (bull)=>new RegExp(`^( {0,3}${bull})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))`),\n    nextBulletRegex: (indent)=>new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))`),\n    hrRegex: (indent)=>new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`),\n    fencesBeginRegex: (indent)=>new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\\`\\`\\`|~~~)`),\n    headingBeginRegex: (indent)=>new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`),\n    htmlBeginRegex: (indent)=>new RegExp(`^ {0,${Math.min(3, indent - 1)}}<(?:[a-z].*>|!--)`, \"i\")\n};\n/**\n * Block-Level Grammar\n */ const newline = /^(?:[ \\t]*(?:\\n|$))+/;\nconst blockCode = /^((?: {4}| {0,3}\\t)[^\\n]+(?:\\n(?:[ \\t]*(?:\\n|$))*)?)+/;\nconst fences = /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/;\nconst hr = /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/;\nconst heading = /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/;\nconst bullet = /(?:[*+-]|\\d{1,9}[.)])/;\nconst lheading = edit(/^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\\n(?!\\s*?\\n|bull |blockCode|fences|blockquote|heading|html))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/).replace(/bull/g, bullet) // lists can interrupt\n.replace(/blockCode/g, /(?: {4}| {0,3}\\t)/) // indented code blocks can interrupt\n.replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt\n.replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt\n.replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt\n.replace(/html/g, / {0,3}<[^\\n>]+>\\n/) // block html can interrupt\n.getRegex();\nconst _paragraph = /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/;\nconst blockText = /^[^\\n]+/;\nconst _blockLabel = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\nconst def = edit(/^ {0,3}\\[(label)\\]: *(?:\\n[ \\t]*)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n[ \\t]*)?| *\\n[ \\t]*)(title))? *(?:\\n+|$)/).replace(\"label\", _blockLabel).replace(\"title\", /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/).getRegex();\nconst list = edit(/^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/).replace(/bull/g, bullet).getRegex();\nconst _tag = \"address|article|aside|base|basefont|blockquote|body|caption\" + \"|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption\" + \"|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe\" + \"|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option\" + \"|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title\" + \"|tr|track|ul\";\nconst _comment = /<!--(?:-?>|[\\s\\S]*?(?:-->|$))/;\nconst html = edit(\"^ {0,3}(?:\" // optional indentation\n + \"<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)\" // (1)\n + \"|comment[^\\\\n]*(\\\\n+|$)\" // (2)\n + \"|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)\" // (3)\n + \"|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)\" // (4)\n + \"|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)\" // (5)\n + \"|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n[ \t]*)+\\\\n|$)\" // (6)\n + \"|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \t]*)+\\\\n|$)\" // (7) open tag\n + \"|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \t]*)+\\\\n|$)\" // (7) closing tag\n + \")\", \"i\").replace(\"comment\", _comment).replace(\"tag\", _tag).replace(\"attribute\", / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/).getRegex();\nconst paragraph = edit(_paragraph).replace(\"hr\", hr).replace(\"heading\", \" {0,3}#{1,6}(?:\\\\s|$)\").replace(\"|lheading\", \"\") // setext headings don't interrupt commonmark paragraphs\n.replace(\"|table\", \"\").replace(\"blockquote\", \" {0,3}>\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \") // only lists starting from 1 can interrupt\n.replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", _tag) // pars can be interrupted by type (6) html blocks\n.getRegex();\nconst blockquote = edit(/^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/).replace(\"paragraph\", paragraph).getRegex();\n/**\n * Normal Block Grammar\n */ const blockNormal = {\n    blockquote,\n    code: blockCode,\n    def,\n    fences,\n    heading,\n    hr,\n    html,\n    lheading,\n    list,\n    newline,\n    paragraph,\n    table: noopTest,\n    text: blockText\n};\n/**\n * GFM Block Grammar\n */ const gfmTable = edit(\"^ *([^\\\\n ].*)\\\\n\" // Header\n + \" {0,3}((?:\\\\| *)?:?-+:? *(?:\\\\| *:?-+:? *)*(?:\\\\| *)?)\" // Align\n + \"(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)\") // Cells\n.replace(\"hr\", hr).replace(\"heading\", \" {0,3}#{1,6}(?:\\\\s|$)\").replace(\"blockquote\", \" {0,3}>\").replace(\"code\", \"(?: {4}| {0,3}\t)[^\\\\n]\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \") // only lists starting from 1 can interrupt\n.replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", _tag) // tables can be interrupted by type (6) html blocks\n.getRegex();\nconst blockGfm = {\n    ...blockNormal,\n    table: gfmTable,\n    paragraph: edit(_paragraph).replace(\"hr\", hr).replace(\"heading\", \" {0,3}#{1,6}(?:\\\\s|$)\").replace(\"|lheading\", \"\") // setext headings don't interrupt commonmark paragraphs\n    .replace(\"table\", gfmTable) // interrupt paragraphs with table\n    .replace(\"blockquote\", \" {0,3}>\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \") // only lists starting from 1 can interrupt\n    .replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", _tag) // pars can be interrupted by type (6) html blocks\n    .getRegex()\n};\n/**\n * Pedantic grammar (original John Gruber's loose markdown specification)\n */ const blockPedantic = {\n    ...blockNormal,\n    html: edit(\"^ *(?:comment *(?:\\\\n|\\\\s*$)\" + \"|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)\" // closed tag\n     + \"|<tag(?:\\\"[^\\\"]*\\\"|'[^']*'|\\\\s[^'\\\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))\").replace(\"comment\", _comment).replace(/tag/g, \"(?!(?:\" + \"a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub\" + \"|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\" + \"\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b\").getRegex(),\n    def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n    heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n    fences: noopTest,\n    lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n    paragraph: edit(_paragraph).replace(\"hr\", hr).replace(\"heading\", \" *#{1,6} *[^\\n]\").replace(\"lheading\", lheading).replace(\"|table\", \"\").replace(\"blockquote\", \" {0,3}>\").replace(\"|fences\", \"\").replace(\"|list\", \"\").replace(\"|html\", \"\").replace(\"|tag\", \"\").getRegex()\n};\n/**\n * Inline-Level Grammar\n */ const escape$1 = /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/;\nconst inlineCode = /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/;\nconst br = /^( {2,}|\\\\)\\n(?!\\s*$)/;\nconst inlineText = /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/;\n// list of unicode punctuation marks, plus any missing characters from CommonMark spec\nconst _punctuation = /[\\p{P}\\p{S}]/u;\nconst _punctuationOrSpace = /[\\s\\p{P}\\p{S}]/u;\nconst _notPunctuationOrSpace = /[^\\s\\p{P}\\p{S}]/u;\nconst punctuation = edit(/^((?![*_])punctSpace)/, \"u\").replace(/punctSpace/g, _punctuationOrSpace).getRegex();\n// sequences em should skip over [title](link), `code`, <html>\nconst blockSkip = /\\[[^[\\]]*?\\]\\((?:\\\\.|[^\\\\\\(\\)]|\\((?:\\\\.|[^\\\\\\(\\)])*\\))*\\)|`[^`]*?`|<[^<>]*?>/g;\nconst emStrongLDelim = edit(/^(?:\\*+(?:((?!\\*)punct)|[^\\s*]))|^_+(?:((?!_)punct)|([^\\s_]))/, \"u\").replace(/punct/g, _punctuation).getRegex();\nconst emStrongRDelimAst = edit(\"^[^_*]*?__[^_*]*?\\\\*[^_*]*?(?=__)\" // Skip orphan inside strong\n + \"|[^*]+(?=[^*])\" // Consume to delim\n + \"|(?!\\\\*)punct(\\\\*+)(?=[\\\\s]|$)\" // (1) #*** can only be a Right Delimiter\n + \"|notPunctSpace(\\\\*+)(?!\\\\*)(?=punctSpace|$)\" // (2) a***#, a*** can only be a Right Delimiter\n + \"|(?!\\\\*)punctSpace(\\\\*+)(?=notPunctSpace)\" // (3) #***a, ***a can only be Left Delimiter\n + \"|[\\\\s](\\\\*+)(?!\\\\*)(?=punct)\" // (4) ***# can only be Left Delimiter\n + \"|(?!\\\\*)punct(\\\\*+)(?!\\\\*)(?=punct)\" // (5) #***# can be either Left or Right Delimiter\n + \"|notPunctSpace(\\\\*+)(?=notPunctSpace)\", \"gu\") // (6) a***a can be either Left or Right Delimiter\n.replace(/notPunctSpace/g, _notPunctuationOrSpace).replace(/punctSpace/g, _punctuationOrSpace).replace(/punct/g, _punctuation).getRegex();\n// (6) Not allowed for _\nconst emStrongRDelimUnd = edit(\"^[^_*]*?\\\\*\\\\*[^_*]*?_[^_*]*?(?=\\\\*\\\\*)\" // Skip orphan inside strong\n + \"|[^_]+(?=[^_])\" // Consume to delim\n + \"|(?!_)punct(_+)(?=[\\\\s]|$)\" // (1) #___ can only be a Right Delimiter\n + \"|notPunctSpace(_+)(?!_)(?=punctSpace|$)\" // (2) a___#, a___ can only be a Right Delimiter\n + \"|(?!_)punctSpace(_+)(?=notPunctSpace)\" // (3) #___a, ___a can only be Left Delimiter\n + \"|[\\\\s](_+)(?!_)(?=punct)\" // (4) ___# can only be Left Delimiter\n + \"|(?!_)punct(_+)(?!_)(?=punct)\", \"gu\") // (5) #___# can be either Left or Right Delimiter\n.replace(/notPunctSpace/g, _notPunctuationOrSpace).replace(/punctSpace/g, _punctuationOrSpace).replace(/punct/g, _punctuation).getRegex();\nconst anyPunctuation = edit(/\\\\(punct)/, \"gu\").replace(/punct/g, _punctuation).getRegex();\nconst autolink = edit(/^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/).replace(\"scheme\", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace(\"email\", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex();\nconst _inlineComment = edit(_comment).replace(\"(?:-->|$)\", \"-->\").getRegex();\nconst tag = edit(\"^comment\" + \"|^</[a-zA-Z][\\\\w:-]*\\\\s*>\" // self-closing tag\n + \"|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>\" // open tag\n + \"|^<\\\\?[\\\\s\\\\S]*?\\\\?>\" // processing instruction, e.g. <?php ?>\n + \"|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>\" // declaration, e.g. <!DOCTYPE html>\n + \"|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>\") // CDATA section\n.replace(\"comment\", _inlineComment).replace(\"attribute\", /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/).getRegex();\nconst _inlineLabel = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\nconst link = edit(/^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/).replace(\"label\", _inlineLabel).replace(\"href\", /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/).replace(\"title\", /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/).getRegex();\nconst reflink = edit(/^!?\\[(label)\\]\\[(ref)\\]/).replace(\"label\", _inlineLabel).replace(\"ref\", _blockLabel).getRegex();\nconst nolink = edit(/^!?\\[(ref)\\](?:\\[\\])?/).replace(\"ref\", _blockLabel).getRegex();\nconst reflinkSearch = edit(\"reflink|nolink(?!\\\\()\", \"g\").replace(\"reflink\", reflink).replace(\"nolink\", nolink).getRegex();\n/**\n * Normal Inline Grammar\n */ const inlineNormal = {\n    _backpedal: noopTest,\n    anyPunctuation,\n    autolink,\n    blockSkip,\n    br,\n    code: inlineCode,\n    del: noopTest,\n    emStrongLDelim,\n    emStrongRDelimAst,\n    emStrongRDelimUnd,\n    escape: escape$1,\n    link,\n    nolink,\n    punctuation,\n    reflink,\n    reflinkSearch,\n    tag,\n    text: inlineText,\n    url: noopTest\n};\n/**\n * Pedantic Inline Grammar\n */ const inlinePedantic = {\n    ...inlineNormal,\n    link: edit(/^!?\\[(label)\\]\\((.*?)\\)/).replace(\"label\", _inlineLabel).getRegex(),\n    reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/).replace(\"label\", _inlineLabel).getRegex()\n};\n/**\n * GFM Inline Grammar\n */ const inlineGfm = {\n    ...inlineNormal,\n    escape: edit(escape$1).replace(\"])\", \"~|])\").getRegex(),\n    url: edit(/^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/, \"i\").replace(\"email\", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),\n    _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n    del: /^(~~?)(?=[^\\s~])((?:\\\\.|[^\\\\])*?(?:\\\\.|[^\\s~\\\\]))\\1(?=[^~]|$)/,\n    text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/\n};\n/**\n * GFM + Line Breaks Inline Grammar\n */ const inlineBreaks = {\n    ...inlineGfm,\n    br: edit(br).replace(\"{2,}\", \"*\").getRegex(),\n    text: edit(inlineGfm.text).replace(\"\\\\b_\", \"\\\\b_| {2,}\\\\n\").replace(/\\{2,\\}/g, \"*\").getRegex()\n};\n/**\n * exports\n */ const block = {\n    normal: blockNormal,\n    gfm: blockGfm,\n    pedantic: blockPedantic\n};\nconst inline = {\n    normal: inlineNormal,\n    gfm: inlineGfm,\n    breaks: inlineBreaks,\n    pedantic: inlinePedantic\n};\n/**\n * Helpers\n */ const escapeReplacements = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#39;\"\n};\nconst getEscapeReplacement = (ch)=>escapeReplacements[ch];\nfunction escape(html, encode) {\n    if (encode) {\n        if (other.escapeTest.test(html)) {\n            return html.replace(other.escapeReplace, getEscapeReplacement);\n        }\n    } else {\n        if (other.escapeTestNoEncode.test(html)) {\n            return html.replace(other.escapeReplaceNoEncode, getEscapeReplacement);\n        }\n    }\n    return html;\n}\nfunction cleanUrl(href) {\n    try {\n        href = encodeURI(href).replace(other.percentDecode, \"%\");\n    } catch  {\n        return null;\n    }\n    return href;\n}\nfunction splitCells(tableRow, count) {\n    // ensure that every cell-delimiting pipe has a space\n    // before it to distinguish it from an escaped pipe\n    const row = tableRow.replace(other.findPipe, (match, offset, str)=>{\n        let escaped = false;\n        let curr = offset;\n        while(--curr >= 0 && str[curr] === \"\\\\\")escaped = !escaped;\n        if (escaped) {\n            // odd number of slashes means | is escaped\n            // so we leave it alone\n            return \"|\";\n        } else {\n            // add space before unescaped |\n            return \" |\";\n        }\n    }), cells = row.split(other.splitPipe);\n    let i = 0;\n    // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n    if (!cells[0].trim()) {\n        cells.shift();\n    }\n    if (cells.length > 0 && !cells.at(-1)?.trim()) {\n        cells.pop();\n    }\n    if (count) {\n        if (cells.length > count) {\n            cells.splice(count);\n        } else {\n            while(cells.length < count)cells.push(\"\");\n        }\n    }\n    for(; i < cells.length; i++){\n        // leading or trailing whitespace is ignored per the gfm spec\n        cells[i] = cells[i].trim().replace(other.slashPipe, \"|\");\n    }\n    return cells;\n}\n/**\n * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n * /c*$/ is vulnerable to REDOS.\n *\n * @param str\n * @param c\n * @param invert Remove suffix of non-c chars instead. Default falsey.\n */ function rtrim(str, c, invert) {\n    const l = str.length;\n    if (l === 0) {\n        return \"\";\n    }\n    // Length of suffix matching the invert condition.\n    let suffLen = 0;\n    // Step left until we fail to match the invert condition.\n    while(suffLen < l){\n        const currChar = str.charAt(l - suffLen - 1);\n        if (currChar === c && !invert) {\n            suffLen++;\n        } else if (currChar !== c && invert) {\n            suffLen++;\n        } else {\n            break;\n        }\n    }\n    return str.slice(0, l - suffLen);\n}\nfunction findClosingBracket(str, b) {\n    if (str.indexOf(b[1]) === -1) {\n        return -1;\n    }\n    let level = 0;\n    for(let i = 0; i < str.length; i++){\n        if (str[i] === \"\\\\\") {\n            i++;\n        } else if (str[i] === b[0]) {\n            level++;\n        } else if (str[i] === b[1]) {\n            level--;\n            if (level < 0) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}\nfunction outputLink(cap, link, raw, lexer, rules) {\n    const href = link.href;\n    const title = link.title || null;\n    const text = cap[1].replace(rules.other.outputLinkReplace, \"$1\");\n    if (cap[0].charAt(0) !== \"!\") {\n        lexer.state.inLink = true;\n        const token = {\n            type: \"link\",\n            raw,\n            href,\n            title,\n            text,\n            tokens: lexer.inlineTokens(text)\n        };\n        lexer.state.inLink = false;\n        return token;\n    }\n    return {\n        type: \"image\",\n        raw,\n        href,\n        title,\n        text\n    };\n}\nfunction indentCodeCompensation(raw, text, rules) {\n    const matchIndentToCode = raw.match(rules.other.indentCodeCompensation);\n    if (matchIndentToCode === null) {\n        return text;\n    }\n    const indentToCode = matchIndentToCode[1];\n    return text.split(\"\\n\").map((node)=>{\n        const matchIndentInNode = node.match(rules.other.beginningSpace);\n        if (matchIndentInNode === null) {\n            return node;\n        }\n        const [indentInNode] = matchIndentInNode;\n        if (indentInNode.length >= indentToCode.length) {\n            return node.slice(indentToCode.length);\n        }\n        return node;\n    }).join(\"\\n\");\n}\n/**\n * Tokenizer\n */ class _Tokenizer {\n    constructor(options){\n        this.options = options || _defaults;\n    }\n    space(src) {\n        const cap = this.rules.block.newline.exec(src);\n        if (cap && cap[0].length > 0) {\n            return {\n                type: \"space\",\n                raw: cap[0]\n            };\n        }\n    }\n    code(src) {\n        const cap = this.rules.block.code.exec(src);\n        if (cap) {\n            const text = cap[0].replace(this.rules.other.codeRemoveIndent, \"\");\n            return {\n                type: \"code\",\n                raw: cap[0],\n                codeBlockStyle: \"indented\",\n                text: !this.options.pedantic ? rtrim(text, \"\\n\") : text\n            };\n        }\n    }\n    fences(src) {\n        const cap = this.rules.block.fences.exec(src);\n        if (cap) {\n            const raw = cap[0];\n            const text = indentCodeCompensation(raw, cap[3] || \"\", this.rules);\n            return {\n                type: \"code\",\n                raw,\n                lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, \"$1\") : cap[2],\n                text\n            };\n        }\n    }\n    heading(src) {\n        const cap = this.rules.block.heading.exec(src);\n        if (cap) {\n            let text = cap[2].trim();\n            // remove trailing #s\n            if (this.rules.other.endingHash.test(text)) {\n                const trimmed = rtrim(text, \"#\");\n                if (this.options.pedantic) {\n                    text = trimmed.trim();\n                } else if (!trimmed || this.rules.other.endingSpaceChar.test(trimmed)) {\n                    // CommonMark requires space before trailing #s\n                    text = trimmed.trim();\n                }\n            }\n            return {\n                type: \"heading\",\n                raw: cap[0],\n                depth: cap[1].length,\n                text,\n                tokens: this.lexer.inline(text)\n            };\n        }\n    }\n    hr(src) {\n        const cap = this.rules.block.hr.exec(src);\n        if (cap) {\n            return {\n                type: \"hr\",\n                raw: rtrim(cap[0], \"\\n\")\n            };\n        }\n    }\n    blockquote(src) {\n        const cap = this.rules.block.blockquote.exec(src);\n        if (cap) {\n            let lines = rtrim(cap[0], \"\\n\").split(\"\\n\");\n            let raw = \"\";\n            let text = \"\";\n            const tokens = [];\n            while(lines.length > 0){\n                let inBlockquote = false;\n                const currentLines = [];\n                let i;\n                for(i = 0; i < lines.length; i++){\n                    // get lines up to a continuation\n                    if (this.rules.other.blockquoteStart.test(lines[i])) {\n                        currentLines.push(lines[i]);\n                        inBlockquote = true;\n                    } else if (!inBlockquote) {\n                        currentLines.push(lines[i]);\n                    } else {\n                        break;\n                    }\n                }\n                lines = lines.slice(i);\n                const currentRaw = currentLines.join(\"\\n\");\n                const currentText = currentRaw// precede setext continuation with 4 spaces so it isn't a setext\n                .replace(this.rules.other.blockquoteSetextReplace, \"\\n    $1\").replace(this.rules.other.blockquoteSetextReplace2, \"\");\n                raw = raw ? `${raw}\\n${currentRaw}` : currentRaw;\n                text = text ? `${text}\\n${currentText}` : currentText;\n                // parse blockquote lines as top level tokens\n                // merge paragraphs if this is a continuation\n                const top = this.lexer.state.top;\n                this.lexer.state.top = true;\n                this.lexer.blockTokens(currentText, tokens, true);\n                this.lexer.state.top = top;\n                // if there is no continuation then we are done\n                if (lines.length === 0) {\n                    break;\n                }\n                const lastToken = tokens.at(-1);\n                if (lastToken?.type === \"code\") {\n                    break;\n                } else if (lastToken?.type === \"blockquote\") {\n                    // include continuation in nested blockquote\n                    const oldToken = lastToken;\n                    const newText = oldToken.raw + \"\\n\" + lines.join(\"\\n\");\n                    const newToken = this.blockquote(newText);\n                    tokens[tokens.length - 1] = newToken;\n                    raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;\n                    text = text.substring(0, text.length - oldToken.text.length) + newToken.text;\n                    break;\n                } else if (lastToken?.type === \"list\") {\n                    // include continuation in nested list\n                    const oldToken = lastToken;\n                    const newText = oldToken.raw + \"\\n\" + lines.join(\"\\n\");\n                    const newToken = this.list(newText);\n                    tokens[tokens.length - 1] = newToken;\n                    raw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;\n                    text = text.substring(0, text.length - oldToken.raw.length) + newToken.raw;\n                    lines = newText.substring(tokens.at(-1).raw.length).split(\"\\n\");\n                    continue;\n                }\n            }\n            return {\n                type: \"blockquote\",\n                raw,\n                tokens,\n                text\n            };\n        }\n    }\n    list(src) {\n        let cap = this.rules.block.list.exec(src);\n        if (cap) {\n            let bull = cap[1].trim();\n            const isordered = bull.length > 1;\n            const list = {\n                type: \"list\",\n                raw: \"\",\n                ordered: isordered,\n                start: isordered ? +bull.slice(0, -1) : \"\",\n                loose: false,\n                items: []\n            };\n            bull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n            if (this.options.pedantic) {\n                bull = isordered ? bull : \"[*+-]\";\n            }\n            // Get next list item\n            const itemRegex = this.rules.other.listItemRegex(bull);\n            let endsWithBlankLine = false;\n            // Check if current bullet point can start a new List Item\n            while(src){\n                let endEarly = false;\n                let raw = \"\";\n                let itemContents = \"\";\n                if (!(cap = itemRegex.exec(src))) {\n                    break;\n                }\n                if (this.rules.block.hr.test(src)) {\n                    break;\n                }\n                raw = cap[0];\n                src = src.substring(raw.length);\n                let line = cap[2].split(\"\\n\", 1)[0].replace(this.rules.other.listReplaceTabs, (t)=>\" \".repeat(3 * t.length));\n                let nextLine = src.split(\"\\n\", 1)[0];\n                let blankLine = !line.trim();\n                let indent = 0;\n                if (this.options.pedantic) {\n                    indent = 2;\n                    itemContents = line.trimStart();\n                } else if (blankLine) {\n                    indent = cap[1].length + 1;\n                } else {\n                    indent = cap[2].search(this.rules.other.nonSpaceChar); // Find first non-space char\n                    indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n                    itemContents = line.slice(indent);\n                    indent += cap[1].length;\n                }\n                if (blankLine && this.rules.other.blankLine.test(nextLine)) {\n                    raw += nextLine + \"\\n\";\n                    src = src.substring(nextLine.length + 1);\n                    endEarly = true;\n                }\n                if (!endEarly) {\n                    const nextBulletRegex = this.rules.other.nextBulletRegex(indent);\n                    const hrRegex = this.rules.other.hrRegex(indent);\n                    const fencesBeginRegex = this.rules.other.fencesBeginRegex(indent);\n                    const headingBeginRegex = this.rules.other.headingBeginRegex(indent);\n                    const htmlBeginRegex = this.rules.other.htmlBeginRegex(indent);\n                    // Check if following lines should be included in List Item\n                    while(src){\n                        const rawLine = src.split(\"\\n\", 1)[0];\n                        let nextLineWithoutTabs;\n                        nextLine = rawLine;\n                        // Re-align to follow commonmark nesting rules\n                        if (this.options.pedantic) {\n                            nextLine = nextLine.replace(this.rules.other.listReplaceNesting, \"  \");\n                            nextLineWithoutTabs = nextLine;\n                        } else {\n                            nextLineWithoutTabs = nextLine.replace(this.rules.other.tabCharGlobal, \"    \");\n                        }\n                        // End list item if found code fences\n                        if (fencesBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of new heading\n                        if (headingBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of html block\n                        if (htmlBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of new bullet\n                        if (nextBulletRegex.test(nextLine)) {\n                            break;\n                        }\n                        // Horizontal rule found\n                        if (hrRegex.test(nextLine)) {\n                            break;\n                        }\n                        if (nextLineWithoutTabs.search(this.rules.other.nonSpaceChar) >= indent || !nextLine.trim()) {\n                            itemContents += \"\\n\" + nextLineWithoutTabs.slice(indent);\n                        } else {\n                            // not enough indentation\n                            if (blankLine) {\n                                break;\n                            }\n                            // paragraph continuation unless last line was a different block level element\n                            if (line.replace(this.rules.other.tabCharGlobal, \"    \").search(this.rules.other.nonSpaceChar) >= 4) {\n                                break;\n                            }\n                            if (fencesBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (headingBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (hrRegex.test(line)) {\n                                break;\n                            }\n                            itemContents += \"\\n\" + nextLine;\n                        }\n                        if (!blankLine && !nextLine.trim()) {\n                            blankLine = true;\n                        }\n                        raw += rawLine + \"\\n\";\n                        src = src.substring(rawLine.length + 1);\n                        line = nextLineWithoutTabs.slice(indent);\n                    }\n                }\n                if (!list.loose) {\n                    // If the previous item ended with a blank line, the list is loose\n                    if (endsWithBlankLine) {\n                        list.loose = true;\n                    } else if (this.rules.other.doubleBlankLine.test(raw)) {\n                        endsWithBlankLine = true;\n                    }\n                }\n                let istask = null;\n                let ischecked;\n                // Check for task list items\n                if (this.options.gfm) {\n                    istask = this.rules.other.listIsTask.exec(itemContents);\n                    if (istask) {\n                        ischecked = istask[0] !== \"[ ] \";\n                        itemContents = itemContents.replace(this.rules.other.listReplaceTask, \"\");\n                    }\n                }\n                list.items.push({\n                    type: \"list_item\",\n                    raw,\n                    task: !!istask,\n                    checked: ischecked,\n                    loose: false,\n                    text: itemContents,\n                    tokens: []\n                });\n                list.raw += raw;\n            }\n            // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n            const lastItem = list.items.at(-1);\n            if (lastItem) {\n                lastItem.raw = lastItem.raw.trimEnd();\n                lastItem.text = lastItem.text.trimEnd();\n            } else {\n                // not a list since there were no items\n                return;\n            }\n            list.raw = list.raw.trimEnd();\n            // Item child tokens handled here at end because we needed to have the final item to trim it first\n            for(let i = 0; i < list.items.length; i++){\n                this.lexer.state.top = false;\n                list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n                if (!list.loose) {\n                    // Check if list should be loose\n                    const spacers = list.items[i].tokens.filter((t)=>t.type === \"space\");\n                    const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t)=>this.rules.other.anyLine.test(t.raw));\n                    list.loose = hasMultipleLineBreaks;\n                }\n            }\n            // Set all items to loose if list is loose\n            if (list.loose) {\n                for(let i = 0; i < list.items.length; i++){\n                    list.items[i].loose = true;\n                }\n            }\n            return list;\n        }\n    }\n    html(src) {\n        const cap = this.rules.block.html.exec(src);\n        if (cap) {\n            const token = {\n                type: \"html\",\n                block: true,\n                raw: cap[0],\n                pre: cap[1] === \"pre\" || cap[1] === \"script\" || cap[1] === \"style\",\n                text: cap[0]\n            };\n            return token;\n        }\n    }\n    def(src) {\n        const cap = this.rules.block.def.exec(src);\n        if (cap) {\n            const tag = cap[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, \" \");\n            const href = cap[2] ? cap[2].replace(this.rules.other.hrefBrackets, \"$1\").replace(this.rules.inline.anyPunctuation, \"$1\") : \"\";\n            const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, \"$1\") : cap[3];\n            return {\n                type: \"def\",\n                tag,\n                raw: cap[0],\n                href,\n                title\n            };\n        }\n    }\n    table(src) {\n        const cap = this.rules.block.table.exec(src);\n        if (!cap) {\n            return;\n        }\n        if (!this.rules.other.tableDelimiter.test(cap[2])) {\n            // delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading\n            return;\n        }\n        const headers = splitCells(cap[1]);\n        const aligns = cap[2].replace(this.rules.other.tableAlignChars, \"\").split(\"|\");\n        const rows = cap[3]?.trim() ? cap[3].replace(this.rules.other.tableRowBlankLine, \"\").split(\"\\n\") : [];\n        const item = {\n            type: \"table\",\n            raw: cap[0],\n            header: [],\n            align: [],\n            rows: []\n        };\n        if (headers.length !== aligns.length) {\n            // header and align columns must be equal, rows can be different.\n            return;\n        }\n        for (const align of aligns){\n            if (this.rules.other.tableAlignRight.test(align)) {\n                item.align.push(\"right\");\n            } else if (this.rules.other.tableAlignCenter.test(align)) {\n                item.align.push(\"center\");\n            } else if (this.rules.other.tableAlignLeft.test(align)) {\n                item.align.push(\"left\");\n            } else {\n                item.align.push(null);\n            }\n        }\n        for(let i = 0; i < headers.length; i++){\n            item.header.push({\n                text: headers[i],\n                tokens: this.lexer.inline(headers[i]),\n                header: true,\n                align: item.align[i]\n            });\n        }\n        for (const row of rows){\n            item.rows.push(splitCells(row, item.header.length).map((cell, i)=>{\n                return {\n                    text: cell,\n                    tokens: this.lexer.inline(cell),\n                    header: false,\n                    align: item.align[i]\n                };\n            }));\n        }\n        return item;\n    }\n    lheading(src) {\n        const cap = this.rules.block.lheading.exec(src);\n        if (cap) {\n            return {\n                type: \"heading\",\n                raw: cap[0],\n                depth: cap[2].charAt(0) === \"=\" ? 1 : 2,\n                text: cap[1],\n                tokens: this.lexer.inline(cap[1])\n            };\n        }\n    }\n    paragraph(src) {\n        const cap = this.rules.block.paragraph.exec(src);\n        if (cap) {\n            const text = cap[1].charAt(cap[1].length - 1) === \"\\n\" ? cap[1].slice(0, -1) : cap[1];\n            return {\n                type: \"paragraph\",\n                raw: cap[0],\n                text,\n                tokens: this.lexer.inline(text)\n            };\n        }\n    }\n    text(src) {\n        const cap = this.rules.block.text.exec(src);\n        if (cap) {\n            return {\n                type: \"text\",\n                raw: cap[0],\n                text: cap[0],\n                tokens: this.lexer.inline(cap[0])\n            };\n        }\n    }\n    escape(src) {\n        const cap = this.rules.inline.escape.exec(src);\n        if (cap) {\n            return {\n                type: \"escape\",\n                raw: cap[0],\n                text: cap[1]\n            };\n        }\n    }\n    tag(src) {\n        const cap = this.rules.inline.tag.exec(src);\n        if (cap) {\n            if (!this.lexer.state.inLink && this.rules.other.startATag.test(cap[0])) {\n                this.lexer.state.inLink = true;\n            } else if (this.lexer.state.inLink && this.rules.other.endATag.test(cap[0])) {\n                this.lexer.state.inLink = false;\n            }\n            if (!this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(cap[0])) {\n                this.lexer.state.inRawBlock = true;\n            } else if (this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(cap[0])) {\n                this.lexer.state.inRawBlock = false;\n            }\n            return {\n                type: \"html\",\n                raw: cap[0],\n                inLink: this.lexer.state.inLink,\n                inRawBlock: this.lexer.state.inRawBlock,\n                block: false,\n                text: cap[0]\n            };\n        }\n    }\n    link(src) {\n        const cap = this.rules.inline.link.exec(src);\n        if (cap) {\n            const trimmedUrl = cap[2].trim();\n            if (!this.options.pedantic && this.rules.other.startAngleBracket.test(trimmedUrl)) {\n                // commonmark requires matching angle brackets\n                if (!this.rules.other.endAngleBracket.test(trimmedUrl)) {\n                    return;\n                }\n                // ending angle bracket cannot be escaped\n                const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), \"\\\\\");\n                if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n                    return;\n                }\n            } else {\n                // find closing parenthesis\n                const lastParenIndex = findClosingBracket(cap[2], \"()\");\n                if (lastParenIndex > -1) {\n                    const start = cap[0].indexOf(\"!\") === 0 ? 5 : 4;\n                    const linkLen = start + cap[1].length + lastParenIndex;\n                    cap[2] = cap[2].substring(0, lastParenIndex);\n                    cap[0] = cap[0].substring(0, linkLen).trim();\n                    cap[3] = \"\";\n                }\n            }\n            let href = cap[2];\n            let title = \"\";\n            if (this.options.pedantic) {\n                // split pedantic href and title\n                const link = this.rules.other.pedanticHrefTitle.exec(href);\n                if (link) {\n                    href = link[1];\n                    title = link[3];\n                }\n            } else {\n                title = cap[3] ? cap[3].slice(1, -1) : \"\";\n            }\n            href = href.trim();\n            if (this.rules.other.startAngleBracket.test(href)) {\n                if (this.options.pedantic && !this.rules.other.endAngleBracket.test(trimmedUrl)) {\n                    // pedantic allows starting angle bracket without ending angle bracket\n                    href = href.slice(1);\n                } else {\n                    href = href.slice(1, -1);\n                }\n            }\n            return outputLink(cap, {\n                href: href ? href.replace(this.rules.inline.anyPunctuation, \"$1\") : href,\n                title: title ? title.replace(this.rules.inline.anyPunctuation, \"$1\") : title\n            }, cap[0], this.lexer, this.rules);\n        }\n    }\n    reflink(src, links) {\n        let cap;\n        if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {\n            const linkString = (cap[2] || cap[1]).replace(this.rules.other.multipleSpaceGlobal, \" \");\n            const link = links[linkString.toLowerCase()];\n            if (!link) {\n                const text = cap[0].charAt(0);\n                return {\n                    type: \"text\",\n                    raw: text,\n                    text\n                };\n            }\n            return outputLink(cap, link, cap[0], this.lexer, this.rules);\n        }\n    }\n    emStrong(src, maskedSrc, prevChar = \"\") {\n        let match = this.rules.inline.emStrongLDelim.exec(src);\n        if (!match) return;\n        // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n        if (match[3] && prevChar.match(this.rules.other.unicodeAlphaNumeric)) return;\n        const nextChar = match[1] || match[2] || \"\";\n        if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {\n            // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)\n            const lLength = [\n                ...match[0]\n            ].length - 1;\n            let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n            const endReg = match[0][0] === \"*\" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;\n            endReg.lastIndex = 0;\n            // Clip maskedSrc to same section of string as src (move to lexer?)\n            maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n            while((match = endReg.exec(maskedSrc)) != null){\n                rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n                if (!rDelim) continue; // skip single * in __abc*abc__\n                rLength = [\n                    ...rDelim\n                ].length;\n                if (match[3] || match[4]) {\n                    delimTotal += rLength;\n                    continue;\n                } else if (match[5] || match[6]) {\n                    if (lLength % 3 && !((lLength + rLength) % 3)) {\n                        midDelimTotal += rLength;\n                        continue; // CommonMark Emphasis Rules 9-10\n                    }\n                }\n                delimTotal -= rLength;\n                if (delimTotal > 0) continue; // Haven't found enough closing delimiters\n                // Remove extra characters. *a*** -> *a*\n                rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n                // char length can be >1 for unicode characters;\n                const lastCharLength = [\n                    ...match[0]\n                ][0].length;\n                const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);\n                // Create `em` if smallest delimiter has odd char count. *a***\n                if (Math.min(lLength, rLength) % 2) {\n                    const text = raw.slice(1, -1);\n                    return {\n                        type: \"em\",\n                        raw,\n                        text,\n                        tokens: this.lexer.inlineTokens(text)\n                    };\n                }\n                // Create 'strong' if smallest delimiter has even char count. **a***\n                const text = raw.slice(2, -2);\n                return {\n                    type: \"strong\",\n                    raw,\n                    text,\n                    tokens: this.lexer.inlineTokens(text)\n                };\n            }\n        }\n    }\n    codespan(src) {\n        const cap = this.rules.inline.code.exec(src);\n        if (cap) {\n            let text = cap[2].replace(this.rules.other.newLineCharGlobal, \" \");\n            const hasNonSpaceChars = this.rules.other.nonSpaceChar.test(text);\n            const hasSpaceCharsOnBothEnds = this.rules.other.startingSpaceChar.test(text) && this.rules.other.endingSpaceChar.test(text);\n            if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n                text = text.substring(1, text.length - 1);\n            }\n            return {\n                type: \"codespan\",\n                raw: cap[0],\n                text\n            };\n        }\n    }\n    br(src) {\n        const cap = this.rules.inline.br.exec(src);\n        if (cap) {\n            return {\n                type: \"br\",\n                raw: cap[0]\n            };\n        }\n    }\n    del(src) {\n        const cap = this.rules.inline.del.exec(src);\n        if (cap) {\n            return {\n                type: \"del\",\n                raw: cap[0],\n                text: cap[2],\n                tokens: this.lexer.inlineTokens(cap[2])\n            };\n        }\n    }\n    autolink(src) {\n        const cap = this.rules.inline.autolink.exec(src);\n        if (cap) {\n            let text, href;\n            if (cap[2] === \"@\") {\n                text = cap[1];\n                href = \"mailto:\" + text;\n            } else {\n                text = cap[1];\n                href = text;\n            }\n            return {\n                type: \"link\",\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: \"text\",\n                        raw: text,\n                        text\n                    }\n                ]\n            };\n        }\n    }\n    url(src) {\n        let cap;\n        if (cap = this.rules.inline.url.exec(src)) {\n            let text, href;\n            if (cap[2] === \"@\") {\n                text = cap[0];\n                href = \"mailto:\" + text;\n            } else {\n                // do extended autolink path validation\n                let prevCapZero;\n                do {\n                    prevCapZero = cap[0];\n                    cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? \"\";\n                }while (prevCapZero !== cap[0]);\n                text = cap[0];\n                if (cap[1] === \"www.\") {\n                    href = \"http://\" + cap[0];\n                } else {\n                    href = cap[0];\n                }\n            }\n            return {\n                type: \"link\",\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: \"text\",\n                        raw: text,\n                        text\n                    }\n                ]\n            };\n        }\n    }\n    inlineText(src) {\n        const cap = this.rules.inline.text.exec(src);\n        if (cap) {\n            const escaped = this.lexer.state.inRawBlock;\n            return {\n                type: \"text\",\n                raw: cap[0],\n                text: cap[0],\n                escaped\n            };\n        }\n    }\n}\n/**\n * Block Lexer\n */ class _Lexer {\n    constructor(options){\n        // TokenList cannot be created in one go\n        this.tokens = [];\n        this.tokens.links = Object.create(null);\n        this.options = options || _defaults;\n        this.options.tokenizer = this.options.tokenizer || new _Tokenizer();\n        this.tokenizer = this.options.tokenizer;\n        this.tokenizer.options = this.options;\n        this.tokenizer.lexer = this;\n        this.inlineQueue = [];\n        this.state = {\n            inLink: false,\n            inRawBlock: false,\n            top: true\n        };\n        const rules = {\n            other,\n            block: block.normal,\n            inline: inline.normal\n        };\n        if (this.options.pedantic) {\n            rules.block = block.pedantic;\n            rules.inline = inline.pedantic;\n        } else if (this.options.gfm) {\n            rules.block = block.gfm;\n            if (this.options.breaks) {\n                rules.inline = inline.breaks;\n            } else {\n                rules.inline = inline.gfm;\n            }\n        }\n        this.tokenizer.rules = rules;\n    }\n    /**\n     * Expose Rules\n     */ static get rules() {\n        return {\n            block,\n            inline\n        };\n    }\n    /**\n     * Static Lex Method\n     */ static lex(src, options) {\n        const lexer = new _Lexer(options);\n        return lexer.lex(src);\n    }\n    /**\n     * Static Lex Inline Method\n     */ static lexInline(src, options) {\n        const lexer = new _Lexer(options);\n        return lexer.inlineTokens(src);\n    }\n    /**\n     * Preprocessing\n     */ lex(src) {\n        src = src.replace(other.carriageReturn, \"\\n\");\n        this.blockTokens(src, this.tokens);\n        for(let i = 0; i < this.inlineQueue.length; i++){\n            const next = this.inlineQueue[i];\n            this.inlineTokens(next.src, next.tokens);\n        }\n        this.inlineQueue = [];\n        return this.tokens;\n    }\n    blockTokens(src, tokens = [], lastParagraphClipped = false) {\n        if (this.options.pedantic) {\n            src = src.replace(other.tabCharGlobal, \"    \").replace(other.spaceLine, \"\");\n        }\n        while(src){\n            let token;\n            if (this.options.extensions?.block?.some((extTokenizer)=>{\n                if (token = extTokenizer.call({\n                    lexer: this\n                }, src, tokens)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    return true;\n                }\n                return false;\n            })) {\n                continue;\n            }\n            // newline\n            if (token = this.tokenizer.space(src)) {\n                src = src.substring(token.raw.length);\n                const lastToken = tokens.at(-1);\n                if (token.raw.length === 1 && lastToken !== undefined) {\n                    // if there's a single \\n as a spacer, it's terminating the last line,\n                    // so move it there so that we don't get unnecessary paragraph tags\n                    lastToken.raw += \"\\n\";\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // code\n            if (token = this.tokenizer.code(src)) {\n                src = src.substring(token.raw.length);\n                const lastToken = tokens.at(-1);\n                // An indented code block cannot interrupt a paragraph.\n                if (lastToken?.type === \"paragraph\" || lastToken?.type === \"text\") {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.text;\n                    this.inlineQueue.at(-1).src = lastToken.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // fences\n            if (token = this.tokenizer.fences(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // heading\n            if (token = this.tokenizer.heading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // hr\n            if (token = this.tokenizer.hr(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // blockquote\n            if (token = this.tokenizer.blockquote(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // list\n            if (token = this.tokenizer.list(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // html\n            if (token = this.tokenizer.html(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // def\n            if (token = this.tokenizer.def(src)) {\n                src = src.substring(token.raw.length);\n                const lastToken = tokens.at(-1);\n                if (lastToken?.type === \"paragraph\" || lastToken?.type === \"text\") {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.raw;\n                    this.inlineQueue.at(-1).src = lastToken.text;\n                } else if (!this.tokens.links[token.tag]) {\n                    this.tokens.links[token.tag] = {\n                        href: token.href,\n                        title: token.title\n                    };\n                }\n                continue;\n            }\n            // table (gfm)\n            if (token = this.tokenizer.table(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // lheading\n            if (token = this.tokenizer.lheading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // top-level paragraph\n            // prevent paragraph consuming extensions by clipping 'src' to extension start\n            let cutSrc = src;\n            if (this.options.extensions?.startBlock) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startBlock.forEach((getStartIndex)=>{\n                    tempStart = getStartIndex.call({\n                        lexer: this\n                    }, tempSrc);\n                    if (typeof tempStart === \"number\" && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n                const lastToken = tokens.at(-1);\n                if (lastParagraphClipped && lastToken?.type === \"paragraph\") {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue.at(-1).src = lastToken.text;\n                } else {\n                    tokens.push(token);\n                }\n                lastParagraphClipped = cutSrc.length !== src.length;\n                src = src.substring(token.raw.length);\n                continue;\n            }\n            // text\n            if (token = this.tokenizer.text(src)) {\n                src = src.substring(token.raw.length);\n                const lastToken = tokens.at(-1);\n                if (lastToken?.type === \"text\") {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue.at(-1).src = lastToken.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                const errMsg = \"Infinite loop on byte: \" + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                } else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        this.state.top = true;\n        return tokens;\n    }\n    inline(src, tokens = []) {\n        this.inlineQueue.push({\n            src,\n            tokens\n        });\n        return tokens;\n    }\n    /**\n     * Lexing/Compiling\n     */ inlineTokens(src, tokens = []) {\n        // String with links masked to avoid interference with em and strong\n        let maskedSrc = src;\n        let match = null;\n        // Mask out reflinks\n        if (this.tokens.links) {\n            const links = Object.keys(this.tokens.links);\n            if (links.length > 0) {\n                while((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null){\n                    if (links.includes(match[0].slice(match[0].lastIndexOf(\"[\") + 1, -1))) {\n                        maskedSrc = maskedSrc.slice(0, match.index) + \"[\" + \"a\".repeat(match[0].length - 2) + \"]\" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n                    }\n                }\n            }\n        }\n        // Mask out other blocks\n        while((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null){\n            maskedSrc = maskedSrc.slice(0, match.index) + \"[\" + \"a\".repeat(match[0].length - 2) + \"]\" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n        }\n        // Mask out escaped characters\n        while((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null){\n            maskedSrc = maskedSrc.slice(0, match.index) + \"++\" + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);\n        }\n        let keepPrevChar = false;\n        let prevChar = \"\";\n        while(src){\n            if (!keepPrevChar) {\n                prevChar = \"\";\n            }\n            keepPrevChar = false;\n            let token;\n            // extensions\n            if (this.options.extensions?.inline?.some((extTokenizer)=>{\n                if (token = extTokenizer.call({\n                    lexer: this\n                }, src, tokens)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    return true;\n                }\n                return false;\n            })) {\n                continue;\n            }\n            // escape\n            if (token = this.tokenizer.escape(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // tag\n            if (token = this.tokenizer.tag(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // link\n            if (token = this.tokenizer.link(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // reflink, nolink\n            if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n                src = src.substring(token.raw.length);\n                const lastToken = tokens.at(-1);\n                if (token.type === \"text\" && lastToken?.type === \"text\") {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // em & strong\n            if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // code\n            if (token = this.tokenizer.codespan(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // br\n            if (token = this.tokenizer.br(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // del (gfm)\n            if (token = this.tokenizer.del(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // autolink\n            if (token = this.tokenizer.autolink(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // url (gfm)\n            if (!this.state.inLink && (token = this.tokenizer.url(src))) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // text\n            // prevent inlineText consuming extensions by clipping 'src' to extension start\n            let cutSrc = src;\n            if (this.options.extensions?.startInline) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startInline.forEach((getStartIndex)=>{\n                    tempStart = getStartIndex.call({\n                        lexer: this\n                    }, tempSrc);\n                    if (typeof tempStart === \"number\" && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (token = this.tokenizer.inlineText(cutSrc)) {\n                src = src.substring(token.raw.length);\n                if (token.raw.slice(-1) !== \"_\") {\n                    prevChar = token.raw.slice(-1);\n                }\n                keepPrevChar = true;\n                const lastToken = tokens.at(-1);\n                if (lastToken?.type === \"text\") {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                const errMsg = \"Infinite loop on byte: \" + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                } else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        return tokens;\n    }\n}\n/**\n * Renderer\n */ class _Renderer {\n    constructor(options){\n        this.options = options || _defaults;\n    }\n    space(token) {\n        return \"\";\n    }\n    code({ text, lang, escaped }) {\n        const langString = (lang || \"\").match(other.notSpaceStart)?.[0];\n        const code = text.replace(other.endingNewline, \"\") + \"\\n\";\n        if (!langString) {\n            return \"<pre><code>\" + (escaped ? code : escape(code, true)) + \"</code></pre>\\n\";\n        }\n        return '<pre><code class=\"language-' + escape(langString) + '\">' + (escaped ? code : escape(code, true)) + \"</code></pre>\\n\";\n    }\n    blockquote({ tokens }) {\n        const body = this.parser.parse(tokens);\n        return `<blockquote>\\n${body}</blockquote>\\n`;\n    }\n    html({ text }) {\n        return text;\n    }\n    heading({ tokens, depth }) {\n        return `<h${depth}>${this.parser.parseInline(tokens)}</h${depth}>\\n`;\n    }\n    hr(token) {\n        return \"<hr>\\n\";\n    }\n    list(token) {\n        const ordered = token.ordered;\n        const start = token.start;\n        let body = \"\";\n        for(let j = 0; j < token.items.length; j++){\n            const item = token.items[j];\n            body += this.listitem(item);\n        }\n        const type = ordered ? \"ol\" : \"ul\";\n        const startAttr = ordered && start !== 1 ? ' start=\"' + start + '\"' : \"\";\n        return \"<\" + type + startAttr + \">\\n\" + body + \"</\" + type + \">\\n\";\n    }\n    listitem(item) {\n        let itemBody = \"\";\n        if (item.task) {\n            const checkbox = this.checkbox({\n                checked: !!item.checked\n            });\n            if (item.loose) {\n                if (item.tokens[0]?.type === \"paragraph\") {\n                    item.tokens[0].text = checkbox + \" \" + item.tokens[0].text;\n                    if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === \"text\") {\n                        item.tokens[0].tokens[0].text = checkbox + \" \" + escape(item.tokens[0].tokens[0].text);\n                        item.tokens[0].tokens[0].escaped = true;\n                    }\n                } else {\n                    item.tokens.unshift({\n                        type: \"text\",\n                        raw: checkbox + \" \",\n                        text: checkbox + \" \",\n                        escaped: true\n                    });\n                }\n            } else {\n                itemBody += checkbox + \" \";\n            }\n        }\n        itemBody += this.parser.parse(item.tokens, !!item.loose);\n        return `<li>${itemBody}</li>\\n`;\n    }\n    checkbox({ checked }) {\n        return \"<input \" + (checked ? 'checked=\"\" ' : \"\") + 'disabled=\"\" type=\"checkbox\">';\n    }\n    paragraph({ tokens }) {\n        return `<p>${this.parser.parseInline(tokens)}</p>\\n`;\n    }\n    table(token) {\n        let header = \"\";\n        // header\n        let cell = \"\";\n        for(let j = 0; j < token.header.length; j++){\n            cell += this.tablecell(token.header[j]);\n        }\n        header += this.tablerow({\n            text: cell\n        });\n        let body = \"\";\n        for(let j = 0; j < token.rows.length; j++){\n            const row = token.rows[j];\n            cell = \"\";\n            for(let k = 0; k < row.length; k++){\n                cell += this.tablecell(row[k]);\n            }\n            body += this.tablerow({\n                text: cell\n            });\n        }\n        if (body) body = `<tbody>${body}</tbody>`;\n        return \"<table>\\n\" + \"<thead>\\n\" + header + \"</thead>\\n\" + body + \"</table>\\n\";\n    }\n    tablerow({ text }) {\n        return `<tr>\\n${text}</tr>\\n`;\n    }\n    tablecell(token) {\n        const content = this.parser.parseInline(token.tokens);\n        const type = token.header ? \"th\" : \"td\";\n        const tag = token.align ? `<${type} align=\"${token.align}\">` : `<${type}>`;\n        return tag + content + `</${type}>\\n`;\n    }\n    /**\n     * span level renderer\n     */ strong({ tokens }) {\n        return `<strong>${this.parser.parseInline(tokens)}</strong>`;\n    }\n    em({ tokens }) {\n        return `<em>${this.parser.parseInline(tokens)}</em>`;\n    }\n    codespan({ text }) {\n        return `<code>${escape(text, true)}</code>`;\n    }\n    br(token) {\n        return \"<br>\";\n    }\n    del({ tokens }) {\n        return `<del>${this.parser.parseInline(tokens)}</del>`;\n    }\n    link({ href, title, tokens }) {\n        const text = this.parser.parseInline(tokens);\n        const cleanHref = cleanUrl(href);\n        if (cleanHref === null) {\n            return text;\n        }\n        href = cleanHref;\n        let out = '<a href=\"' + href + '\"';\n        if (title) {\n            out += ' title=\"' + escape(title) + '\"';\n        }\n        out += \">\" + text + \"</a>\";\n        return out;\n    }\n    image({ href, title, text }) {\n        const cleanHref = cleanUrl(href);\n        if (cleanHref === null) {\n            return escape(text);\n        }\n        href = cleanHref;\n        let out = `<img src=\"${href}\" alt=\"${text}\"`;\n        if (title) {\n            out += ` title=\"${escape(title)}\"`;\n        }\n        out += \">\";\n        return out;\n    }\n    text(token) {\n        return \"tokens\" in token && token.tokens ? this.parser.parseInline(token.tokens) : \"escaped\" in token && token.escaped ? token.text : escape(token.text);\n    }\n}\n/**\n * TextRenderer\n * returns only the textual part of the token\n */ class _TextRenderer {\n    // no need for block level renderers\n    strong({ text }) {\n        return text;\n    }\n    em({ text }) {\n        return text;\n    }\n    codespan({ text }) {\n        return text;\n    }\n    del({ text }) {\n        return text;\n    }\n    html({ text }) {\n        return text;\n    }\n    text({ text }) {\n        return text;\n    }\n    link({ text }) {\n        return \"\" + text;\n    }\n    image({ text }) {\n        return \"\" + text;\n    }\n    br() {\n        return \"\";\n    }\n}\n/**\n * Parsing & Compiling\n */ class _Parser {\n    constructor(options){\n        this.options = options || _defaults;\n        this.options.renderer = this.options.renderer || new _Renderer();\n        this.renderer = this.options.renderer;\n        this.renderer.options = this.options;\n        this.renderer.parser = this;\n        this.textRenderer = new _TextRenderer();\n    }\n    /**\n     * Static Parse Method\n     */ static parse(tokens, options) {\n        const parser = new _Parser(options);\n        return parser.parse(tokens);\n    }\n    /**\n     * Static Parse Inline Method\n     */ static parseInline(tokens, options) {\n        const parser = new _Parser(options);\n        return parser.parseInline(tokens);\n    }\n    /**\n     * Parse Loop\n     */ parse(tokens, top = true) {\n        let out = \"\";\n        for(let i = 0; i < tokens.length; i++){\n            const anyToken = tokens[i];\n            // Run any renderer extensions\n            if (this.options.extensions?.renderers?.[anyToken.type]) {\n                const genericToken = anyToken;\n                const ret = this.options.extensions.renderers[genericToken.type].call({\n                    parser: this\n                }, genericToken);\n                if (ret !== false || ![\n                    \"space\",\n                    \"hr\",\n                    \"heading\",\n                    \"code\",\n                    \"table\",\n                    \"blockquote\",\n                    \"list\",\n                    \"html\",\n                    \"paragraph\",\n                    \"text\"\n                ].includes(genericToken.type)) {\n                    out += ret || \"\";\n                    continue;\n                }\n            }\n            const token = anyToken;\n            switch(token.type){\n                case \"space\":\n                    {\n                        out += this.renderer.space(token);\n                        continue;\n                    }\n                case \"hr\":\n                    {\n                        out += this.renderer.hr(token);\n                        continue;\n                    }\n                case \"heading\":\n                    {\n                        out += this.renderer.heading(token);\n                        continue;\n                    }\n                case \"code\":\n                    {\n                        out += this.renderer.code(token);\n                        continue;\n                    }\n                case \"table\":\n                    {\n                        out += this.renderer.table(token);\n                        continue;\n                    }\n                case \"blockquote\":\n                    {\n                        out += this.renderer.blockquote(token);\n                        continue;\n                    }\n                case \"list\":\n                    {\n                        out += this.renderer.list(token);\n                        continue;\n                    }\n                case \"html\":\n                    {\n                        out += this.renderer.html(token);\n                        continue;\n                    }\n                case \"paragraph\":\n                    {\n                        out += this.renderer.paragraph(token);\n                        continue;\n                    }\n                case \"text\":\n                    {\n                        let textToken = token;\n                        let body = this.renderer.text(textToken);\n                        while(i + 1 < tokens.length && tokens[i + 1].type === \"text\"){\n                            textToken = tokens[++i];\n                            body += \"\\n\" + this.renderer.text(textToken);\n                        }\n                        if (top) {\n                            out += this.renderer.paragraph({\n                                type: \"paragraph\",\n                                raw: body,\n                                text: body,\n                                tokens: [\n                                    {\n                                        type: \"text\",\n                                        raw: body,\n                                        text: body,\n                                        escaped: true\n                                    }\n                                ]\n                            });\n                        } else {\n                            out += body;\n                        }\n                        continue;\n                    }\n                default:\n                    {\n                        const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                        if (this.options.silent) {\n                            console.error(errMsg);\n                            return \"\";\n                        } else {\n                            throw new Error(errMsg);\n                        }\n                    }\n            }\n        }\n        return out;\n    }\n    /**\n     * Parse Inline Tokens\n     */ parseInline(tokens, renderer = this.renderer) {\n        let out = \"\";\n        for(let i = 0; i < tokens.length; i++){\n            const anyToken = tokens[i];\n            // Run any renderer extensions\n            if (this.options.extensions?.renderers?.[anyToken.type]) {\n                const ret = this.options.extensions.renderers[anyToken.type].call({\n                    parser: this\n                }, anyToken);\n                if (ret !== false || ![\n                    \"escape\",\n                    \"html\",\n                    \"link\",\n                    \"image\",\n                    \"strong\",\n                    \"em\",\n                    \"codespan\",\n                    \"br\",\n                    \"del\",\n                    \"text\"\n                ].includes(anyToken.type)) {\n                    out += ret || \"\";\n                    continue;\n                }\n            }\n            const token = anyToken;\n            switch(token.type){\n                case \"escape\":\n                    {\n                        out += renderer.text(token);\n                        break;\n                    }\n                case \"html\":\n                    {\n                        out += renderer.html(token);\n                        break;\n                    }\n                case \"link\":\n                    {\n                        out += renderer.link(token);\n                        break;\n                    }\n                case \"image\":\n                    {\n                        out += renderer.image(token);\n                        break;\n                    }\n                case \"strong\":\n                    {\n                        out += renderer.strong(token);\n                        break;\n                    }\n                case \"em\":\n                    {\n                        out += renderer.em(token);\n                        break;\n                    }\n                case \"codespan\":\n                    {\n                        out += renderer.codespan(token);\n                        break;\n                    }\n                case \"br\":\n                    {\n                        out += renderer.br(token);\n                        break;\n                    }\n                case \"del\":\n                    {\n                        out += renderer.del(token);\n                        break;\n                    }\n                case \"text\":\n                    {\n                        out += renderer.text(token);\n                        break;\n                    }\n                default:\n                    {\n                        const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                        if (this.options.silent) {\n                            console.error(errMsg);\n                            return \"\";\n                        } else {\n                            throw new Error(errMsg);\n                        }\n                    }\n            }\n        }\n        return out;\n    }\n}\nclass _Hooks {\n    constructor(options){\n        this.options = options || _defaults;\n    }\n    static{\n        this.passThroughHooks = new Set([\n            \"preprocess\",\n            \"postprocess\",\n            \"processAllTokens\"\n        ]);\n    }\n    /**\n     * Process markdown before marked\n     */ preprocess(markdown) {\n        return markdown;\n    }\n    /**\n     * Process HTML after marked is finished\n     */ postprocess(html) {\n        return html;\n    }\n    /**\n     * Process all tokens before walk tokens\n     */ processAllTokens(tokens) {\n        return tokens;\n    }\n    /**\n     * Provide function to tokenize markdown\n     */ provideLexer() {\n        return this.block ? _Lexer.lex : _Lexer.lexInline;\n    }\n    /**\n     * Provide function to parse tokens\n     */ provideParser() {\n        return this.block ? _Parser.parse : _Parser.parseInline;\n    }\n}\nclass Marked {\n    constructor(...args){\n        this.defaults = _getDefaults();\n        this.options = this.setOptions;\n        this.parse = this.parseMarkdown(true);\n        this.parseInline = this.parseMarkdown(false);\n        this.Parser = _Parser;\n        this.Renderer = _Renderer;\n        this.TextRenderer = _TextRenderer;\n        this.Lexer = _Lexer;\n        this.Tokenizer = _Tokenizer;\n        this.Hooks = _Hooks;\n        this.use(...args);\n    }\n    /**\n     * Run callback for every token\n     */ walkTokens(tokens, callback) {\n        let values = [];\n        for (const token of tokens){\n            values = values.concat(callback.call(this, token));\n            switch(token.type){\n                case \"table\":\n                    {\n                        const tableToken = token;\n                        for (const cell of tableToken.header){\n                            values = values.concat(this.walkTokens(cell.tokens, callback));\n                        }\n                        for (const row of tableToken.rows){\n                            for (const cell of row){\n                                values = values.concat(this.walkTokens(cell.tokens, callback));\n                            }\n                        }\n                        break;\n                    }\n                case \"list\":\n                    {\n                        const listToken = token;\n                        values = values.concat(this.walkTokens(listToken.items, callback));\n                        break;\n                    }\n                default:\n                    {\n                        const genericToken = token;\n                        if (this.defaults.extensions?.childTokens?.[genericToken.type]) {\n                            this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens)=>{\n                                const tokens = genericToken[childTokens].flat(Infinity);\n                                values = values.concat(this.walkTokens(tokens, callback));\n                            });\n                        } else if (genericToken.tokens) {\n                            values = values.concat(this.walkTokens(genericToken.tokens, callback));\n                        }\n                    }\n            }\n        }\n        return values;\n    }\n    use(...args) {\n        const extensions = this.defaults.extensions || {\n            renderers: {},\n            childTokens: {}\n        };\n        args.forEach((pack)=>{\n            // copy options to new object\n            const opts = {\n                ...pack\n            };\n            // set async to true if it was set to true before\n            opts.async = this.defaults.async || opts.async || false;\n            // ==-- Parse \"addon\" extensions --== //\n            if (pack.extensions) {\n                pack.extensions.forEach((ext)=>{\n                    if (!ext.name) {\n                        throw new Error(\"extension name required\");\n                    }\n                    if (\"renderer\" in ext) {\n                        const prevRenderer = extensions.renderers[ext.name];\n                        if (prevRenderer) {\n                            // Replace extension with func to run new extension but fall back if false\n                            extensions.renderers[ext.name] = function(...args) {\n                                let ret = ext.renderer.apply(this, args);\n                                if (ret === false) {\n                                    ret = prevRenderer.apply(this, args);\n                                }\n                                return ret;\n                            };\n                        } else {\n                            extensions.renderers[ext.name] = ext.renderer;\n                        }\n                    }\n                    if (\"tokenizer\" in ext) {\n                        if (!ext.level || ext.level !== \"block\" && ext.level !== \"inline\") {\n                            throw new Error(\"extension level must be 'block' or 'inline'\");\n                        }\n                        const extLevel = extensions[ext.level];\n                        if (extLevel) {\n                            extLevel.unshift(ext.tokenizer);\n                        } else {\n                            extensions[ext.level] = [\n                                ext.tokenizer\n                            ];\n                        }\n                        if (ext.start) {\n                            if (ext.level === \"block\") {\n                                if (extensions.startBlock) {\n                                    extensions.startBlock.push(ext.start);\n                                } else {\n                                    extensions.startBlock = [\n                                        ext.start\n                                    ];\n                                }\n                            } else if (ext.level === \"inline\") {\n                                if (extensions.startInline) {\n                                    extensions.startInline.push(ext.start);\n                                } else {\n                                    extensions.startInline = [\n                                        ext.start\n                                    ];\n                                }\n                            }\n                        }\n                    }\n                    if (\"childTokens\" in ext && ext.childTokens) {\n                        extensions.childTokens[ext.name] = ext.childTokens;\n                    }\n                });\n                opts.extensions = extensions;\n            }\n            // ==-- Parse \"overwrite\" extensions --== //\n            if (pack.renderer) {\n                const renderer = this.defaults.renderer || new _Renderer(this.defaults);\n                for(const prop in pack.renderer){\n                    if (!(prop in renderer)) {\n                        throw new Error(`renderer '${prop}' does not exist`);\n                    }\n                    if ([\n                        \"options\",\n                        \"parser\"\n                    ].includes(prop)) {\n                        continue;\n                    }\n                    const rendererProp = prop;\n                    const rendererFunc = pack.renderer[rendererProp];\n                    const prevRenderer = renderer[rendererProp];\n                    // Replace renderer with func to run extension, but fall back if false\n                    renderer[rendererProp] = (...args)=>{\n                        let ret = rendererFunc.apply(renderer, args);\n                        if (ret === false) {\n                            ret = prevRenderer.apply(renderer, args);\n                        }\n                        return ret || \"\";\n                    };\n                }\n                opts.renderer = renderer;\n            }\n            if (pack.tokenizer) {\n                const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);\n                for(const prop in pack.tokenizer){\n                    if (!(prop in tokenizer)) {\n                        throw new Error(`tokenizer '${prop}' does not exist`);\n                    }\n                    if ([\n                        \"options\",\n                        \"rules\",\n                        \"lexer\"\n                    ].includes(prop)) {\n                        continue;\n                    }\n                    const tokenizerProp = prop;\n                    const tokenizerFunc = pack.tokenizer[tokenizerProp];\n                    const prevTokenizer = tokenizer[tokenizerProp];\n                    // Replace tokenizer with func to run extension, but fall back if false\n                    // @ts-expect-error cannot type tokenizer function dynamically\n                    tokenizer[tokenizerProp] = (...args)=>{\n                        let ret = tokenizerFunc.apply(tokenizer, args);\n                        if (ret === false) {\n                            ret = prevTokenizer.apply(tokenizer, args);\n                        }\n                        return ret;\n                    };\n                }\n                opts.tokenizer = tokenizer;\n            }\n            // ==-- Parse Hooks extensions --== //\n            if (pack.hooks) {\n                const hooks = this.defaults.hooks || new _Hooks();\n                for(const prop in pack.hooks){\n                    if (!(prop in hooks)) {\n                        throw new Error(`hook '${prop}' does not exist`);\n                    }\n                    if ([\n                        \"options\",\n                        \"block\"\n                    ].includes(prop)) {\n                        continue;\n                    }\n                    const hooksProp = prop;\n                    const hooksFunc = pack.hooks[hooksProp];\n                    const prevHook = hooks[hooksProp];\n                    if (_Hooks.passThroughHooks.has(prop)) {\n                        // @ts-expect-error cannot type hook function dynamically\n                        hooks[hooksProp] = (arg)=>{\n                            if (this.defaults.async) {\n                                return Promise.resolve(hooksFunc.call(hooks, arg)).then((ret)=>{\n                                    return prevHook.call(hooks, ret);\n                                });\n                            }\n                            const ret = hooksFunc.call(hooks, arg);\n                            return prevHook.call(hooks, ret);\n                        };\n                    } else {\n                        // @ts-expect-error cannot type hook function dynamically\n                        hooks[hooksProp] = (...args)=>{\n                            let ret = hooksFunc.apply(hooks, args);\n                            if (ret === false) {\n                                ret = prevHook.apply(hooks, args);\n                            }\n                            return ret;\n                        };\n                    }\n                }\n                opts.hooks = hooks;\n            }\n            // ==-- Parse WalkTokens extensions --== //\n            if (pack.walkTokens) {\n                const walkTokens = this.defaults.walkTokens;\n                const packWalktokens = pack.walkTokens;\n                opts.walkTokens = function(token) {\n                    let values = [];\n                    values.push(packWalktokens.call(this, token));\n                    if (walkTokens) {\n                        values = values.concat(walkTokens.call(this, token));\n                    }\n                    return values;\n                };\n            }\n            this.defaults = {\n                ...this.defaults,\n                ...opts\n            };\n        });\n        return this;\n    }\n    setOptions(opt) {\n        this.defaults = {\n            ...this.defaults,\n            ...opt\n        };\n        return this;\n    }\n    lexer(src, options) {\n        return _Lexer.lex(src, options ?? this.defaults);\n    }\n    parser(tokens, options) {\n        return _Parser.parse(tokens, options ?? this.defaults);\n    }\n    parseMarkdown(blockType) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const parse = (src, options)=>{\n            const origOpt = {\n                ...options\n            };\n            const opt = {\n                ...this.defaults,\n                ...origOpt\n            };\n            const throwError = this.onError(!!opt.silent, !!opt.async);\n            // throw error if an extension set async to true but parse was called with async: false\n            if (this.defaults.async === true && origOpt.async === false) {\n                return throwError(new Error(\"marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.\"));\n            }\n            // throw error in case of non string input\n            if (typeof src === \"undefined\" || src === null) {\n                return throwError(new Error(\"marked(): input parameter is undefined or null\"));\n            }\n            if (typeof src !== \"string\") {\n                return throwError(new Error(\"marked(): input parameter is of type \" + Object.prototype.toString.call(src) + \", string expected\"));\n            }\n            if (opt.hooks) {\n                opt.hooks.options = opt;\n                opt.hooks.block = blockType;\n            }\n            const lexer = opt.hooks ? opt.hooks.provideLexer() : blockType ? _Lexer.lex : _Lexer.lexInline;\n            const parser = opt.hooks ? opt.hooks.provideParser() : blockType ? _Parser.parse : _Parser.parseInline;\n            if (opt.async) {\n                return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src)=>lexer(src, opt)).then((tokens)=>opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens).then((tokens)=>opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(()=>tokens) : tokens).then((tokens)=>parser(tokens, opt)).then((html)=>opt.hooks ? opt.hooks.postprocess(html) : html).catch(throwError);\n            }\n            try {\n                if (opt.hooks) {\n                    src = opt.hooks.preprocess(src);\n                }\n                let tokens = lexer(src, opt);\n                if (opt.hooks) {\n                    tokens = opt.hooks.processAllTokens(tokens);\n                }\n                if (opt.walkTokens) {\n                    this.walkTokens(tokens, opt.walkTokens);\n                }\n                let html = parser(tokens, opt);\n                if (opt.hooks) {\n                    html = opt.hooks.postprocess(html);\n                }\n                return html;\n            } catch (e) {\n                return throwError(e);\n            }\n        };\n        return parse;\n    }\n    onError(silent, async) {\n        return (e)=>{\n            e.message += \"\\nPlease report this to https://github.com/markedjs/marked.\";\n            if (silent) {\n                const msg = \"<p>An error occurred:</p><pre>\" + escape(e.message + \"\", true) + \"</pre>\";\n                if (async) {\n                    return Promise.resolve(msg);\n                }\n                return msg;\n            }\n            if (async) {\n                return Promise.reject(e);\n            }\n            throw e;\n        };\n    }\n}\nconst markedInstance = new Marked();\nfunction marked(src, opt) {\n    return markedInstance.parse(src, opt);\n}\n/**\n * Sets the default options.\n *\n * @param options Hash of options\n */ marked.options = marked.setOptions = function(options) {\n    markedInstance.setOptions(options);\n    marked.defaults = markedInstance.defaults;\n    changeDefaults(marked.defaults);\n    return marked;\n};\n/**\n * Gets the original marked default options.\n */ marked.getDefaults = _getDefaults;\nmarked.defaults = _defaults;\n/**\n * Use Extension\n */ marked.use = function(...args) {\n    markedInstance.use(...args);\n    marked.defaults = markedInstance.defaults;\n    changeDefaults(marked.defaults);\n    return marked;\n};\n/**\n * Run callback for every token\n */ marked.walkTokens = function(tokens, callback) {\n    return markedInstance.walkTokens(tokens, callback);\n};\n/**\n * Compiles markdown to HTML without enclosing `p` tag.\n *\n * @param src String of markdown source to be compiled\n * @param options Hash of options\n * @return String of compiled HTML\n */ marked.parseInline = markedInstance.parseInline;\n/**\n * Expose\n */ marked.Parser = _Parser;\nmarked.parser = _Parser.parse;\nmarked.Renderer = _Renderer;\nmarked.TextRenderer = _TextRenderer;\nmarked.Lexer = _Lexer;\nmarked.lexer = _Lexer.lex;\nmarked.Tokenizer = _Tokenizer;\nmarked.Hooks = _Hooks;\nmarked.parse = marked;\nconst options = marked.options;\nconst setOptions = marked.setOptions;\nconst use = marked.use;\nconst walkTokens = marked.walkTokens;\nconst parseInline = marked.parseInline;\nconst parse = marked;\nconst parser = _Parser.parse;\nconst lexer = _Lexer.lex;\n //# sourceMappingURL=marked.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFya2VkL2xpYi9tYXJrZWQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7O0NBSUMsR0FFRDs7O0NBR0MsR0FFRDs7Q0FFQyxHQUNELFNBQVNBO0lBQ0wsT0FBTztRQUNIQyxPQUFPO1FBQ1BDLFFBQVE7UUFDUkMsWUFBWTtRQUNaQyxLQUFLO1FBQ0xDLE9BQU87UUFDUEMsVUFBVTtRQUNWQyxVQUFVO1FBQ1ZDLFFBQVE7UUFDUkMsV0FBVztRQUNYQyxZQUFZO0lBQ2hCO0FBQ0o7QUFDQSxJQUFJQyxZQUFZWDtBQUNoQixTQUFTWSxlQUFlQyxXQUFXO0lBQy9CRixZQUFZRTtBQUNoQjtBQUVBLE1BQU1DLFdBQVc7SUFBRUMsTUFBTSxJQUFNO0FBQUs7QUFDcEMsU0FBU0MsS0FBS0MsS0FBSyxFQUFFQyxNQUFNLEVBQUU7SUFDekIsSUFBSUMsU0FBUyxPQUFPRixVQUFVLFdBQVdBLFFBQVFBLE1BQU1FLE1BQU07SUFDN0QsTUFBTUMsTUFBTTtRQUNSQyxTQUFTLENBQUNDLE1BQU1DO1lBQ1osSUFBSUMsWUFBWSxPQUFPRCxRQUFRLFdBQVdBLE1BQU1BLElBQUlKLE1BQU07WUFDMURLLFlBQVlBLFVBQVVILE9BQU8sQ0FBQ0ksTUFBTUMsS0FBSyxFQUFFO1lBQzNDUCxTQUFTQSxPQUFPRSxPQUFPLENBQUNDLE1BQU1FO1lBQzlCLE9BQU9KO1FBQ1g7UUFDQU8sVUFBVTtZQUNOLE9BQU8sSUFBSUMsT0FBT1QsUUFBUUQ7UUFDOUI7SUFDSjtJQUNBLE9BQU9FO0FBQ1g7QUFDQSxNQUFNSyxRQUFRO0lBQ1ZJLGtCQUFrQjtJQUNsQkMsbUJBQW1CO0lBQ25CQyx3QkFBd0I7SUFDeEJDLGdCQUFnQjtJQUNoQkMsWUFBWTtJQUNaQyxtQkFBbUI7SUFDbkJDLGlCQUFpQjtJQUNqQkMsY0FBYztJQUNkQyxtQkFBbUI7SUFDbkJDLGVBQWU7SUFDZkMscUJBQXFCO0lBQ3JCQyxXQUFXO0lBQ1hDLGlC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LE9BQU8zQyxLQUFLLEdBQUduQjtBQUNmOEQsT0FBT3ZGLEtBQUssR0FBR3VGO0FBQ2YsTUFBTXZNLFVBQVV1TSxPQUFPdk0sT0FBTztBQUM5QixNQUFNcUosYUFBYWtELE9BQU9sRCxVQUFVO0FBQ3BDLE1BQU1RLE1BQU0wQyxPQUFPMUMsR0FBRztBQUN0QixNQUFNL1YsYUFBYXlZLE9BQU96WSxVQUFVO0FBQ3BDLE1BQU1tVCxjQUFjc0YsT0FBT3RGLFdBQVc7QUFDdEMsTUFBTUQsUUFBUXVGO0FBQ2QsTUFBTXhGLFNBQVNtQixRQUFRbEIsS0FBSztBQUM1QixNQUFNbEksUUFBUWlHLE9BQU9JLEdBQUc7QUFFbVEsQ0FDM1Isc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vRkxBQUtLTy8uL25vZGVfbW9kdWxlcy9tYXJrZWQvbGliL21hcmtlZC5lc20uanM/YzczOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIG1hcmtlZCB2MTUuMC40IC0gYSBtYXJrZG93biBwYXJzZXJcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDI0LCBDaHJpc3RvcGhlciBKZWZmcmV5LiAoTUlUIExpY2Vuc2VkKVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hcmtlZGpzL21hcmtlZFxuICovXG5cbi8qKlxuICogRE8gTk9UIEVESVQgVEhJUyBGSUxFXG4gKiBUaGUgY29kZSBpbiB0aGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGZyb20gZmlsZXMgaW4gLi9zcmMvXG4gKi9cblxuLyoqXG4gKiBHZXRzIHRoZSBvcmlnaW5hbCBtYXJrZWQgZGVmYXVsdCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBfZ2V0RGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYXN5bmM6IGZhbHNlLFxuICAgICAgICBicmVha3M6IGZhbHNlLFxuICAgICAgICBleHRlbnNpb25zOiBudWxsLFxuICAgICAgICBnZm06IHRydWUsXG4gICAgICAgIGhvb2tzOiBudWxsLFxuICAgICAgICBwZWRhbnRpYzogZmFsc2UsXG4gICAgICAgIHJlbmRlcmVyOiBudWxsLFxuICAgICAgICBzaWxlbnQ6IGZhbHNlLFxuICAgICAgICB0b2tlbml6ZXI6IG51bGwsXG4gICAgICAgIHdhbGtUb2tlbnM6IG51bGwsXG4gICAgfTtcbn1cbmxldCBfZGVmYXVsdHMgPSBfZ2V0RGVmYXVsdHMoKTtcbmZ1bmN0aW9uIGNoYW5nZURlZmF1bHRzKG5ld0RlZmF1bHRzKSB7XG4gICAgX2RlZmF1bHRzID0gbmV3RGVmYXVsdHM7XG59XG5cbmNvbnN0IG5vb3BUZXN0ID0geyBleGVjOiAoKSA9PiBudWxsIH07XG5mdW5jdGlvbiBlZGl0KHJlZ2V4LCBvcHQgPSAnJykge1xuICAgIGxldCBzb3VyY2UgPSB0eXBlb2YgcmVnZXggPT09ICdzdHJpbmcnID8gcmVnZXggOiByZWdleC5zb3VyY2U7XG4gICAgY29uc3Qgb2JqID0ge1xuICAgICAgICByZXBsYWNlOiAobmFtZSwgdmFsKSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsU291cmNlID0gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyB2YWwgOiB2YWwuc291cmNlO1xuICAgICAgICAgICAgdmFsU291cmNlID0gdmFsU291cmNlLnJlcGxhY2Uob3RoZXIuY2FyZXQsICckMScpO1xuICAgICAgICAgICAgc291cmNlID0gc291cmNlLnJlcGxhY2UobmFtZSwgdmFsU291cmNlKTtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFJlZ2V4OiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChzb3VyY2UsIG9wdCk7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICByZXR1cm4gb2JqO1xufVxuY29uc3Qgb3RoZXIgPSB7XG4gICAgY29kZVJlbW92ZUluZGVudDogL14oPzogezEsNH18IHswLDN9XFx0KS9nbSxcbiAgICBvdXRwdXRMaW5rUmVwbGFjZTogL1xcXFwoW1xcW1xcXV0pL2csXG4gICAgaW5kZW50Q29kZUNvbXBlbnNhdGlvbjogL14oXFxzKykoPzpgYGApLyxcbiAgICBiZWdpbm5pbmdTcGFjZTogL15cXHMrLyxcbiAgICBlbmRpbmdIYXNoOiAvIyQvLFxuICAgIHN0YXJ0aW5nU3BhY2VDaGFyOiAvXiAvLFxuICAgIGVuZGluZ1NwYWNlQ2hhcjogLyAkLyxcbiAgICBub25TcGFjZUNoYXI6IC9bXiBdLyxcbiAgICBuZXdMaW5lQ2hhckdsb2JhbDogL1xcbi9nLFxuICAgIHRhYkNoYXJHbG9iYWw6IC9cXHQvZyxcbiAgICBtdWx0aXBsZVNwYWNlR2xvYmFsOiAvXFxzKy9nLFxuICAgIGJsYW5rTGluZTogL15bIFxcdF0qJC8sXG4gICAgZG91YmxlQmxhbmtMaW5lOiAvXFxuWyBcXHRdKlxcblsgXFx0XSokLyxcbiAgICBibG9ja3F1b3RlU3RhcnQ6IC9eIHswLDN9Pi8sXG4gICAgYmxvY2txdW90ZVNldGV4dFJlcGxhY2U6IC9cXG4gezAsM30oKD86PSt8LSspICopKD89XFxufCQpL2csXG4gICAgYmxvY2txdW90ZVNldGV4dFJlcGxhY2UyOiAvXiB7MCwzfT5bIFxcdF0/L2dtLFxuICAgIGxpc3RSZXBsYWNlVGFiczogL15cXHQrLyxcbiAgICBsaXN0UmVwbGFjZU5lc3Rpbmc6IC9eIHsxLDR9KD89KCB7NH0pKlteIF0pL2csXG4gICAgbGlzdElzVGFzazogL15cXFtbIHhYXVxcXSAvLFxuICAgIGxpc3RSZXBsYWNlVGFzazogL15cXFtbIHhYXVxcXSArLyxcbiAgICBhbnlMaW5lOiAvXFxuLipcXG4vLFxuICAgIGhyZWZCcmFja2V0czogL148KC4qKT4kLyxcbiAgICB0YWJsZURlbGltaXRlcjogL1s6fF0vLFxuICAgIHRhYmxlQWxpZ25DaGFyczogL15cXHx8XFx8ICokL2csXG4gICAgdGFibGVSb3dCbGFua0xpbmU6IC9cXG5bIFxcdF0qJC8sXG4gICAgdGFibGVBbGlnblJpZ2h0OiAvXiAqLSs6ICokLyxcbiAgICB0YWJsZUFsaWduQ2VudGVyOiAvXiAqOi0rOiAqJC8sXG4gICAgdGFibGVBbGlnbkxlZnQ6IC9eICo6LSsgKiQvLFxuICAgIHN0YXJ0QVRhZzogL148YSAvaSxcbiAgICBlbmRBVGFnOiAvXjxcXC9hPi9pLFxuICAgIHN0YXJ0UHJlU2NyaXB0VGFnOiAvXjwocHJlfGNvZGV8a2JkfHNjcmlwdCkoXFxzfD4pL2ksXG4gICAgZW5kUHJlU2NyaXB0VGFnOiAvXjxcXC8ocHJlfGNvZGV8a2JkfHNjcmlwdCkoXFxzfD4pL2ksXG4gICAgc3RhcnRBbmdsZUJyYWNrZXQ6IC9ePC8sXG4gICAgZW5kQW5nbGVCcmFja2V0OiAvPiQvLFxuICAgIHBlZGFudGljSHJlZlRpdGxlOiAvXihbXidcIl0qW15cXHNdKVxccysoWydcIl0pKC4qKVxcMi8sXG4gICAgdW5pY29kZUFscGhhTnVtZXJpYzogL1tcXHB7TH1cXHB7Tn1dL3UsXG4gICAgZXNjYXBlVGVzdDogL1smPD5cIiddLyxcbiAgICBlc2NhcGVSZXBsYWNlOiAvWyY8PlwiJ10vZyxcbiAgICBlc2NhcGVUZXN0Tm9FbmNvZGU6IC9bPD5cIiddfCYoPyEoI1xcZHsxLDd9fCNbWHhdW2EtZkEtRjAtOV17MSw2fXxcXHcrKTspLyxcbiAgICBlc2NhcGVSZXBsYWNlTm9FbmNvZGU6IC9bPD5cIiddfCYoPyEoI1xcZHsxLDd9fCNbWHhdW2EtZkEtRjAtOV17MSw2fXxcXHcrKTspL2csXG4gICAgdW5lc2NhcGVUZXN0OiAvJigjKD86XFxkKyl8KD86I3hbMC05QS1GYS1mXSspfCg/OlxcdyspKTs/L2lnLFxuICAgIGNhcmV0OiAvKF58W15cXFtdKVxcXi9nLFxuICAgIHBlcmNlbnREZWNvZGU6IC8lMjUvZyxcbiAgICBmaW5kUGlwZTogL1xcfC9nLFxuICAgIHNwbGl0UGlwZTogLyBcXHwvLFxuICAgIHNsYXNoUGlwZTogL1xcXFxcXHwvZyxcbiAgICBjYXJyaWFnZVJldHVybjogL1xcclxcbnxcXHIvZyxcbiAgICBzcGFjZUxpbmU6IC9eICskL2dtLFxuICAgIG5vdFNwYWNlU3RhcnQ6IC9eXFxTKi8sXG4gICAgZW5kaW5nTmV3bGluZTogL1xcbiQvLFxuICAgIGxpc3RJdGVtUmVnZXg6IChidWxsKSA9PiBuZXcgUmVnRXhwKGBeKCB7MCwzfSR7YnVsbH0pKCg/OltcXHQgXVteXFxcXG5dKik/KD86XFxcXG58JCkpYCksXG4gICAgbmV4dEJ1bGxldFJlZ2V4OiAoaW5kZW50KSA9PiBuZXcgUmVnRXhwKGBeIHswLCR7TWF0aC5taW4oMywgaW5kZW50IC0gMSl9fSg/OlsqKy1dfFxcXFxkezEsOX1bLildKSgoPzpbIFxcdF1bXlxcXFxuXSopPyg/OlxcXFxufCQpKWApLFxuICAgIGhyUmVnZXg6IChpbmRlbnQpID0+IG5ldyBSZWdFeHAoYF4gezAsJHtNYXRoLm1pbigzLCBpbmRlbnQgLSAxKX19KCg/Oi0gKil7Myx9fCg/Ol8gKil7Myx9fCg/OlxcXFwqICopezMsfSkoPzpcXFxcbit8JClgKSxcbiAgICBmZW5jZXNCZWdpblJlZ2V4OiAoaW5kZW50KSA9PiBuZXcgUmVnRXhwKGBeIHswLCR7TWF0aC5taW4oMywgaW5kZW50IC0gMSl9fSg/OlxcYFxcYFxcYHx+fn4pYCksXG4gICAgaGVhZGluZ0JlZ2luUmVnZXg6IChpbmRlbnQpID0+IG5ldyBSZWdFeHAoYF4gezAsJHtNYXRoLm1pbigzLCBpbmRlbnQgLSAxKX19I2ApLFxuICAgIGh0bWxCZWdpblJlZ2V4OiAoaW5kZW50KSA9PiBuZXcgUmVnRXhwKGBeIHswLCR7TWF0aC5taW4oMywgaW5kZW50IC0gMSl9fTwoPzpbYS16XS4qPnwhLS0pYCwgJ2knKSxcbn07XG4vKipcbiAqIEJsb2NrLUxldmVsIEdyYW1tYXJcbiAqL1xuY29uc3QgbmV3bGluZSA9IC9eKD86WyBcXHRdKig/OlxcbnwkKSkrLztcbmNvbnN0IGJsb2NrQ29kZSA9IC9eKCg/OiB7NH18IHswLDN9XFx0KVteXFxuXSsoPzpcXG4oPzpbIFxcdF0qKD86XFxufCQpKSopPykrLztcbmNvbnN0IGZlbmNlcyA9IC9eIHswLDN9KGB7Myx9KD89W15gXFxuXSooPzpcXG58JCkpfH57Myx9KShbXlxcbl0qKSg/OlxcbnwkKSg/OnwoW1xcc1xcU10qPykoPzpcXG58JCkpKD86IHswLDN9XFwxW35gXSogKig/PVxcbnwkKXwkKS87XG5jb25zdCBociA9IC9eIHswLDN9KCg/Oi1bXFx0IF0qKXszLH18KD86X1sgXFx0XSopezMsfXwoPzpcXCpbIFxcdF0qKXszLH0pKD86XFxuK3wkKS87XG5jb25zdCBoZWFkaW5nID0gL14gezAsM30oI3sxLDZ9KSg/PVxcc3wkKSguKikoPzpcXG4rfCQpLztcbmNvbnN0IGJ1bGxldCA9IC8oPzpbKistXXxcXGR7MSw5fVsuKV0pLztcbmNvbnN0IGxoZWFkaW5nID0gZWRpdCgvXig/IWJ1bGwgfGJsb2NrQ29kZXxmZW5jZXN8YmxvY2txdW90ZXxoZWFkaW5nfGh0bWwpKCg/Oi58XFxuKD8hXFxzKj9cXG58YnVsbCB8YmxvY2tDb2RlfGZlbmNlc3xibG9ja3F1b3RlfGhlYWRpbmd8aHRtbCkpKz8pXFxuIHswLDN9KD0rfC0rKSAqKD86XFxuK3wkKS8pXG4gICAgLnJlcGxhY2UoL2J1bGwvZywgYnVsbGV0KSAvLyBsaXN0cyBjYW4gaW50ZXJydXB0XG4gICAgLnJlcGxhY2UoL2Jsb2NrQ29kZS9nLCAvKD86IHs0fXwgezAsM31cXHQpLykgLy8gaW5kZW50ZWQgY29kZSBibG9ja3MgY2FuIGludGVycnVwdFxuICAgIC5yZXBsYWNlKC9mZW5jZXMvZywgLyB7MCwzfSg/OmB7Myx9fH57Myx9KS8pIC8vIGZlbmNlZCBjb2RlIGJsb2NrcyBjYW4gaW50ZXJydXB0XG4gICAgLnJlcGxhY2UoL2Jsb2NrcXVvdGUvZywgLyB7MCwzfT4vKSAvLyBibG9ja3F1b3RlIGNhbiBpbnRlcnJ1cHRcbiAgICAucmVwbGFjZSgvaGVhZGluZy9nLCAvIHswLDN9I3sxLDZ9LykgLy8gQVRYIGhlYWRpbmcgY2FuIGludGVycnVwdFxuICAgIC5yZXBsYWNlKC9odG1sL2csIC8gezAsM308W15cXG4+XSs+XFxuLykgLy8gYmxvY2sgaHRtbCBjYW4gaW50ZXJydXB0XG4gICAgLmdldFJlZ2V4KCk7XG5jb25zdCBfcGFyYWdyYXBoID0gL14oW15cXG5dKyg/Olxcbig/IWhyfGhlYWRpbmd8bGhlYWRpbmd8YmxvY2txdW90ZXxmZW5jZXN8bGlzdHxodG1sfHRhYmxlfCArXFxuKVteXFxuXSspKikvO1xuY29uc3QgYmxvY2tUZXh0ID0gL15bXlxcbl0rLztcbmNvbnN0IF9ibG9ja0xhYmVsID0gLyg/IVxccypcXF0pKD86XFxcXC58W15cXFtcXF1cXFxcXSkrLztcbmNvbnN0IGRlZiA9IGVkaXQoL14gezAsM31cXFsobGFiZWwpXFxdOiAqKD86XFxuWyBcXHRdKik/KFtePFxcc11bXlxcc10qfDwuKj8+KSg/Oig/OiArKD86XFxuWyBcXHRdKik/fCAqXFxuWyBcXHRdKikodGl0bGUpKT8gKig/Olxcbit8JCkvKVxuICAgIC5yZXBsYWNlKCdsYWJlbCcsIF9ibG9ja0xhYmVsKVxuICAgIC5yZXBsYWNlKCd0aXRsZScsIC8oPzpcIig/OlxcXFxcIj98W15cIlxcXFxdKSpcInwnW14nXFxuXSooPzpcXG5bXidcXG5dKykqXFxuPyd8XFwoW14oKV0qXFwpKS8pXG4gICAgLmdldFJlZ2V4KCk7XG5jb25zdCBsaXN0ID0gZWRpdCgvXiggezAsM31idWxsKShbIFxcdF1bXlxcbl0rPyk/KD86XFxufCQpLylcbiAgICAucmVwbGFjZSgvYnVsbC9nLCBidWxsZXQpXG4gICAgLmdldFJlZ2V4KCk7XG5jb25zdCBfdGFnID0gJ2FkZHJlc3N8YXJ0aWNsZXxhc2lkZXxiYXNlfGJhc2Vmb250fGJsb2NrcXVvdGV8Ym9keXxjYXB0aW9uJ1xuICAgICsgJ3xjZW50ZXJ8Y29sfGNvbGdyb3VwfGRkfGRldGFpbHN8ZGlhbG9nfGRpcnxkaXZ8ZGx8ZHR8ZmllbGRzZXR8ZmlnY2FwdGlvbidcbiAgICArICd8ZmlndXJlfGZvb3Rlcnxmb3JtfGZyYW1lfGZyYW1lc2V0fGhbMS02XXxoZWFkfGhlYWRlcnxocnxodG1sfGlmcmFtZSdcbiAgICArICd8bGVnZW5kfGxpfGxpbmt8bWFpbnxtZW51fG1lbnVpdGVtfG1ldGF8bmF2fG5vZnJhbWVzfG9sfG9wdGdyb3VwfG9wdGlvbidcbiAgICArICd8cHxwYXJhbXxzZWFyY2h8c2VjdGlvbnxzdW1tYXJ5fHRhYmxlfHRib2R5fHRkfHRmb290fHRofHRoZWFkfHRpdGxlJ1xuICAgICsgJ3x0cnx0cmFja3x1bCc7XG5jb25zdCBfY29tbWVudCA9IC88IS0tKD86LT8+fFtcXHNcXFNdKj8oPzotLT58JCkpLztcbmNvbnN0IGh0bWwgPSBlZGl0KCdeIHswLDN9KD86JyAvLyBvcHRpb25hbCBpbmRlbnRhdGlvblxuICAgICsgJzwoc2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYSlbXFxcXHM+XVtcXFxcc1xcXFxTXSo/KD86PC9cXFxcMT5bXlxcXFxuXSpcXFxcbit8JCknIC8vICgxKVxuICAgICsgJ3xjb21tZW50W15cXFxcbl0qKFxcXFxuK3wkKScgLy8gKDIpXG4gICAgKyAnfDxcXFxcP1tcXFxcc1xcXFxTXSo/KD86XFxcXD8+XFxcXG4qfCQpJyAvLyAoMylcbiAgICArICd8PCFbQS1aXVtcXFxcc1xcXFxTXSo/KD86PlxcXFxuKnwkKScgLy8gKDQpXG4gICAgKyAnfDwhXFxcXFtDREFUQVxcXFxbW1xcXFxzXFxcXFNdKj8oPzpcXFxcXVxcXFxdPlxcXFxuKnwkKScgLy8gKDUpXG4gICAgKyAnfDwvPyh0YWcpKD86ICt8XFxcXG58Lz8+KVtcXFxcc1xcXFxTXSo/KD86KD86XFxcXG5bIFxcdF0qKStcXFxcbnwkKScgLy8gKDYpXG4gICAgKyAnfDwoPyFzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhKShbYS16XVtcXFxcdy1dKikoPzphdHRyaWJ1dGUpKj8gKi8/Pig/PVsgXFxcXHRdKig/OlxcXFxufCQpKVtcXFxcc1xcXFxTXSo/KD86KD86XFxcXG5bIFxcdF0qKStcXFxcbnwkKScgLy8gKDcpIG9wZW4gdGFnXG4gICAgKyAnfDwvKD8hc2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYSlbYS16XVtcXFxcdy1dKlxcXFxzKj4oPz1bIFxcXFx0XSooPzpcXFxcbnwkKSlbXFxcXHNcXFxcU10qPyg/Oig/OlxcXFxuWyBcXHRdKikrXFxcXG58JCknIC8vICg3KSBjbG9zaW5nIHRhZ1xuICAgICsgJyknLCAnaScpXG4gICAgLnJlcGxhY2UoJ2NvbW1lbnQnLCBfY29tbWVudClcbiAgICAucmVwbGFjZSgndGFnJywgX3RhZylcbiAgICAucmVwbGFjZSgnYXR0cmlidXRlJywgLyArW2EtekEtWjpfXVtcXHcuOi1dKig/OiAqPSAqXCJbXlwiXFxuXSpcInwgKj0gKidbXidcXG5dKid8ICo9ICpbXlxcc1wiJz08PmBdKyk/LylcbiAgICAuZ2V0UmVnZXgoKTtcbmNvbnN0IHBhcmFncmFwaCA9IGVkaXQoX3BhcmFncmFwaClcbiAgICAucmVwbGFjZSgnaHInLCBocilcbiAgICAucmVwbGFjZSgnaGVhZGluZycsICcgezAsM30jezEsNn0oPzpcXFxcc3wkKScpXG4gICAgLnJlcGxhY2UoJ3xsaGVhZGluZycsICcnKSAvLyBzZXRleHQgaGVhZGluZ3MgZG9uJ3QgaW50ZXJydXB0IGNvbW1vbm1hcmsgcGFyYWdyYXBoc1xuICAgIC5yZXBsYWNlKCd8dGFibGUnLCAnJylcbiAgICAucmVwbGFjZSgnYmxvY2txdW90ZScsICcgezAsM30+JylcbiAgICAucmVwbGFjZSgnZmVuY2VzJywgJyB7MCwzfSg/OmB7Myx9KD89W15gXFxcXG5dKlxcXFxuKXx+ezMsfSlbXlxcXFxuXSpcXFxcbicpXG4gICAgLnJlcGxhY2UoJ2xpc3QnLCAnIHswLDN9KD86WyorLV18MVsuKV0pICcpIC8vIG9ubHkgbGlzdHMgc3RhcnRpbmcgZnJvbSAxIGNhbiBpbnRlcnJ1cHRcbiAgICAucmVwbGFjZSgnaHRtbCcsICc8Lz8oPzp0YWcpKD86ICt8XFxcXG58Lz8+KXw8KD86c2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYXwhLS0pJylcbiAgICAucmVwbGFjZSgndGFnJywgX3RhZykgLy8gcGFycyBjYW4gYmUgaW50ZXJydXB0ZWQgYnkgdHlwZSAoNikgaHRtbCBibG9ja3NcbiAgICAuZ2V0UmVnZXgoKTtcbmNvbnN0IGJsb2NrcXVvdGUgPSBlZGl0KC9eKCB7MCwzfT4gPyhwYXJhZ3JhcGh8W15cXG5dKikoPzpcXG58JCkpKy8pXG4gICAgLnJlcGxhY2UoJ3BhcmFncmFwaCcsIHBhcmFncmFwaClcbiAgICAuZ2V0UmVnZXgoKTtcbi8qKlxuICogTm9ybWFsIEJsb2NrIEdyYW1tYXJcbiAqL1xuY29uc3QgYmxvY2tOb3JtYWwgPSB7XG4gICAgYmxvY2txdW90ZSxcbiAgICBjb2RlOiBibG9ja0NvZGUsXG4gICAgZGVmLFxuICAgIGZlbmNlcyxcbiAgICBoZWFkaW5nLFxuICAgIGhyLFxuICAgIGh0bWwsXG4gICAgbGhlYWRpbmcsXG4gICAgbGlzdCxcbiAgICBuZXdsaW5lLFxuICAgIHBhcmFncmFwaCxcbiAgICB0YWJsZTogbm9vcFRlc3QsXG4gICAgdGV4dDogYmxvY2tUZXh0LFxufTtcbi8qKlxuICogR0ZNIEJsb2NrIEdyYW1tYXJcbiAqL1xuY29uc3QgZ2ZtVGFibGUgPSBlZGl0KCdeICooW15cXFxcbiBdLiopXFxcXG4nIC8vIEhlYWRlclxuICAgICsgJyB7MCwzfSgoPzpcXFxcfCAqKT86Py0rOj8gKig/OlxcXFx8ICo6Py0rOj8gKikqKD86XFxcXHwgKik/KScgLy8gQWxpZ25cbiAgICArICcoPzpcXFxcbigoPzooPyEgKlxcXFxufGhyfGhlYWRpbmd8YmxvY2txdW90ZXxjb2RlfGZlbmNlc3xsaXN0fGh0bWwpLiooPzpcXFxcbnwkKSkqKVxcXFxuKnwkKScpIC8vIENlbGxzXG4gICAgLnJlcGxhY2UoJ2hyJywgaHIpXG4gICAgLnJlcGxhY2UoJ2hlYWRpbmcnLCAnIHswLDN9I3sxLDZ9KD86XFxcXHN8JCknKVxuICAgIC5yZXBsYWNlKCdibG9ja3F1b3RlJywgJyB7MCwzfT4nKVxuICAgIC5yZXBsYWNlKCdjb2RlJywgJyg/OiB7NH18IHswLDN9XFx0KVteXFxcXG5dJylcbiAgICAucmVwbGFjZSgnZmVuY2VzJywgJyB7MCwzfSg/OmB7Myx9KD89W15gXFxcXG5dKlxcXFxuKXx+ezMsfSlbXlxcXFxuXSpcXFxcbicpXG4gICAgLnJlcGxhY2UoJ2xpc3QnLCAnIHswLDN9KD86WyorLV18MVsuKV0pICcpIC8vIG9ubHkgbGlzdHMgc3RhcnRpbmcgZnJvbSAxIGNhbiBpbnRlcnJ1cHRcbiAgICAucmVwbGFjZSgnaHRtbCcsICc8Lz8oPzp0YWcpKD86ICt8XFxcXG58Lz8+KXw8KD86c2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYXwhLS0pJylcbiAgICAucmVwbGFjZSgndGFnJywgX3RhZykgLy8gdGFibGVzIGNhbiBiZSBpbnRlcnJ1cHRlZCBieSB0eXBlICg2KSBodG1sIGJsb2Nrc1xuICAgIC5nZXRSZWdleCgpO1xuY29uc3QgYmxvY2tHZm0gPSB7XG4gICAgLi4uYmxvY2tOb3JtYWwsXG4gICAgdGFibGU6IGdmbVRhYmxlLFxuICAgIHBhcmFncmFwaDogZWRpdChfcGFyYWdyYXBoKVxuICAgICAgICAucmVwbGFjZSgnaHInLCBocilcbiAgICAgICAgLnJlcGxhY2UoJ2hlYWRpbmcnLCAnIHswLDN9I3sxLDZ9KD86XFxcXHN8JCknKVxuICAgICAgICAucmVwbGFjZSgnfGxoZWFkaW5nJywgJycpIC8vIHNldGV4dCBoZWFkaW5ncyBkb24ndCBpbnRlcnJ1cHQgY29tbW9ubWFyayBwYXJhZ3JhcGhzXG4gICAgICAgIC5yZXBsYWNlKCd0YWJsZScsIGdmbVRhYmxlKSAvLyBpbnRlcnJ1cHQgcGFyYWdyYXBocyB3aXRoIHRhYmxlXG4gICAgICAgIC5yZXBsYWNlKCdibG9ja3F1b3RlJywgJyB7MCwzfT4nKVxuICAgICAgICAucmVwbGFjZSgnZmVuY2VzJywgJyB7MCwzfSg/OmB7Myx9KD89W15gXFxcXG5dKlxcXFxuKXx+ezMsfSlbXlxcXFxuXSpcXFxcbicpXG4gICAgICAgIC5yZXBsYWNlKCdsaXN0JywgJyB7MCwzfSg/OlsqKy1dfDFbLildKSAnKSAvLyBvbmx5IGxpc3RzIHN0YXJ0aW5nIGZyb20gMSBjYW4gaW50ZXJydXB0XG4gICAgICAgIC5yZXBsYWNlKCdodG1sJywgJzwvPyg/OnRhZykoPzogK3xcXFxcbnwvPz4pfDwoPzpzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhfCEtLSknKVxuICAgICAgICAucmVwbGFjZSgndGFnJywgX3RhZykgLy8gcGFycyBjYW4gYmUgaW50ZXJydXB0ZWQgYnkgdHlwZSAoNikgaHRtbCBibG9ja3NcbiAgICAgICAgLmdldFJlZ2V4KCksXG59O1xuLyoqXG4gKiBQZWRhbnRpYyBncmFtbWFyIChvcmlnaW5hbCBKb2huIEdydWJlcidzIGxvb3NlIG1hcmtkb3duIHNwZWNpZmljYXRpb24pXG4gKi9cbmNvbnN0IGJsb2NrUGVkYW50aWMgPSB7XG4gICAgLi4uYmxvY2tOb3JtYWwsXG4gICAgaHRtbDogZWRpdCgnXiAqKD86Y29tbWVudCAqKD86XFxcXG58XFxcXHMqJCknXG4gICAgICAgICsgJ3w8KHRhZylbXFxcXHNcXFxcU10rPzwvXFxcXDE+ICooPzpcXFxcbnsyLH18XFxcXHMqJCknIC8vIGNsb3NlZCB0YWdcbiAgICAgICAgKyAnfDx0YWcoPzpcIlteXCJdKlwifFxcJ1teXFwnXSpcXCd8XFxcXHNbXlxcJ1wiLz5cXFxcc10qKSo/Lz8+ICooPzpcXFxcbnsyLH18XFxcXHMqJCkpJylcbiAgICAgICAgLnJlcGxhY2UoJ2NvbW1lbnQnLCBfY29tbWVudClcbiAgICAgICAgLnJlcGxhY2UoL3RhZy9nLCAnKD8hKD86J1xuICAgICAgICArICdhfGVtfHN0cm9uZ3xzbWFsbHxzfGNpdGV8cXxkZm58YWJicnxkYXRhfHRpbWV8Y29kZXx2YXJ8c2FtcHxrYmR8c3ViJ1xuICAgICAgICArICd8c3VwfGl8Ynx1fG1hcmt8cnVieXxydHxycHxiZGl8YmRvfHNwYW58YnJ8d2JyfGluc3xkZWx8aW1nKSdcbiAgICAgICAgKyAnXFxcXGIpXFxcXHcrKD8hOnxbXlxcXFx3XFxcXHNAXSpAKVxcXFxiJylcbiAgICAgICAgLmdldFJlZ2V4KCksXG4gICAgZGVmOiAvXiAqXFxbKFteXFxdXSspXFxdOiAqPD8oW15cXHM+XSspPj8oPzogKyhbXCIoXVteXFxuXStbXCIpXSkpPyAqKD86XFxuK3wkKS8sXG4gICAgaGVhZGluZzogL14oI3sxLDZ9KSguKikoPzpcXG4rfCQpLyxcbiAgICBmZW5jZXM6IG5vb3BUZXN0LCAvLyBmZW5jZXMgbm90IHN1cHBvcnRlZFxuICAgIGxoZWFkaW5nOiAvXiguKz8pXFxuIHswLDN9KD0rfC0rKSAqKD86XFxuK3wkKS8sXG4gICAgcGFyYWdyYXBoOiBlZGl0KF9wYXJhZ3JhcGgpXG4gICAgICAgIC5yZXBsYWNlKCdocicsIGhyKVxuICAgICAgICAucmVwbGFjZSgnaGVhZGluZycsICcgKiN7MSw2fSAqW15cXG5dJylcbiAgICAgICAgLnJlcGxhY2UoJ2xoZWFkaW5nJywgbGhlYWRpbmcpXG4gICAgICAgIC5yZXBsYWNlKCd8dGFibGUnLCAnJylcbiAgICAgICAgLnJlcGxhY2UoJ2Jsb2NrcXVvdGUnLCAnIHswLDN9PicpXG4gICAgICAgIC5yZXBsYWNlKCd8ZmVuY2VzJywgJycpXG4gICAgICAgIC5yZXBsYWNlKCd8bGlzdCcsICcnKVxuICAgICAgICAucmVwbGFjZSgnfGh0bWwnLCAnJylcbiAgICAgICAgLnJlcGxhY2UoJ3x0YWcnLCAnJylcbiAgICAgICAgLmdldFJlZ2V4KCksXG59O1xuLyoqXG4gKiBJbmxpbmUtTGV2ZWwgR3JhbW1hclxuICovXG5jb25zdCBlc2NhcGUkMSA9IC9eXFxcXChbIVwiIyQlJicoKSorLFxcLS4vOjs8PT4/QFxcW1xcXVxcXFxeX2B7fH1+XSkvO1xuY29uc3QgaW5saW5lQ29kZSA9IC9eKGArKShbXmBdfFteYF1bXFxzXFxTXSo/W15gXSlcXDEoPyFgKS87XG5jb25zdCBiciA9IC9eKCB7Mix9fFxcXFwpXFxuKD8hXFxzKiQpLztcbmNvbnN0IGlubGluZVRleHQgPSAvXihgK3xbXmBdKSg/Oig/PSB7Mix9XFxuKXxbXFxzXFxTXSo/KD86KD89W1xcXFw8IVxcW2AqX118XFxiX3wkKXxbXiBdKD89IHsyLH1cXG4pKSkvO1xuLy8gbGlzdCBvZiB1bmljb2RlIHB1bmN0dWF0aW9uIG1hcmtzLCBwbHVzIGFueSBtaXNzaW5nIGNoYXJhY3RlcnMgZnJvbSBDb21tb25NYXJrIHNwZWNcbmNvbnN0IF9wdW5jdHVhdGlvbiA9IC9bXFxwe1B9XFxwe1N9XS91O1xuY29uc3QgX3B1bmN0dWF0aW9uT3JTcGFjZSA9IC9bXFxzXFxwe1B9XFxwe1N9XS91O1xuY29uc3QgX25vdFB1bmN0dWF0aW9uT3JTcGFjZSA9IC9bXlxcc1xccHtQfVxccHtTfV0vdTtcbmNvbnN0IHB1bmN0dWF0aW9uID0gZWRpdCgvXigoPyFbKl9dKXB1bmN0U3BhY2UpLywgJ3UnKVxuICAgIC5yZXBsYWNlKC9wdW5jdFNwYWNlL2csIF9wdW5jdHVhdGlvbk9yU3BhY2UpLmdldFJlZ2V4KCk7XG4vLyBzZXF1ZW5jZXMgZW0gc2hvdWxkIHNraXAgb3ZlciBbdGl0bGVdKGxpbmspLCBgY29kZWAsIDxodG1sPlxuY29uc3QgYmxvY2tTa2lwID0gL1xcW1teW1xcXV0qP1xcXVxcKCg/OlxcXFwufFteXFxcXFxcKFxcKV18XFwoKD86XFxcXC58W15cXFxcXFwoXFwpXSkqXFwpKSpcXCl8YFteYF0qP2B8PFtePD5dKj8+L2c7XG5jb25zdCBlbVN0cm9uZ0xEZWxpbSA9IGVkaXQoL14oPzpcXCorKD86KCg/IVxcKilwdW5jdCl8W15cXHMqXSkpfF5fKyg/OigoPyFfKXB1bmN0KXwoW15cXHNfXSkpLywgJ3UnKVxuICAgIC5yZXBsYWNlKC9wdW5jdC9nLCBfcHVuY3R1YXRpb24pXG4gICAgLmdldFJlZ2V4KCk7XG5jb25zdCBlbVN0cm9uZ1JEZWxpbUFzdCA9IGVkaXQoJ15bXl8qXSo/X19bXl8qXSo/XFxcXCpbXl8qXSo/KD89X18pJyAvLyBTa2lwIG9ycGhhbiBpbnNpZGUgc3Ryb25nXG4gICAgKyAnfFteKl0rKD89W14qXSknIC8vIENvbnN1bWUgdG8gZGVsaW1cbiAgICArICd8KD8hXFxcXCopcHVuY3QoXFxcXCorKSg/PVtcXFxcc118JCknIC8vICgxKSAjKioqIGNhbiBvbmx5IGJlIGEgUmlnaHQgRGVsaW1pdGVyXG4gICAgKyAnfG5vdFB1bmN0U3BhY2UoXFxcXCorKSg/IVxcXFwqKSg/PXB1bmN0U3BhY2V8JCknIC8vICgyKSBhKioqIywgYSoqKiBjYW4gb25seSBiZSBhIFJpZ2h0IERlbGltaXRlclxuICAgICsgJ3woPyFcXFxcKilwdW5jdFNwYWNlKFxcXFwqKykoPz1ub3RQdW5jdFNwYWNlKScgLy8gKDMpICMqKiphLCAqKiphIGNhbiBvbmx5IGJlIExlZnQgRGVsaW1pdGVyXG4gICAgKyAnfFtcXFxcc10oXFxcXCorKSg/IVxcXFwqKSg/PXB1bmN0KScgLy8gKDQpICoqKiMgY2FuIG9ubHkgYmUgTGVmdCBEZWxpbWl0ZXJcbiAgICArICd8KD8hXFxcXCopcHVuY3QoXFxcXCorKSg/IVxcXFwqKSg/PXB1bmN0KScgLy8gKDUpICMqKiojIGNhbiBiZSBlaXRoZXIgTGVmdCBvciBSaWdodCBEZWxpbWl0ZXJcbiAgICArICd8bm90UHVuY3RTcGFjZShcXFxcKispKD89bm90UHVuY3RTcGFjZSknLCAnZ3UnKSAvLyAoNikgYSoqKmEgY2FuIGJlIGVpdGhlciBMZWZ0IG9yIFJpZ2h0IERlbGltaXRlclxuICAgIC5yZXBsYWNlKC9ub3RQdW5jdFNwYWNlL2csIF9ub3RQdW5jdHVhdGlvbk9yU3BhY2UpXG4gICAgLnJlcGxhY2UoL3B1bmN0U3BhY2UvZywgX3B1bmN0dWF0aW9uT3JTcGFjZSlcbiAgICAucmVwbGFjZSgvcHVuY3QvZywgX3B1bmN0dWF0aW9uKVxuICAgIC5nZXRSZWdleCgpO1xuLy8gKDYpIE5vdCBhbGxvd2VkIGZvciBfXG5jb25zdCBlbVN0cm9uZ1JEZWxpbVVuZCA9IGVkaXQoJ15bXl8qXSo/XFxcXCpcXFxcKlteXypdKj9fW15fKl0qPyg/PVxcXFwqXFxcXCopJyAvLyBTa2lwIG9ycGhhbiBpbnNpZGUgc3Ryb25nXG4gICAgKyAnfFteX10rKD89W15fXSknIC8vIENvbnN1bWUgdG8gZGVsaW1cbiAgICArICd8KD8hXylwdW5jdChfKykoPz1bXFxcXHNdfCQpJyAvLyAoMSkgI19fXyBjYW4gb25seSBiZSBhIFJpZ2h0IERlbGltaXRlclxuICAgICsgJ3xub3RQdW5jdFNwYWNlKF8rKSg/IV8pKD89cHVuY3RTcGFjZXwkKScgLy8gKDIpIGFfX18jLCBhX19fIGNhbiBvbmx5IGJlIGEgUmlnaHQgRGVsaW1pdGVyXG4gICAgKyAnfCg/IV8pcHVuY3RTcGFjZShfKykoPz1ub3RQdW5jdFNwYWNlKScgLy8gKDMpICNfX19hLCBfX19hIGNhbiBvbmx5IGJlIExlZnQgRGVsaW1pdGVyXG4gICAgKyAnfFtcXFxcc10oXyspKD8hXykoPz1wdW5jdCknIC8vICg0KSBfX18jIGNhbiBvbmx5IGJlIExlZnQgRGVsaW1pdGVyXG4gICAgKyAnfCg/IV8pcHVuY3QoXyspKD8hXykoPz1wdW5jdCknLCAnZ3UnKSAvLyAoNSkgI19fXyMgY2FuIGJlIGVpdGhlciBMZWZ0IG9yIFJpZ2h0IERlbGltaXRlclxuICAgIC5yZXBsYWNlKC9ub3RQdW5jdFNwYWNlL2csIF9ub3RQdW5jdHVhdGlvbk9yU3BhY2UpXG4gICAgLnJlcGxhY2UoL3B1bmN0U3BhY2UvZywgX3B1bmN0dWF0aW9uT3JTcGFjZSlcbiAgICAucmVwbGFjZSgvcHVuY3QvZywgX3B1bmN0dWF0aW9uKVxuICAgIC5nZXRSZWdleCgpO1xuY29uc3QgYW55UHVuY3R1YXRpb24gPSBlZGl0KC9cXFxcKHB1bmN0KS8sICdndScpXG4gICAgLnJlcGxhY2UoL3B1bmN0L2csIF9wdW5jdHVhdGlvbilcbiAgICAuZ2V0UmVnZXgoKTtcbmNvbnN0IGF1dG9saW5rID0gZWRpdCgvXjwoc2NoZW1lOlteXFxzXFx4MDAtXFx4MWY8Pl0qfGVtYWlsKT4vKVxuICAgIC5yZXBsYWNlKCdzY2hlbWUnLCAvW2EtekEtWl1bYS16QS1aMC05Ky4tXXsxLDMxfS8pXG4gICAgLnJlcGxhY2UoJ2VtYWlsJywgL1thLXpBLVowLTkuISMkJSYnKisvPT9eX2B7fH1+LV0rKEApW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSsoPyFbLV9dKS8pXG4gICAgLmdldFJlZ2V4KCk7XG5jb25zdCBfaW5saW5lQ29tbWVudCA9IGVkaXQoX2NvbW1lbnQpLnJlcGxhY2UoJyg/Oi0tPnwkKScsICctLT4nKS5nZXRSZWdleCgpO1xuY29uc3QgdGFnID0gZWRpdCgnXmNvbW1lbnQnXG4gICAgKyAnfF48L1thLXpBLVpdW1xcXFx3Oi1dKlxcXFxzKj4nIC8vIHNlbGYtY2xvc2luZyB0YWdcbiAgICArICd8XjxbYS16QS1aXVtcXFxcdy1dKig/OmF0dHJpYnV0ZSkqP1xcXFxzKi8/PicgLy8gb3BlbiB0YWdcbiAgICArICd8XjxcXFxcP1tcXFxcc1xcXFxTXSo/XFxcXD8+JyAvLyBwcm9jZXNzaW5nIGluc3RydWN0aW9uLCBlLmcuIDw/cGhwID8+XG4gICAgKyAnfF48IVthLXpBLVpdK1xcXFxzW1xcXFxzXFxcXFNdKj8+JyAvLyBkZWNsYXJhdGlvbiwgZS5nLiA8IURPQ1RZUEUgaHRtbD5cbiAgICArICd8XjwhXFxcXFtDREFUQVxcXFxbW1xcXFxzXFxcXFNdKj9cXFxcXVxcXFxdPicpIC8vIENEQVRBIHNlY3Rpb25cbiAgICAucmVwbGFjZSgnY29tbWVudCcsIF9pbmxpbmVDb21tZW50KVxuICAgIC5yZXBsYWNlKCdhdHRyaWJ1dGUnLCAvXFxzK1thLXpBLVo6X11bXFx3LjotXSooPzpcXHMqPVxccypcIlteXCJdKlwifFxccyo9XFxzKidbXiddKid8XFxzKj1cXHMqW15cXHNcIic9PD5gXSspPy8pXG4gICAgLmdldFJlZ2V4KCk7XG5jb25zdCBfaW5saW5lTGFiZWwgPSAvKD86XFxbKD86XFxcXC58W15cXFtcXF1cXFxcXSkqXFxdfFxcXFwufGBbXmBdKmB8W15cXFtcXF1cXFxcYF0pKj8vO1xuY29uc3QgbGluayA9IGVkaXQoL14hP1xcWyhsYWJlbClcXF1cXChcXHMqKGhyZWYpKD86XFxzKyh0aXRsZSkpP1xccypcXCkvKVxuICAgIC5yZXBsYWNlKCdsYWJlbCcsIF9pbmxpbmVMYWJlbClcbiAgICAucmVwbGFjZSgnaHJlZicsIC88KD86XFxcXC58W15cXG48PlxcXFxdKSs+fFteXFxzXFx4MDAtXFx4MWZdKi8pXG4gICAgLnJlcGxhY2UoJ3RpdGxlJywgL1wiKD86XFxcXFwiP3xbXlwiXFxcXF0pKlwifCcoPzpcXFxcJz98W14nXFxcXF0pKid8XFwoKD86XFxcXFxcKT98W14pXFxcXF0pKlxcKS8pXG4gICAgLmdldFJlZ2V4KCk7XG5jb25zdCByZWZsaW5rID0gZWRpdCgvXiE/XFxbKGxhYmVsKVxcXVxcWyhyZWYpXFxdLylcbiAgICAucmVwbGFjZSgnbGFiZWwnLCBfaW5saW5lTGFiZWwpXG4gICAgLnJlcGxhY2UoJ3JlZicsIF9ibG9ja0xhYmVsKVxuICAgIC5nZXRSZWdleCgpO1xuY29uc3Qgbm9saW5rID0gZWRpdCgvXiE/XFxbKHJlZilcXF0oPzpcXFtcXF0pPy8pXG4gICAgLnJlcGxhY2UoJ3JlZicsIF9ibG9ja0xhYmVsKVxuICAgIC5nZXRSZWdleCgpO1xuY29uc3QgcmVmbGlua1NlYXJjaCA9IGVkaXQoJ3JlZmxpbmt8bm9saW5rKD8hXFxcXCgpJywgJ2cnKVxuICAgIC5yZXBsYWNlKCdyZWZsaW5rJywgcmVmbGluaylcbiAgICAucmVwbGFjZSgnbm9saW5rJywgbm9saW5rKVxuICAgIC5nZXRSZWdleCgpO1xuLyoqXG4gKiBOb3JtYWwgSW5saW5lIEdyYW1tYXJcbiAqL1xuY29uc3QgaW5saW5lTm9ybWFsID0ge1xuICAgIF9iYWNrcGVkYWw6IG5vb3BUZXN0LCAvLyBvbmx5IHVzZWQgZm9yIEdGTSB1cmxcbiAgICBhbnlQdW5jdHVhdGlvbixcbiAgICBhdXRvbGluayxcbiAgICBibG9ja1NraXAsXG4gICAgYnIsXG4gICAgY29kZTogaW5saW5lQ29kZSxcbiAgICBkZWw6IG5vb3BUZXN0LFxuICAgIGVtU3Ryb25nTERlbGltLFxuICAgIGVtU3Ryb25nUkRlbGltQXN0LFxuICAgIGVtU3Ryb25nUkRlbGltVW5kLFxuICAgIGVzY2FwZTogZXNjYXBlJDEsXG4gICAgbGluayxcbiAgICBub2xpbmssXG4gICAgcHVuY3R1YXRpb24sXG4gICAgcmVmbGluayxcbiAgICByZWZsaW5rU2VhcmNoLFxuICAgIHRhZyxcbiAgICB0ZXh0OiBpbmxpbmVUZXh0LFxuICAgIHVybDogbm9vcFRlc3QsXG59O1xuLyoqXG4gKiBQZWRhbnRpYyBJbmxpbmUgR3JhbW1hclxuICovXG5jb25zdCBpbmxpbmVQZWRhbnRpYyA9IHtcbiAgICAuLi5pbmxpbmVOb3JtYWwsXG4gICAgbGluazogZWRpdCgvXiE/XFxbKGxhYmVsKVxcXVxcKCguKj8pXFwpLylcbiAgICAgICAgLnJlcGxhY2UoJ2xhYmVsJywgX2lubGluZUxhYmVsKVxuICAgICAgICAuZ2V0UmVnZXgoKSxcbiAgICByZWZsaW5rOiBlZGl0KC9eIT9cXFsobGFiZWwpXFxdXFxzKlxcWyhbXlxcXV0qKVxcXS8pXG4gICAgICAgIC5yZXBsYWNlKCdsYWJlbCcsIF9pbmxpbmVMYWJlbClcbiAgICAgICAgLmdldFJlZ2V4KCksXG59O1xuLyoqXG4gKiBHRk0gSW5saW5lIEdyYW1tYXJcbiAqL1xuY29uc3QgaW5saW5lR2ZtID0ge1xuICAgIC4uLmlubGluZU5vcm1hbCxcbiAgICBlc2NhcGU6IGVkaXQoZXNjYXBlJDEpLnJlcGxhY2UoJ10pJywgJ358XSknKS5nZXRSZWdleCgpLFxuICAgIHVybDogZWRpdCgvXigoPzpmdHB8aHR0cHM/KTpcXC9cXC98d3d3XFwuKSg/OlthLXpBLVowLTlcXC1dK1xcLj8pK1teXFxzPF0qfF5lbWFpbC8sICdpJylcbiAgICAgICAgLnJlcGxhY2UoJ2VtYWlsJywgL1tBLVphLXowLTkuXystXSsoQClbYS16QS1aMC05LV9dKyg/OlxcLlthLXpBLVowLTktX10qW2EtekEtWjAtOV0pKyg/IVstX10pLylcbiAgICAgICAgLmdldFJlZ2V4KCksXG4gICAgX2JhY2twZWRhbDogLyg/OltePyEuLDo7Kl8nXCJ+KCkmXSt8XFwoW14pXSpcXCl8Jig/IVthLXpBLVowLTldKzskKXxbPyEuLDo7Kl8nXCJ+KV0rKD8hJCkpKy8sXG4gICAgZGVsOiAvXih+fj8pKD89W15cXHN+XSkoKD86XFxcXC58W15cXFxcXSkqPyg/OlxcXFwufFteXFxzflxcXFxdKSlcXDEoPz1bXn5dfCQpLyxcbiAgICB0ZXh0OiAvXihbYH5dK3xbXmB+XSkoPzooPz0gezIsfVxcbil8KD89W2EtekEtWjAtOS4hIyQlJicqK1xcLz0/X2B7XFx8fX4tXStAKXxbXFxzXFxTXSo/KD86KD89W1xcXFw8IVxcW2Aqfl9dfFxcYl98aHR0cHM/OlxcL1xcL3xmdHA6XFwvXFwvfHd3d1xcLnwkKXxbXiBdKD89IHsyLH1cXG4pfFteYS16QS1aMC05LiEjJCUmJyorXFwvPT9fYHtcXHx9fi1dKD89W2EtekEtWjAtOS4hIyQlJicqK1xcLz0/X2B7XFx8fX4tXStAKSkpLyxcbn07XG4vKipcbiAqIEdGTSArIExpbmUgQnJlYWtzIElubGluZSBHcmFtbWFyXG4gKi9cbmNvbnN0IGlubGluZUJyZWFrcyA9IHtcbiAgICAuLi5pbmxpbmVHZm0sXG4gICAgYnI6IGVkaXQoYnIpLnJlcGxhY2UoJ3syLH0nLCAnKicpLmdldFJlZ2V4KCksXG4gICAgdGV4dDogZWRpdChpbmxpbmVHZm0udGV4dClcbiAgICAgICAgLnJlcGxhY2UoJ1xcXFxiXycsICdcXFxcYl98IHsyLH1cXFxcbicpXG4gICAgICAgIC5yZXBsYWNlKC9cXHsyLFxcfS9nLCAnKicpXG4gICAgICAgIC5nZXRSZWdleCgpLFxufTtcbi8qKlxuICogZXhwb3J0c1xuICovXG5jb25zdCBibG9jayA9IHtcbiAgICBub3JtYWw6IGJsb2NrTm9ybWFsLFxuICAgIGdmbTogYmxvY2tHZm0sXG4gICAgcGVkYW50aWM6IGJsb2NrUGVkYW50aWMsXG59O1xuY29uc3QgaW5saW5lID0ge1xuICAgIG5vcm1hbDogaW5saW5lTm9ybWFsLFxuICAgIGdmbTogaW5saW5lR2ZtLFxuICAgIGJyZWFrczogaW5saW5lQnJlYWtzLFxuICAgIHBlZGFudGljOiBpbmxpbmVQZWRhbnRpYyxcbn07XG5cbi8qKlxuICogSGVscGVyc1xuICovXG5jb25zdCBlc2NhcGVSZXBsYWNlbWVudHMgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiMzOTsnLFxufTtcbmNvbnN0IGdldEVzY2FwZVJlcGxhY2VtZW50ID0gKGNoKSA9PiBlc2NhcGVSZXBsYWNlbWVudHNbY2hdO1xuZnVuY3Rpb24gZXNjYXBlKGh0bWwsIGVuY29kZSkge1xuICAgIGlmIChlbmNvZGUpIHtcbiAgICAgICAgaWYgKG90aGVyLmVzY2FwZVRlc3QudGVzdChodG1sKSkge1xuICAgICAgICAgICAgcmV0dXJuIGh0bWwucmVwbGFjZShvdGhlci5lc2NhcGVSZXBsYWNlLCBnZXRFc2NhcGVSZXBsYWNlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChvdGhlci5lc2NhcGVUZXN0Tm9FbmNvZGUudGVzdChodG1sKSkge1xuICAgICAgICAgICAgcmV0dXJuIGh0bWwucmVwbGFjZShvdGhlci5lc2NhcGVSZXBsYWNlTm9FbmNvZGUsIGdldEVzY2FwZVJlcGxhY2VtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaHRtbDtcbn1cbmZ1bmN0aW9uIGNsZWFuVXJsKGhyZWYpIHtcbiAgICB0cnkge1xuICAgICAgICBocmVmID0gZW5jb2RlVVJJKGhyZWYpLnJlcGxhY2Uob3RoZXIucGVyY2VudERlY29kZSwgJyUnKTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGhyZWY7XG59XG5mdW5jdGlvbiBzcGxpdENlbGxzKHRhYmxlUm93LCBjb3VudCkge1xuICAgIC8vIGVuc3VyZSB0aGF0IGV2ZXJ5IGNlbGwtZGVsaW1pdGluZyBwaXBlIGhhcyBhIHNwYWNlXG4gICAgLy8gYmVmb3JlIGl0IHRvIGRpc3Rpbmd1aXNoIGl0IGZyb20gYW4gZXNjYXBlZCBwaXBlXG4gICAgY29uc3Qgcm93ID0gdGFibGVSb3cucmVwbGFjZShvdGhlci5maW5kUGlwZSwgKG1hdGNoLCBvZmZzZXQsIHN0cikgPT4ge1xuICAgICAgICBsZXQgZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgY3VyciA9IG9mZnNldDtcbiAgICAgICAgd2hpbGUgKC0tY3VyciA+PSAwICYmIHN0cltjdXJyXSA9PT0gJ1xcXFwnKVxuICAgICAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkO1xuICAgICAgICBpZiAoZXNjYXBlZCkge1xuICAgICAgICAgICAgLy8gb2RkIG51bWJlciBvZiBzbGFzaGVzIG1lYW5zIHwgaXMgZXNjYXBlZFxuICAgICAgICAgICAgLy8gc28gd2UgbGVhdmUgaXQgYWxvbmVcbiAgICAgICAgICAgIHJldHVybiAnfCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBhZGQgc3BhY2UgYmVmb3JlIHVuZXNjYXBlZCB8XG4gICAgICAgICAgICByZXR1cm4gJyB8JztcbiAgICAgICAgfVxuICAgIH0pLCBjZWxscyA9IHJvdy5zcGxpdChvdGhlci5zcGxpdFBpcGUpO1xuICAgIGxldCBpID0gMDtcbiAgICAvLyBGaXJzdC9sYXN0IGNlbGwgaW4gYSByb3cgY2Fubm90IGJlIGVtcHR5IGlmIGl0IGhhcyBubyBsZWFkaW5nL3RyYWlsaW5nIHBpcGVcbiAgICBpZiAoIWNlbGxzWzBdLnRyaW0oKSkge1xuICAgICAgICBjZWxscy5zaGlmdCgpO1xuICAgIH1cbiAgICBpZiAoY2VsbHMubGVuZ3RoID4gMCAmJiAhY2VsbHMuYXQoLTEpPy50cmltKCkpIHtcbiAgICAgICAgY2VsbHMucG9wKCk7XG4gICAgfVxuICAgIGlmIChjb3VudCkge1xuICAgICAgICBpZiAoY2VsbHMubGVuZ3RoID4gY291bnQpIHtcbiAgICAgICAgICAgIGNlbGxzLnNwbGljZShjb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAoY2VsbHMubGVuZ3RoIDwgY291bnQpXG4gICAgICAgICAgICAgICAgY2VsbHMucHVzaCgnJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICg7IGkgPCBjZWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBsZWFkaW5nIG9yIHRyYWlsaW5nIHdoaXRlc3BhY2UgaXMgaWdub3JlZCBwZXIgdGhlIGdmbSBzcGVjXG4gICAgICAgIGNlbGxzW2ldID0gY2VsbHNbaV0udHJpbSgpLnJlcGxhY2Uob3RoZXIuc2xhc2hQaXBlLCAnfCcpO1xuICAgIH1cbiAgICByZXR1cm4gY2VsbHM7XG59XG4vKipcbiAqIFJlbW92ZSB0cmFpbGluZyAnYydzLiBFcXVpdmFsZW50IHRvIHN0ci5yZXBsYWNlKC9jKiQvLCAnJykuXG4gKiAvYyokLyBpcyB2dWxuZXJhYmxlIHRvIFJFRE9TLlxuICpcbiAqIEBwYXJhbSBzdHJcbiAqIEBwYXJhbSBjXG4gKiBAcGFyYW0gaW52ZXJ0IFJlbW92ZSBzdWZmaXggb2Ygbm9uLWMgY2hhcnMgaW5zdGVhZC4gRGVmYXVsdCBmYWxzZXkuXG4gKi9cbmZ1bmN0aW9uIHJ0cmltKHN0ciwgYywgaW52ZXJ0KSB7XG4gICAgY29uc3QgbCA9IHN0ci5sZW5ndGg7XG4gICAgaWYgKGwgPT09IDApIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICAvLyBMZW5ndGggb2Ygc3VmZml4IG1hdGNoaW5nIHRoZSBpbnZlcnQgY29uZGl0aW9uLlxuICAgIGxldCBzdWZmTGVuID0gMDtcbiAgICAvLyBTdGVwIGxlZnQgdW50aWwgd2UgZmFpbCB0byBtYXRjaCB0aGUgaW52ZXJ0IGNvbmRpdGlvbi5cbiAgICB3aGlsZSAoc3VmZkxlbiA8IGwpIHtcbiAgICAgICAgY29uc3QgY3VyckNoYXIgPSBzdHIuY2hhckF0KGwgLSBzdWZmTGVuIC0gMSk7XG4gICAgICAgIGlmIChjdXJyQ2hhciA9PT0gYyAmJiAhaW52ZXJ0KSB7XG4gICAgICAgICAgICBzdWZmTGVuKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VyckNoYXIgIT09IGMgJiYgaW52ZXJ0KSB7XG4gICAgICAgICAgICBzdWZmTGVuKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyLnNsaWNlKDAsIGwgLSBzdWZmTGVuKTtcbn1cbmZ1bmN0aW9uIGZpbmRDbG9zaW5nQnJhY2tldChzdHIsIGIpIHtcbiAgICBpZiAoc3RyLmluZGV4T2YoYlsxXSkgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgbGV0IGxldmVsID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc3RyW2ldID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdHJbaV0gPT09IGJbMF0pIHtcbiAgICAgICAgICAgIGxldmVsKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RyW2ldID09PSBiWzFdKSB7XG4gICAgICAgICAgICBsZXZlbC0tO1xuICAgICAgICAgICAgaWYgKGxldmVsIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gb3V0cHV0TGluayhjYXAsIGxpbmssIHJhdywgbGV4ZXIsIHJ1bGVzKSB7XG4gICAgY29uc3QgaHJlZiA9IGxpbmsuaHJlZjtcbiAgICBjb25zdCB0aXRsZSA9IGxpbmsudGl0bGUgfHwgbnVsbDtcbiAgICBjb25zdCB0ZXh0ID0gY2FwWzFdLnJlcGxhY2UocnVsZXMub3RoZXIub3V0cHV0TGlua1JlcGxhY2UsICckMScpO1xuICAgIGlmIChjYXBbMF0uY2hhckF0KDApICE9PSAnIScpIHtcbiAgICAgICAgbGV4ZXIuc3RhdGUuaW5MaW5rID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgdG9rZW4gPSB7XG4gICAgICAgICAgICB0eXBlOiAnbGluaycsXG4gICAgICAgICAgICByYXcsXG4gICAgICAgICAgICBocmVmLFxuICAgICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgdG9rZW5zOiBsZXhlci5pbmxpbmVUb2tlbnModGV4dCksXG4gICAgICAgIH07XG4gICAgICAgIGxleGVyLnN0YXRlLmluTGluayA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdpbWFnZScsXG4gICAgICAgIHJhdyxcbiAgICAgICAgaHJlZixcbiAgICAgICAgdGl0bGUsXG4gICAgICAgIHRleHQsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGluZGVudENvZGVDb21wZW5zYXRpb24ocmF3LCB0ZXh0LCBydWxlcykge1xuICAgIGNvbnN0IG1hdGNoSW5kZW50VG9Db2RlID0gcmF3Lm1hdGNoKHJ1bGVzLm90aGVyLmluZGVudENvZGVDb21wZW5zYXRpb24pO1xuICAgIGlmIChtYXRjaEluZGVudFRvQ29kZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgY29uc3QgaW5kZW50VG9Db2RlID0gbWF0Y2hJbmRlbnRUb0NvZGVbMV07XG4gICAgcmV0dXJuIHRleHRcbiAgICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgICAubWFwKG5vZGUgPT4ge1xuICAgICAgICBjb25zdCBtYXRjaEluZGVudEluTm9kZSA9IG5vZGUubWF0Y2gocnVsZXMub3RoZXIuYmVnaW5uaW5nU3BhY2UpO1xuICAgICAgICBpZiAobWF0Y2hJbmRlbnRJbk5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtpbmRlbnRJbk5vZGVdID0gbWF0Y2hJbmRlbnRJbk5vZGU7XG4gICAgICAgIGlmIChpbmRlbnRJbk5vZGUubGVuZ3RoID49IGluZGVudFRvQ29kZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLnNsaWNlKGluZGVudFRvQ29kZS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0pXG4gICAgICAgIC5qb2luKCdcXG4nKTtcbn1cbi8qKlxuICogVG9rZW5pemVyXG4gKi9cbmNsYXNzIF9Ub2tlbml6ZXIge1xuICAgIG9wdGlvbnM7XG4gICAgcnVsZXM7IC8vIHNldCBieSB0aGUgbGV4ZXJcbiAgICBsZXhlcjsgLy8gc2V0IGJ5IHRoZSBsZXhlclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBfZGVmYXVsdHM7XG4gICAgfVxuICAgIHNwYWNlKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLm5ld2xpbmUuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwICYmIGNhcFswXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzcGFjZScsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvZGUoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2suY29kZS5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBjYXBbMF0ucmVwbGFjZSh0aGlzLnJ1bGVzLm90aGVyLmNvZGVSZW1vdmVJbmRlbnQsICcnKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIGNvZGVCbG9ja1N0eWxlOiAnaW5kZW50ZWQnLFxuICAgICAgICAgICAgICAgIHRleHQ6ICF0aGlzLm9wdGlvbnMucGVkYW50aWNcbiAgICAgICAgICAgICAgICAgICAgPyBydHJpbSh0ZXh0LCAnXFxuJylcbiAgICAgICAgICAgICAgICAgICAgOiB0ZXh0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmZW5jZXMoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2suZmVuY2VzLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgY29uc3QgcmF3ID0gY2FwWzBdO1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IGluZGVudENvZGVDb21wZW5zYXRpb24ocmF3LCBjYXBbM10gfHwgJycsIHRoaXMucnVsZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29kZScsXG4gICAgICAgICAgICAgICAgcmF3LFxuICAgICAgICAgICAgICAgIGxhbmc6IGNhcFsyXSA/IGNhcFsyXS50cmltKCkucmVwbGFjZSh0aGlzLnJ1bGVzLmlubGluZS5hbnlQdW5jdHVhdGlvbiwgJyQxJykgOiBjYXBbMl0sXG4gICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGVhZGluZyhzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5oZWFkaW5nLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgbGV0IHRleHQgPSBjYXBbMl0udHJpbSgpO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nICNzXG4gICAgICAgICAgICBpZiAodGhpcy5ydWxlcy5vdGhlci5lbmRpbmdIYXNoLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmltbWVkID0gcnRyaW0odGV4dCwgJyMnKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSB0cmltbWVkLnRyaW0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIXRyaW1tZWQgfHwgdGhpcy5ydWxlcy5vdGhlci5lbmRpbmdTcGFjZUNoYXIudGVzdCh0cmltbWVkKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb21tb25NYXJrIHJlcXVpcmVzIHNwYWNlIGJlZm9yZSB0cmFpbGluZyAjc1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdHJpbW1lZC50cmltKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaGVhZGluZycsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgZGVwdGg6IGNhcFsxXS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lKHRleHQpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBocihzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5oci5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2hyJyxcbiAgICAgICAgICAgICAgICByYXc6IHJ0cmltKGNhcFswXSwgJ1xcbicpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBibG9ja3F1b3RlKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmJsb2NrcXVvdGUuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICBsZXQgbGluZXMgPSBydHJpbShjYXBbMF0sICdcXG4nKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICBsZXQgcmF3ID0gJyc7XG4gICAgICAgICAgICBsZXQgdGV4dCA9ICcnO1xuICAgICAgICAgICAgY29uc3QgdG9rZW5zID0gW107XG4gICAgICAgICAgICB3aGlsZSAobGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBpbkJsb2NrcXVvdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50TGluZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IGxpbmVzIHVwIHRvIGEgY29udGludWF0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJ1bGVzLm90aGVyLmJsb2NrcXVvdGVTdGFydC50ZXN0KGxpbmVzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudExpbmVzLnB1c2gobGluZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5CbG9ja3F1b3RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghaW5CbG9ja3F1b3RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGluZXMucHVzaChsaW5lc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaW5lcyA9IGxpbmVzLnNsaWNlKGkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRSYXcgPSBjdXJyZW50TGluZXMuam9pbignXFxuJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFRleHQgPSBjdXJyZW50UmF3XG4gICAgICAgICAgICAgICAgICAgIC8vIHByZWNlZGUgc2V0ZXh0IGNvbnRpbnVhdGlvbiB3aXRoIDQgc3BhY2VzIHNvIGl0IGlzbid0IGEgc2V0ZXh0XG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKHRoaXMucnVsZXMub3RoZXIuYmxvY2txdW90ZVNldGV4dFJlcGxhY2UsICdcXG4gICAgJDEnKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSh0aGlzLnJ1bGVzLm90aGVyLmJsb2NrcXVvdGVTZXRleHRSZXBsYWNlMiwgJycpO1xuICAgICAgICAgICAgICAgIHJhdyA9IHJhdyA/IGAke3Jhd31cXG4ke2N1cnJlbnRSYXd9YCA6IGN1cnJlbnRSYXc7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQgPyBgJHt0ZXh0fVxcbiR7Y3VycmVudFRleHR9YCA6IGN1cnJlbnRUZXh0O1xuICAgICAgICAgICAgICAgIC8vIHBhcnNlIGJsb2NrcXVvdGUgbGluZXMgYXMgdG9wIGxldmVsIHRva2Vuc1xuICAgICAgICAgICAgICAgIC8vIG1lcmdlIHBhcmFncmFwaHMgaWYgdGhpcyBpcyBhIGNvbnRpbnVhdGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IHRvcCA9IHRoaXMubGV4ZXIuc3RhdGUudG9wO1xuICAgICAgICAgICAgICAgIHRoaXMubGV4ZXIuc3RhdGUudG9wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmxleGVyLmJsb2NrVG9rZW5zKGN1cnJlbnRUZXh0LCB0b2tlbnMsIHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMubGV4ZXIuc3RhdGUudG9wID0gdG9wO1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGNvbnRpbnVhdGlvbiB0aGVuIHdlIGFyZSBkb25lXG4gICAgICAgICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdFRva2VuID0gdG9rZW5zLmF0KC0xKTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFRva2VuPy50eXBlID09PSAnY29kZScpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYmxvY2txdW90ZSBjb250aW51YXRpb24gY2Fubm90IGJlIHByZWNlZGVkIGJ5IGEgY29kZSBibG9ja1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobGFzdFRva2VuPy50eXBlID09PSAnYmxvY2txdW90ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5jbHVkZSBjb250aW51YXRpb24gaW4gbmVzdGVkIGJsb2NrcXVvdGVcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2xkVG9rZW4gPSBsYXN0VG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1RleHQgPSBvbGRUb2tlbi5yYXcgKyAnXFxuJyArIGxpbmVzLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdUb2tlbiA9IHRoaXMuYmxvY2txdW90ZShuZXdUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXSA9IG5ld1Rva2VuO1xuICAgICAgICAgICAgICAgICAgICByYXcgPSByYXcuc3Vic3RyaW5nKDAsIHJhdy5sZW5ndGggLSBvbGRUb2tlbi5yYXcubGVuZ3RoKSArIG5ld1Rva2VuLnJhdztcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHRleHQubGVuZ3RoIC0gb2xkVG9rZW4udGV4dC5sZW5ndGgpICsgbmV3VG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxhc3RUb2tlbj8udHlwZSA9PT0gJ2xpc3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluY2x1ZGUgY29udGludWF0aW9uIGluIG5lc3RlZCBsaXN0XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZFRva2VuID0gbGFzdFRva2VuO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdUZXh0ID0gb2xkVG9rZW4ucmF3ICsgJ1xcbicgKyBsaW5lcy5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3VG9rZW4gPSB0aGlzLmxpc3QobmV3VGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0gPSBuZXdUb2tlbjtcbiAgICAgICAgICAgICAgICAgICAgcmF3ID0gcmF3LnN1YnN0cmluZygwLCByYXcubGVuZ3RoIC0gbGFzdFRva2VuLnJhdy5sZW5ndGgpICsgbmV3VG9rZW4ucmF3O1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgdGV4dC5sZW5ndGggLSBvbGRUb2tlbi5yYXcubGVuZ3RoKSArIG5ld1Rva2VuLnJhdztcbiAgICAgICAgICAgICAgICAgICAgbGluZXMgPSBuZXdUZXh0LnN1YnN0cmluZyh0b2tlbnMuYXQoLTEpLnJhdy5sZW5ndGgpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYmxvY2txdW90ZScsXG4gICAgICAgICAgICAgICAgcmF3LFxuICAgICAgICAgICAgICAgIHRva2VucyxcbiAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsaXN0KHNyYykge1xuICAgICAgICBsZXQgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5saXN0LmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgbGV0IGJ1bGwgPSBjYXBbMV0udHJpbSgpO1xuICAgICAgICAgICAgY29uc3QgaXNvcmRlcmVkID0gYnVsbC5sZW5ndGggPiAxO1xuICAgICAgICAgICAgY29uc3QgbGlzdCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGlzdCcsXG4gICAgICAgICAgICAgICAgcmF3OiAnJyxcbiAgICAgICAgICAgICAgICBvcmRlcmVkOiBpc29yZGVyZWQsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IGlzb3JkZXJlZCA/ICtidWxsLnNsaWNlKDAsIC0xKSA6ICcnLFxuICAgICAgICAgICAgICAgIGxvb3NlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpdGVtczogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnVsbCA9IGlzb3JkZXJlZCA/IGBcXFxcZHsxLDl9XFxcXCR7YnVsbC5zbGljZSgtMSl9YCA6IGBcXFxcJHtidWxsfWA7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgICAgICAgICAgYnVsbCA9IGlzb3JkZXJlZCA/IGJ1bGwgOiAnWyorLV0nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IG5leHQgbGlzdCBpdGVtXG4gICAgICAgICAgICBjb25zdCBpdGVtUmVnZXggPSB0aGlzLnJ1bGVzLm90aGVyLmxpc3RJdGVtUmVnZXgoYnVsbCk7XG4gICAgICAgICAgICBsZXQgZW5kc1dpdGhCbGFua0xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGN1cnJlbnQgYnVsbGV0IHBvaW50IGNhbiBzdGFydCBhIG5ldyBMaXN0IEl0ZW1cbiAgICAgICAgICAgIHdoaWxlIChzcmMpIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kRWFybHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBsZXQgcmF3ID0gJyc7XG4gICAgICAgICAgICAgICAgbGV0IGl0ZW1Db250ZW50cyA9ICcnO1xuICAgICAgICAgICAgICAgIGlmICghKGNhcCA9IGl0ZW1SZWdleC5leGVjKHNyYykpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ydWxlcy5ibG9jay5oci50ZXN0KHNyYykpIHsgLy8gRW5kIGxpc3QgaWYgYnVsbGV0IHdhcyBhY3R1YWxseSBIUiAocG9zc2libHkgbW92ZSBpbnRvIGl0ZW1SZWdleD8pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByYXcgPSBjYXBbMF07XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhyYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBsZXQgbGluZSA9IGNhcFsyXS5zcGxpdCgnXFxuJywgMSlbMF0ucmVwbGFjZSh0aGlzLnJ1bGVzLm90aGVyLmxpc3RSZXBsYWNlVGFicywgKHQpID0+ICcgJy5yZXBlYXQoMyAqIHQubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgbGV0IG5leHRMaW5lID0gc3JjLnNwbGl0KCdcXG4nLCAxKVswXTtcbiAgICAgICAgICAgICAgICBsZXQgYmxhbmtMaW5lID0gIWxpbmUudHJpbSgpO1xuICAgICAgICAgICAgICAgIGxldCBpbmRlbnQgPSAwO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgaXRlbUNvbnRlbnRzID0gbGluZS50cmltU3RhcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYmxhbmtMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGVudCA9IGNhcFsxXS5sZW5ndGggKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ID0gY2FwWzJdLnNlYXJjaCh0aGlzLnJ1bGVzLm90aGVyLm5vblNwYWNlQ2hhcik7IC8vIEZpbmQgZmlyc3Qgbm9uLXNwYWNlIGNoYXJcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ID0gaW5kZW50ID4gNCA/IDEgOiBpbmRlbnQ7IC8vIFRyZWF0IGluZGVudGVkIGNvZGUgYmxvY2tzICg+IDQgc3BhY2VzKSBhcyBoYXZpbmcgb25seSAxIGluZGVudFxuICAgICAgICAgICAgICAgICAgICBpdGVtQ29udGVudHMgPSBsaW5lLnNsaWNlKGluZGVudCk7XG4gICAgICAgICAgICAgICAgICAgIGluZGVudCArPSBjYXBbMV0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYmxhbmtMaW5lICYmIHRoaXMucnVsZXMub3RoZXIuYmxhbmtMaW5lLnRlc3QobmV4dExpbmUpKSB7IC8vIEl0ZW1zIGJlZ2luIHdpdGggYXQgbW9zdCBvbmUgYmxhbmsgbGluZVxuICAgICAgICAgICAgICAgICAgICByYXcgKz0gbmV4dExpbmUgKyAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhuZXh0TGluZS5sZW5ndGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgZW5kRWFybHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWVuZEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRCdWxsZXRSZWdleCA9IHRoaXMucnVsZXMub3RoZXIubmV4dEJ1bGxldFJlZ2V4KGluZGVudCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhyUmVnZXggPSB0aGlzLnJ1bGVzLm90aGVyLmhyUmVnZXgoaW5kZW50KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmVuY2VzQmVnaW5SZWdleCA9IHRoaXMucnVsZXMub3RoZXIuZmVuY2VzQmVnaW5SZWdleChpbmRlbnQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoZWFkaW5nQmVnaW5SZWdleCA9IHRoaXMucnVsZXMub3RoZXIuaGVhZGluZ0JlZ2luUmVnZXgoaW5kZW50KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaHRtbEJlZ2luUmVnZXggPSB0aGlzLnJ1bGVzLm90aGVyLmh0bWxCZWdpblJlZ2V4KGluZGVudCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGZvbGxvd2luZyBsaW5lcyBzaG91bGQgYmUgaW5jbHVkZWQgaW4gTGlzdCBJdGVtXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzcmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhd0xpbmUgPSBzcmMuc3BsaXQoJ1xcbicsIDEpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5leHRMaW5lV2l0aG91dFRhYnM7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0TGluZSA9IHJhd0xpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZS1hbGlnbiB0byBmb2xsb3cgY29tbW9ubWFyayBuZXN0aW5nIHJ1bGVzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dExpbmUgPSBuZXh0TGluZS5yZXBsYWNlKHRoaXMucnVsZXMub3RoZXIubGlzdFJlcGxhY2VOZXN0aW5nLCAnICAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0TGluZVdpdGhvdXRUYWJzID0gbmV4dExpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0TGluZVdpdGhvdXRUYWJzID0gbmV4dExpbmUucmVwbGFjZSh0aGlzLnJ1bGVzLm90aGVyLnRhYkNoYXJHbG9iYWwsICcgICAgJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbmQgbGlzdCBpdGVtIGlmIGZvdW5kIGNvZGUgZmVuY2VzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmVuY2VzQmVnaW5SZWdleC50ZXN0KG5leHRMaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5kIGxpc3QgaXRlbSBpZiBmb3VuZCBzdGFydCBvZiBuZXcgaGVhZGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWRpbmdCZWdpblJlZ2V4LnRlc3QobmV4dExpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbmQgbGlzdCBpdGVtIGlmIGZvdW5kIHN0YXJ0IG9mIGh0bWwgYmxvY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChodG1sQmVnaW5SZWdleC50ZXN0KG5leHRMaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5kIGxpc3QgaXRlbSBpZiBmb3VuZCBzdGFydCBvZiBuZXcgYnVsbGV0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dEJ1bGxldFJlZ2V4LnRlc3QobmV4dExpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIb3Jpem9udGFsIHJ1bGUgZm91bmRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoclJlZ2V4LnRlc3QobmV4dExpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dExpbmVXaXRob3V0VGFicy5zZWFyY2godGhpcy5ydWxlcy5vdGhlci5ub25TcGFjZUNoYXIpID49IGluZGVudCB8fCAhbmV4dExpbmUudHJpbSgpKSB7IC8vIERlZGVudCBpZiBwb3NzaWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1Db250ZW50cyArPSAnXFxuJyArIG5leHRMaW5lV2l0aG91dFRhYnMuc2xpY2UoaW5kZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdCBlbm91Z2ggaW5kZW50YXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmxhbmtMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwYXJhZ3JhcGggY29udGludWF0aW9uIHVubGVzcyBsYXN0IGxpbmUgd2FzIGEgZGlmZmVyZW50IGJsb2NrIGxldmVsIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZS5yZXBsYWNlKHRoaXMucnVsZXMub3RoZXIudGFiQ2hhckdsb2JhbCwgJyAgICAnKS5zZWFyY2godGhpcy5ydWxlcy5vdGhlci5ub25TcGFjZUNoYXIpID49IDQpIHsgLy8gaW5kZW50ZWQgY29kZSBibG9ja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZlbmNlc0JlZ2luUmVnZXgudGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWRpbmdCZWdpblJlZ2V4LnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoclJlZ2V4LnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1Db250ZW50cyArPSAnXFxuJyArIG5leHRMaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFibGFua0xpbmUgJiYgIW5leHRMaW5lLnRyaW0oKSkgeyAvLyBDaGVjayBpZiBjdXJyZW50IGxpbmUgaXMgYmxhbmtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibGFua0xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3ICs9IHJhd0xpbmUgKyAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcocmF3TGluZS5sZW5ndGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgPSBuZXh0TGluZVdpdGhvdXRUYWJzLnNsaWNlKGluZGVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFsaXN0Lmxvb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBwcmV2aW91cyBpdGVtIGVuZGVkIHdpdGggYSBibGFuayBsaW5lLCB0aGUgbGlzdCBpcyBsb29zZVxuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kc1dpdGhCbGFua0xpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QubG9vc2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucnVsZXMub3RoZXIuZG91YmxlQmxhbmtMaW5lLnRlc3QocmF3KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kc1dpdGhCbGFua0xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBpc3Rhc2sgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBpc2NoZWNrZWQ7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHRhc2sgbGlzdCBpdGVtc1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZ2ZtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzdGFzayA9IHRoaXMucnVsZXMub3RoZXIubGlzdElzVGFzay5leGVjKGl0ZW1Db250ZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc3Rhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzY2hlY2tlZCA9IGlzdGFza1swXSAhPT0gJ1sgXSAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUNvbnRlbnRzID0gaXRlbUNvbnRlbnRzLnJlcGxhY2UodGhpcy5ydWxlcy5vdGhlci5saXN0UmVwbGFjZVRhc2ssICcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaXN0Lml0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGlzdF9pdGVtJyxcbiAgICAgICAgICAgICAgICAgICAgcmF3LFxuICAgICAgICAgICAgICAgICAgICB0YXNrOiAhIWlzdGFzayxcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tlZDogaXNjaGVja2VkLFxuICAgICAgICAgICAgICAgICAgICBsb29zZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGl0ZW1Db250ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zOiBbXSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsaXN0LnJhdyArPSByYXc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEbyBub3QgY29uc3VtZSBuZXdsaW5lcyBhdCBlbmQgb2YgZmluYWwgaXRlbS4gQWx0ZXJuYXRpdmVseSwgbWFrZSBpdGVtUmVnZXggKnN0YXJ0KiB3aXRoIGFueSBuZXdsaW5lcyB0byBzaW1wbGlmeS9zcGVlZCB1cCBlbmRzV2l0aEJsYW5rTGluZSBsb2dpY1xuICAgICAgICAgICAgY29uc3QgbGFzdEl0ZW0gPSBsaXN0Lml0ZW1zLmF0KC0xKTtcbiAgICAgICAgICAgIGlmIChsYXN0SXRlbSkge1xuICAgICAgICAgICAgICAgIGxhc3RJdGVtLnJhdyA9IGxhc3RJdGVtLnJhdy50cmltRW5kKCk7XG4gICAgICAgICAgICAgICAgbGFzdEl0ZW0udGV4dCA9IGxhc3RJdGVtLnRleHQudHJpbUVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbm90IGEgbGlzdCBzaW5jZSB0aGVyZSB3ZXJlIG5vIGl0ZW1zXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdC5yYXcgPSBsaXN0LnJhdy50cmltRW5kKCk7XG4gICAgICAgICAgICAvLyBJdGVtIGNoaWxkIHRva2VucyBoYW5kbGVkIGhlcmUgYXQgZW5kIGJlY2F1c2Ugd2UgbmVlZGVkIHRvIGhhdmUgdGhlIGZpbmFsIGl0ZW0gdG8gdHJpbSBpdCBmaXJzdFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lml0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS50b3AgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBsaXN0Lml0ZW1zW2ldLnRva2VucyA9IHRoaXMubGV4ZXIuYmxvY2tUb2tlbnMobGlzdC5pdGVtc1tpXS50ZXh0LCBbXSk7XG4gICAgICAgICAgICAgICAgaWYgKCFsaXN0Lmxvb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGxpc3Qgc2hvdWxkIGJlIGxvb3NlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNwYWNlcnMgPSBsaXN0Lml0ZW1zW2ldLnRva2Vucy5maWx0ZXIodCA9PiB0LnR5cGUgPT09ICdzcGFjZScpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNNdWx0aXBsZUxpbmVCcmVha3MgPSBzcGFjZXJzLmxlbmd0aCA+IDAgJiYgc3BhY2Vycy5zb21lKHQgPT4gdGhpcy5ydWxlcy5vdGhlci5hbnlMaW5lLnRlc3QodC5yYXcpKTtcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5sb29zZSA9IGhhc011bHRpcGxlTGluZUJyZWFrcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXQgYWxsIGl0ZW1zIHRvIGxvb3NlIGlmIGxpc3QgaXMgbG9vc2VcbiAgICAgICAgICAgIGlmIChsaXN0Lmxvb3NlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lml0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3QuaXRlbXNbaV0ubG9vc2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsaXN0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGh0bWwoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2suaHRtbC5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdodG1sJyxcbiAgICAgICAgICAgICAgICBibG9jazogdHJ1ZSxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICBwcmU6IGNhcFsxXSA9PT0gJ3ByZScgfHwgY2FwWzFdID09PSAnc2NyaXB0JyB8fCBjYXBbMV0gPT09ICdzdHlsZScsXG4gICAgICAgICAgICAgICAgdGV4dDogY2FwWzBdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWYoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2suZGVmLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gY2FwWzFdLnRvTG93ZXJDYXNlKCkucmVwbGFjZSh0aGlzLnJ1bGVzLm90aGVyLm11bHRpcGxlU3BhY2VHbG9iYWwsICcgJyk7XG4gICAgICAgICAgICBjb25zdCBocmVmID0gY2FwWzJdID8gY2FwWzJdLnJlcGxhY2UodGhpcy5ydWxlcy5vdGhlci5ocmVmQnJhY2tldHMsICckMScpLnJlcGxhY2UodGhpcy5ydWxlcy5pbmxpbmUuYW55UHVuY3R1YXRpb24sICckMScpIDogJyc7XG4gICAgICAgICAgICBjb25zdCB0aXRsZSA9IGNhcFszXSA/IGNhcFszXS5zdWJzdHJpbmcoMSwgY2FwWzNdLmxlbmd0aCAtIDEpLnJlcGxhY2UodGhpcy5ydWxlcy5pbmxpbmUuYW55UHVuY3R1YXRpb24sICckMScpIDogY2FwWzNdO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZGVmJyxcbiAgICAgICAgICAgICAgICB0YWcsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgaHJlZixcbiAgICAgICAgICAgICAgICB0aXRsZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGFibGUoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2sudGFibGUuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoIWNhcCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5ydWxlcy5vdGhlci50YWJsZURlbGltaXRlci50ZXN0KGNhcFsyXSkpIHtcbiAgICAgICAgICAgIC8vIGRlbGltaXRlciByb3cgbXVzdCBoYXZlIGEgcGlwZSAofCkgb3IgY29sb24gKDopIG90aGVyd2lzZSBpdCBpcyBhIHNldGV4dCBoZWFkaW5nXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHNwbGl0Q2VsbHMoY2FwWzFdKTtcbiAgICAgICAgY29uc3QgYWxpZ25zID0gY2FwWzJdLnJlcGxhY2UodGhpcy5ydWxlcy5vdGhlci50YWJsZUFsaWduQ2hhcnMsICcnKS5zcGxpdCgnfCcpO1xuICAgICAgICBjb25zdCByb3dzID0gY2FwWzNdPy50cmltKCkgPyBjYXBbM10ucmVwbGFjZSh0aGlzLnJ1bGVzLm90aGVyLnRhYmxlUm93QmxhbmtMaW5lLCAnJykuc3BsaXQoJ1xcbicpIDogW107XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB7XG4gICAgICAgICAgICB0eXBlOiAndGFibGUnLFxuICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICBoZWFkZXI6IFtdLFxuICAgICAgICAgICAgYWxpZ246IFtdLFxuICAgICAgICAgICAgcm93czogW10sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChoZWFkZXJzLmxlbmd0aCAhPT0gYWxpZ25zLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gaGVhZGVyIGFuZCBhbGlnbiBjb2x1bW5zIG11c3QgYmUgZXF1YWwsIHJvd3MgY2FuIGJlIGRpZmZlcmVudC5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGFsaWduIG9mIGFsaWducykge1xuICAgICAgICAgICAgaWYgKHRoaXMucnVsZXMub3RoZXIudGFibGVBbGlnblJpZ2h0LnRlc3QoYWxpZ24pKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5hbGlnbi5wdXNoKCdyaWdodCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5ydWxlcy5vdGhlci50YWJsZUFsaWduQ2VudGVyLnRlc3QoYWxpZ24pKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5hbGlnbi5wdXNoKCdjZW50ZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucnVsZXMub3RoZXIudGFibGVBbGlnbkxlZnQudGVzdChhbGlnbikpIHtcbiAgICAgICAgICAgICAgICBpdGVtLmFsaWduLnB1c2goJ2xlZnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZW0uYWxpZ24ucHVzaChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0uaGVhZGVyLnB1c2goe1xuICAgICAgICAgICAgICAgIHRleHQ6IGhlYWRlcnNbaV0sXG4gICAgICAgICAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZShoZWFkZXJzW2ldKSxcbiAgICAgICAgICAgICAgICBoZWFkZXI6IHRydWUsXG4gICAgICAgICAgICAgICAgYWxpZ246IGl0ZW0uYWxpZ25baV0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiByb3dzKSB7XG4gICAgICAgICAgICBpdGVtLnJvd3MucHVzaChzcGxpdENlbGxzKHJvdywgaXRlbS5oZWFkZXIubGVuZ3RoKS5tYXAoKGNlbGwsIGkpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjZWxsLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lKGNlbGwpLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBhbGlnbjogaXRlbS5hbGlnbltpXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cbiAgICBsaGVhZGluZyhzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5saGVhZGluZy5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2hlYWRpbmcnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIGRlcHRoOiBjYXBbMl0uY2hhckF0KDApID09PSAnPScgPyAxIDogMixcbiAgICAgICAgICAgICAgICB0ZXh0OiBjYXBbMV0sXG4gICAgICAgICAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZShjYXBbMV0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJhZ3JhcGgoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2sucGFyYWdyYXBoLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IGNhcFsxXS5jaGFyQXQoY2FwWzFdLmxlbmd0aCAtIDEpID09PSAnXFxuJ1xuICAgICAgICAgICAgICAgID8gY2FwWzFdLnNsaWNlKDAsIC0xKVxuICAgICAgICAgICAgICAgIDogY2FwWzFdO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAncGFyYWdyYXBoJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmUodGV4dCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHRleHQoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2sudGV4dC5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHRleHQ6IGNhcFswXSxcbiAgICAgICAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lKGNhcFswXSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVzY2FwZShzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuZXNjYXBlLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZXNjYXBlJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBjYXBbMV0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHRhZyhzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUudGFnLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmxleGVyLnN0YXRlLmluTGluayAmJiB0aGlzLnJ1bGVzLm90aGVyLnN0YXJ0QVRhZy50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxleGVyLnN0YXRlLmluTGluayA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmxleGVyLnN0YXRlLmluTGluayAmJiB0aGlzLnJ1bGVzLm90aGVyLmVuZEFUYWcudGVzdChjYXBbMF0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS5pbkxpbmsgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrICYmIHRoaXMucnVsZXMub3RoZXIuc3RhcnRQcmVTY3JpcHRUYWcudGVzdChjYXBbMF0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayAmJiB0aGlzLnJ1bGVzLm90aGVyLmVuZFByZVNjcmlwdFRhZy50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxleGVyLnN0YXRlLmluUmF3QmxvY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2h0bWwnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIGluTGluazogdGhpcy5sZXhlci5zdGF0ZS5pbkxpbmssXG4gICAgICAgICAgICAgICAgaW5SYXdCbG9jazogdGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrLFxuICAgICAgICAgICAgICAgIGJsb2NrOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBjYXBbMF0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGxpbmsoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmxpbmsuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICBjb25zdCB0cmltbWVkVXJsID0gY2FwWzJdLnRyaW0oKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLnBlZGFudGljICYmIHRoaXMucnVsZXMub3RoZXIuc3RhcnRBbmdsZUJyYWNrZXQudGVzdCh0cmltbWVkVXJsKSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbW1vbm1hcmsgcmVxdWlyZXMgbWF0Y2hpbmcgYW5nbGUgYnJhY2tldHNcbiAgICAgICAgICAgICAgICBpZiAoISh0aGlzLnJ1bGVzLm90aGVyLmVuZEFuZ2xlQnJhY2tldC50ZXN0KHRyaW1tZWRVcmwpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVuZGluZyBhbmdsZSBicmFja2V0IGNhbm5vdCBiZSBlc2NhcGVkXG4gICAgICAgICAgICAgICAgY29uc3QgcnRyaW1TbGFzaCA9IHJ0cmltKHRyaW1tZWRVcmwuc2xpY2UoMCwgLTEpLCAnXFxcXCcpO1xuICAgICAgICAgICAgICAgIGlmICgodHJpbW1lZFVybC5sZW5ndGggLSBydHJpbVNsYXNoLmxlbmd0aCkgJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBmaW5kIGNsb3NpbmcgcGFyZW50aGVzaXNcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0UGFyZW5JbmRleCA9IGZpbmRDbG9zaW5nQnJhY2tldChjYXBbMl0sICcoKScpO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0UGFyZW5JbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gY2FwWzBdLmluZGV4T2YoJyEnKSA9PT0gMCA/IDUgOiA0O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5rTGVuID0gc3RhcnQgKyBjYXBbMV0ubGVuZ3RoICsgbGFzdFBhcmVuSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGNhcFsyXSA9IGNhcFsyXS5zdWJzdHJpbmcoMCwgbGFzdFBhcmVuSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBjYXBbMF0gPSBjYXBbMF0uc3Vic3RyaW5nKDAsIGxpbmtMZW4pLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgY2FwWzNdID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGhyZWYgPSBjYXBbMl07XG4gICAgICAgICAgICBsZXQgdGl0bGUgPSAnJztcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgICAgICAvLyBzcGxpdCBwZWRhbnRpYyBocmVmIGFuZCB0aXRsZVxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmsgPSB0aGlzLnJ1bGVzLm90aGVyLnBlZGFudGljSHJlZlRpdGxlLmV4ZWMoaHJlZik7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgaHJlZiA9IGxpbmtbMV07XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlID0gbGlua1szXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aXRsZSA9IGNhcFszXSA/IGNhcFszXS5zbGljZSgxLCAtMSkgOiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhyZWYgPSBocmVmLnRyaW0oKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJ1bGVzLm90aGVyLnN0YXJ0QW5nbGVCcmFja2V0LnRlc3QoaHJlZikpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljICYmICEodGhpcy5ydWxlcy5vdGhlci5lbmRBbmdsZUJyYWNrZXQudGVzdCh0cmltbWVkVXJsKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcGVkYW50aWMgYWxsb3dzIHN0YXJ0aW5nIGFuZ2xlIGJyYWNrZXQgd2l0aG91dCBlbmRpbmcgYW5nbGUgYnJhY2tldFxuICAgICAgICAgICAgICAgICAgICBocmVmID0gaHJlZi5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhyZWYgPSBocmVmLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0TGluayhjYXAsIHtcbiAgICAgICAgICAgICAgICBocmVmOiBocmVmID8gaHJlZi5yZXBsYWNlKHRoaXMucnVsZXMuaW5saW5lLmFueVB1bmN0dWF0aW9uLCAnJDEnKSA6IGhyZWYsXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlID8gdGl0bGUucmVwbGFjZSh0aGlzLnJ1bGVzLmlubGluZS5hbnlQdW5jdHVhdGlvbiwgJyQxJykgOiB0aXRsZSxcbiAgICAgICAgICAgIH0sIGNhcFswXSwgdGhpcy5sZXhlciwgdGhpcy5ydWxlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVmbGluayhzcmMsIGxpbmtzKSB7XG4gICAgICAgIGxldCBjYXA7XG4gICAgICAgIGlmICgoY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUucmVmbGluay5leGVjKHNyYykpXG4gICAgICAgICAgICB8fCAoY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUubm9saW5rLmV4ZWMoc3JjKSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmtTdHJpbmcgPSAoY2FwWzJdIHx8IGNhcFsxXSkucmVwbGFjZSh0aGlzLnJ1bGVzLm90aGVyLm11bHRpcGxlU3BhY2VHbG9iYWwsICcgJyk7XG4gICAgICAgICAgICBjb25zdCBsaW5rID0gbGlua3NbbGlua1N0cmluZy50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgICAgIGlmICghbGluaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSBjYXBbMF0uY2hhckF0KDApO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgcmF3OiB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0TGluayhjYXAsIGxpbmssIGNhcFswXSwgdGhpcy5sZXhlciwgdGhpcy5ydWxlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW1TdHJvbmcoc3JjLCBtYXNrZWRTcmMsIHByZXZDaGFyID0gJycpIHtcbiAgICAgICAgbGV0IG1hdGNoID0gdGhpcy5ydWxlcy5pbmxpbmUuZW1TdHJvbmdMRGVsaW0uZXhlYyhzcmMpO1xuICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBfIGNhbid0IGJlIGJldHdlZW4gdHdvIGFscGhhbnVtZXJpY3MuIFxccHtMfVxccHtOfSBpbmNsdWRlcyBub24tZW5nbGlzaCBhbHBoYWJldC9udW1iZXJzIGFzIHdlbGxcbiAgICAgICAgaWYgKG1hdGNoWzNdICYmIHByZXZDaGFyLm1hdGNoKHRoaXMucnVsZXMub3RoZXIudW5pY29kZUFscGhhTnVtZXJpYykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IG5leHRDaGFyID0gbWF0Y2hbMV0gfHwgbWF0Y2hbMl0gfHwgJyc7XG4gICAgICAgIGlmICghbmV4dENoYXIgfHwgIXByZXZDaGFyIHx8IHRoaXMucnVsZXMuaW5saW5lLnB1bmN0dWF0aW9uLmV4ZWMocHJldkNoYXIpKSB7XG4gICAgICAgICAgICAvLyB1bmljb2RlIFJlZ2V4IGNvdW50cyBlbW9qaSBhcyAxIGNoYXI7IHNwcmVhZCBpbnRvIGFycmF5IGZvciBwcm9wZXIgY291bnQgKHVzZWQgbXVsdGlwbGUgdGltZXMgYmVsb3cpXG4gICAgICAgICAgICBjb25zdCBsTGVuZ3RoID0gWy4uLm1hdGNoWzBdXS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgbGV0IHJEZWxpbSwgckxlbmd0aCwgZGVsaW1Ub3RhbCA9IGxMZW5ndGgsIG1pZERlbGltVG90YWwgPSAwO1xuICAgICAgICAgICAgY29uc3QgZW5kUmVnID0gbWF0Y2hbMF1bMF0gPT09ICcqJyA/IHRoaXMucnVsZXMuaW5saW5lLmVtU3Ryb25nUkRlbGltQXN0IDogdGhpcy5ydWxlcy5pbmxpbmUuZW1TdHJvbmdSRGVsaW1VbmQ7XG4gICAgICAgICAgICBlbmRSZWcubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgIC8vIENsaXAgbWFza2VkU3JjIHRvIHNhbWUgc2VjdGlvbiBvZiBzdHJpbmcgYXMgc3JjIChtb3ZlIHRvIGxleGVyPylcbiAgICAgICAgICAgIG1hc2tlZFNyYyA9IG1hc2tlZFNyYy5zbGljZSgtMSAqIHNyYy5sZW5ndGggKyBsTGVuZ3RoKTtcbiAgICAgICAgICAgIHdoaWxlICgobWF0Y2ggPSBlbmRSZWcuZXhlYyhtYXNrZWRTcmMpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgckRlbGltID0gbWF0Y2hbMV0gfHwgbWF0Y2hbMl0gfHwgbWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgbWF0Y2hbNl07XG4gICAgICAgICAgICAgICAgaWYgKCFyRGVsaW0pXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBza2lwIHNpbmdsZSAqIGluIF9fYWJjKmFiY19fXG4gICAgICAgICAgICAgICAgckxlbmd0aCA9IFsuLi5yRGVsaW1dLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hbM10gfHwgbWF0Y2hbNF0pIHsgLy8gZm91bmQgYW5vdGhlciBMZWZ0IERlbGltXG4gICAgICAgICAgICAgICAgICAgIGRlbGltVG90YWwgKz0gckxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoWzVdIHx8IG1hdGNoWzZdKSB7IC8vIGVpdGhlciBMZWZ0IG9yIFJpZ2h0IERlbGltXG4gICAgICAgICAgICAgICAgICAgIGlmIChsTGVuZ3RoICUgMyAmJiAhKChsTGVuZ3RoICsgckxlbmd0aCkgJSAzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWlkRGVsaW1Ub3RhbCArPSByTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIENvbW1vbk1hcmsgRW1waGFzaXMgUnVsZXMgOS0xMFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGltVG90YWwgLT0gckxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoZGVsaW1Ub3RhbCA+IDApXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBIYXZlbid0IGZvdW5kIGVub3VnaCBjbG9zaW5nIGRlbGltaXRlcnNcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZXh0cmEgY2hhcmFjdGVycy4gKmEqKiogLT4gKmEqXG4gICAgICAgICAgICAgICAgckxlbmd0aCA9IE1hdGgubWluKHJMZW5ndGgsIHJMZW5ndGggKyBkZWxpbVRvdGFsICsgbWlkRGVsaW1Ub3RhbCk7XG4gICAgICAgICAgICAgICAgLy8gY2hhciBsZW5ndGggY2FuIGJlID4xIGZvciB1bmljb2RlIGNoYXJhY3RlcnM7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdENoYXJMZW5ndGggPSBbLi4ubWF0Y2hbMF1dWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCByYXcgPSBzcmMuc2xpY2UoMCwgbExlbmd0aCArIG1hdGNoLmluZGV4ICsgbGFzdENoYXJMZW5ndGggKyByTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYGVtYCBpZiBzbWFsbGVzdCBkZWxpbWl0ZXIgaGFzIG9kZCBjaGFyIGNvdW50LiAqYSoqKlxuICAgICAgICAgICAgICAgIGlmIChNYXRoLm1pbihsTGVuZ3RoLCByTGVuZ3RoKSAlIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IHJhdy5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmVUb2tlbnModGV4dCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSAnc3Ryb25nJyBpZiBzbWFsbGVzdCBkZWxpbWl0ZXIgaGFzIGV2ZW4gY2hhciBjb3VudC4gKiphKioqXG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IHJhdy5zbGljZSgyLCAtMik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3N0cm9uZycsXG4gICAgICAgICAgICAgICAgICAgIHJhdyxcbiAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZVRva2Vucyh0ZXh0KSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvZGVzcGFuKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5jb2RlLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgbGV0IHRleHQgPSBjYXBbMl0ucmVwbGFjZSh0aGlzLnJ1bGVzLm90aGVyLm5ld0xpbmVDaGFyR2xvYmFsLCAnICcpO1xuICAgICAgICAgICAgY29uc3QgaGFzTm9uU3BhY2VDaGFycyA9IHRoaXMucnVsZXMub3RoZXIubm9uU3BhY2VDaGFyLnRlc3QodGV4dCk7XG4gICAgICAgICAgICBjb25zdCBoYXNTcGFjZUNoYXJzT25Cb3RoRW5kcyA9IHRoaXMucnVsZXMub3RoZXIuc3RhcnRpbmdTcGFjZUNoYXIudGVzdCh0ZXh0KSAmJiB0aGlzLnJ1bGVzLm90aGVyLmVuZGluZ1NwYWNlQ2hhci50ZXN0KHRleHQpO1xuICAgICAgICAgICAgaWYgKGhhc05vblNwYWNlQ2hhcnMgJiYgaGFzU3BhY2VDaGFyc09uQm90aEVuZHMpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMSwgdGV4dC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvZGVzcGFuJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBicihzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuYnIuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdicicsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlbChzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuZGVsLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZGVsJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBjYXBbMl0sXG4gICAgICAgICAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZVRva2VucyhjYXBbMl0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhdXRvbGluayhzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuYXV0b2xpbmsuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICBsZXQgdGV4dCwgaHJlZjtcbiAgICAgICAgICAgIGlmIChjYXBbMl0gPT09ICdAJykge1xuICAgICAgICAgICAgICAgIHRleHQgPSBjYXBbMV07XG4gICAgICAgICAgICAgICAgaHJlZiA9ICdtYWlsdG86JyArIHRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gY2FwWzFdO1xuICAgICAgICAgICAgICAgIGhyZWYgPSB0ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGluaycsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICBocmVmLFxuICAgICAgICAgICAgICAgIHRva2VuczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICByYXc6IHRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHVybChzcmMpIHtcbiAgICAgICAgbGV0IGNhcDtcbiAgICAgICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLnVybC5leGVjKHNyYykpIHtcbiAgICAgICAgICAgIGxldCB0ZXh0LCBocmVmO1xuICAgICAgICAgICAgaWYgKGNhcFsyXSA9PT0gJ0AnKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGNhcFswXTtcbiAgICAgICAgICAgICAgICBocmVmID0gJ21haWx0bzonICsgdGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRvIGV4dGVuZGVkIGF1dG9saW5rIHBhdGggdmFsaWRhdGlvblxuICAgICAgICAgICAgICAgIGxldCBwcmV2Q2FwWmVybztcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZDYXBaZXJvID0gY2FwWzBdO1xuICAgICAgICAgICAgICAgICAgICBjYXBbMF0gPSB0aGlzLnJ1bGVzLmlubGluZS5fYmFja3BlZGFsLmV4ZWMoY2FwWzBdKT8uWzBdID8/ICcnO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHByZXZDYXBaZXJvICE9PSBjYXBbMF0pO1xuICAgICAgICAgICAgICAgIHRleHQgPSBjYXBbMF07XG4gICAgICAgICAgICAgICAgaWYgKGNhcFsxXSA9PT0gJ3d3dy4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGhyZWYgPSAnaHR0cDovLycgKyBjYXBbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBocmVmID0gY2FwWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2xpbmsnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgaHJlZixcbiAgICAgICAgICAgICAgICB0b2tlbnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3OiB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbmxpbmVUZXh0KHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS50ZXh0LmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgY29uc3QgZXNjYXBlZCA9IHRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jaztcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHRleHQ6IGNhcFswXSxcbiAgICAgICAgICAgICAgICBlc2NhcGVkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBCbG9jayBMZXhlclxuICovXG5jbGFzcyBfTGV4ZXIge1xuICAgIHRva2VucztcbiAgICBvcHRpb25zO1xuICAgIHN0YXRlO1xuICAgIHRva2VuaXplcjtcbiAgICBpbmxpbmVRdWV1ZTtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIC8vIFRva2VuTGlzdCBjYW5ub3QgYmUgY3JlYXRlZCBpbiBvbmUgZ29cbiAgICAgICAgdGhpcy50b2tlbnMgPSBbXTtcbiAgICAgICAgdGhpcy50b2tlbnMubGlua3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IF9kZWZhdWx0cztcbiAgICAgICAgdGhpcy5vcHRpb25zLnRva2VuaXplciA9IHRoaXMub3B0aW9ucy50b2tlbml6ZXIgfHwgbmV3IF9Ub2tlbml6ZXIoKTtcbiAgICAgICAgdGhpcy50b2tlbml6ZXIgPSB0aGlzLm9wdGlvbnMudG9rZW5pemVyO1xuICAgICAgICB0aGlzLnRva2VuaXplci5vcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB0aGlzLnRva2VuaXplci5sZXhlciA9IHRoaXM7XG4gICAgICAgIHRoaXMuaW5saW5lUXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGluTGluazogZmFsc2UsXG4gICAgICAgICAgICBpblJhd0Jsb2NrOiBmYWxzZSxcbiAgICAgICAgICAgIHRvcDogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcnVsZXMgPSB7XG4gICAgICAgICAgICBvdGhlcixcbiAgICAgICAgICAgIGJsb2NrOiBibG9jay5ub3JtYWwsXG4gICAgICAgICAgICBpbmxpbmU6IGlubGluZS5ub3JtYWwsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgIHJ1bGVzLmJsb2NrID0gYmxvY2sucGVkYW50aWM7XG4gICAgICAgICAgICBydWxlcy5pbmxpbmUgPSBpbmxpbmUucGVkYW50aWM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25zLmdmbSkge1xuICAgICAgICAgICAgcnVsZXMuYmxvY2sgPSBibG9jay5nZm07XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJyZWFrcykge1xuICAgICAgICAgICAgICAgIHJ1bGVzLmlubGluZSA9IGlubGluZS5icmVha3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBydWxlcy5pbmxpbmUgPSBpbmxpbmUuZ2ZtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudG9rZW5pemVyLnJ1bGVzID0gcnVsZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cG9zZSBSdWxlc1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgcnVsZXMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBibG9jayxcbiAgICAgICAgICAgIGlubGluZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhdGljIExleCBNZXRob2RcbiAgICAgKi9cbiAgICBzdGF0aWMgbGV4KHNyYywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBsZXhlciA9IG5ldyBfTGV4ZXIob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBsZXhlci5sZXgoc3JjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhdGljIExleCBJbmxpbmUgTWV0aG9kXG4gICAgICovXG4gICAgc3RhdGljIGxleElubGluZShzcmMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbGV4ZXIgPSBuZXcgX0xleGVyKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gbGV4ZXIuaW5saW5lVG9rZW5zKHNyYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXByb2Nlc3NpbmdcbiAgICAgKi9cbiAgICBsZXgoc3JjKSB7XG4gICAgICAgIHNyYyA9IHNyYy5yZXBsYWNlKG90aGVyLmNhcnJpYWdlUmV0dXJuLCAnXFxuJyk7XG4gICAgICAgIHRoaXMuYmxvY2tUb2tlbnMoc3JjLCB0aGlzLnRva2Vucyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pbmxpbmVRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMuaW5saW5lUXVldWVbaV07XG4gICAgICAgICAgICB0aGlzLmlubGluZVRva2VucyhuZXh0LnNyYywgbmV4dC50b2tlbnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5saW5lUXVldWUgPSBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5zO1xuICAgIH1cbiAgICBibG9ja1Rva2VucyhzcmMsIHRva2VucyA9IFtdLCBsYXN0UGFyYWdyYXBoQ2xpcHBlZCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgIHNyYyA9IHNyYy5yZXBsYWNlKG90aGVyLnRhYkNoYXJHbG9iYWwsICcgICAgJykucmVwbGFjZShvdGhlci5zcGFjZUxpbmUsICcnKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoc3JjKSB7XG4gICAgICAgICAgICBsZXQgdG9rZW47XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnM/LmJsb2NrPy5zb21lKChleHRUb2tlbml6ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPSBleHRUb2tlbml6ZXIuY2FsbCh7IGxleGVyOiB0aGlzIH0sIHNyYywgdG9rZW5zKSkge1xuICAgICAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbmV3bGluZVxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuc3BhY2Uoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdFRva2VuID0gdG9rZW5zLmF0KC0xKTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4ucmF3Lmxlbmd0aCA9PT0gMSAmJiBsYXN0VG9rZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSdzIGEgc2luZ2xlIFxcbiBhcyBhIHNwYWNlciwgaXQncyB0ZXJtaW5hdGluZyB0aGUgbGFzdCBsaW5lLFxuICAgICAgICAgICAgICAgICAgICAvLyBzbyBtb3ZlIGl0IHRoZXJlIHNvIHRoYXQgd2UgZG9uJ3QgZ2V0IHVubmVjZXNzYXJ5IHBhcmFncmFwaCB0YWdzXG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gJ1xcbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29kZVxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuY29kZShzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0VG9rZW4gPSB0b2tlbnMuYXQoLTEpO1xuICAgICAgICAgICAgICAgIC8vIEFuIGluZGVudGVkIGNvZGUgYmxvY2sgY2Fubm90IGludGVycnVwdCBhIHBhcmFncmFwaC5cbiAgICAgICAgICAgICAgICBpZiAobGFzdFRva2VuPy50eXBlID09PSAncGFyYWdyYXBoJyB8fCBsYXN0VG9rZW4/LnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSAnXFxuJyArIHRva2VuLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5saW5lUXVldWUuYXQoLTEpLnNyYyA9IGxhc3RUb2tlbi50ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZlbmNlc1xuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZmVuY2VzKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGhlYWRpbmdcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmhlYWRpbmcoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaHJcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmhyKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGJsb2NrcXVvdGVcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmJsb2NrcXVvdGUoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbGlzdFxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIubGlzdChzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBodG1sXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5odG1sKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRlZlxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZGVmKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RUb2tlbiA9IHRva2Vucy5hdCgtMSk7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RUb2tlbj8udHlwZSA9PT0gJ3BhcmFncmFwaCcgfHwgbGFzdFRva2VuPy50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnJhdyArPSAnXFxuJyArIHRva2VuLnJhdztcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gJ1xcbicgKyB0b2tlbi5yYXc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5saW5lUXVldWUuYXQoLTEpLnNyYyA9IGxhc3RUb2tlbi50ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghdGhpcy50b2tlbnMubGlua3NbdG9rZW4udGFnXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRva2Vucy5saW5rc1t0b2tlbi50YWddID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogdG9rZW4uaHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0b2tlbi50aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0YWJsZSAoZ2ZtKVxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIudGFibGUoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbGhlYWRpbmdcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmxoZWFkaW5nKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRvcC1sZXZlbCBwYXJhZ3JhcGhcbiAgICAgICAgICAgIC8vIHByZXZlbnQgcGFyYWdyYXBoIGNvbnN1bWluZyBleHRlbnNpb25zIGJ5IGNsaXBwaW5nICdzcmMnIHRvIGV4dGVuc2lvbiBzdGFydFxuICAgICAgICAgICAgbGV0IGN1dFNyYyA9IHNyYztcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucz8uc3RhcnRCbG9jaykge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydEluZGV4ID0gSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcFNyYyA9IHNyYy5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICBsZXQgdGVtcFN0YXJ0O1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnN0YXJ0QmxvY2suZm9yRWFjaCgoZ2V0U3RhcnRJbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wU3RhcnQgPSBnZXRTdGFydEluZGV4LmNhbGwoeyBsZXhlcjogdGhpcyB9LCB0ZW1wU3JjKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZW1wU3RhcnQgPT09ICdudW1iZXInICYmIHRlbXBTdGFydCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydEluZGV4ID0gTWF0aC5taW4oc3RhcnRJbmRleCwgdGVtcFN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydEluZGV4IDwgSW5maW5pdHkgJiYgc3RhcnRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1dFNyYyA9IHNyYy5zdWJzdHJpbmcoMCwgc3RhcnRJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLnRvcCAmJiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5wYXJhZ3JhcGgoY3V0U3JjKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0VG9rZW4gPSB0b2tlbnMuYXQoLTEpO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0UGFyYWdyYXBoQ2xpcHBlZCAmJiBsYXN0VG9rZW4/LnR5cGUgPT09ICdwYXJhZ3JhcGgnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gJ1xcbicgKyB0b2tlbi5yYXc7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi50ZXh0ICs9ICdcXG4nICsgdG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZS5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZS5hdCgtMSkuc3JjID0gbGFzdFRva2VuLnRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RQYXJhZ3JhcGhDbGlwcGVkID0gY3V0U3JjLmxlbmd0aCAhPT0gc3JjLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGV4dFxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIudGV4dChzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0VG9rZW4gPSB0b2tlbnMuYXQoLTEpO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0VG9rZW4/LnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSAnXFxuJyArIHRva2VuLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5saW5lUXVldWUucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5saW5lUXVldWUuYXQoLTEpLnNyYyA9IGxhc3RUb2tlbi50ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJNc2cgPSAnSW5maW5pdGUgbG9vcCBvbiBieXRlOiAnICsgc3JjLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlLnRvcCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxuICAgIGlubGluZShzcmMsIHRva2VucyA9IFtdKSB7XG4gICAgICAgIHRoaXMuaW5saW5lUXVldWUucHVzaCh7IHNyYywgdG9rZW5zIH0pO1xuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMZXhpbmcvQ29tcGlsaW5nXG4gICAgICovXG4gICAgaW5saW5lVG9rZW5zKHNyYywgdG9rZW5zID0gW10pIHtcbiAgICAgICAgLy8gU3RyaW5nIHdpdGggbGlua3MgbWFza2VkIHRvIGF2b2lkIGludGVyZmVyZW5jZSB3aXRoIGVtIGFuZCBzdHJvbmdcbiAgICAgICAgbGV0IG1hc2tlZFNyYyA9IHNyYztcbiAgICAgICAgbGV0IG1hdGNoID0gbnVsbDtcbiAgICAgICAgLy8gTWFzayBvdXQgcmVmbGlua3NcbiAgICAgICAgaWYgKHRoaXMudG9rZW5zLmxpbmtzKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5rcyA9IE9iamVjdC5rZXlzKHRoaXMudG9rZW5zLmxpbmtzKTtcbiAgICAgICAgICAgIGlmIChsaW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKChtYXRjaCA9IHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5yZWZsaW5rU2VhcmNoLmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGlua3MuaW5jbHVkZXMobWF0Y2hbMF0uc2xpY2UobWF0Y2hbMF0ubGFzdEluZGV4T2YoJ1snKSArIDEsIC0xKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tlZFNyYyA9IG1hc2tlZFNyYy5zbGljZSgwLCBtYXRjaC5pbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArICdbJyArICdhJy5yZXBlYXQobWF0Y2hbMF0ubGVuZ3RoIC0gMikgKyAnXSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArIG1hc2tlZFNyYy5zbGljZSh0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUucmVmbGlua1NlYXJjaC5sYXN0SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE1hc2sgb3V0IG90aGVyIGJsb2Nrc1xuICAgICAgICB3aGlsZSAoKG1hdGNoID0gdGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLmJsb2NrU2tpcC5leGVjKG1hc2tlZFNyYykpICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1hc2tlZFNyYyA9IG1hc2tlZFNyYy5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAnWycgKyAnYScucmVwZWF0KG1hdGNoWzBdLmxlbmd0aCAtIDIpICsgJ10nICsgbWFza2VkU3JjLnNsaWNlKHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5ibG9ja1NraXAubGFzdEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYXNrIG91dCBlc2NhcGVkIGNoYXJhY3RlcnNcbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5hbnlQdW5jdHVhdGlvbi5leGVjKG1hc2tlZFNyYykpICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1hc2tlZFNyYyA9IG1hc2tlZFNyYy5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAnKysnICsgbWFza2VkU3JjLnNsaWNlKHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5hbnlQdW5jdHVhdGlvbi5sYXN0SW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBrZWVwUHJldkNoYXIgPSBmYWxzZTtcbiAgICAgICAgbGV0IHByZXZDaGFyID0gJyc7XG4gICAgICAgIHdoaWxlIChzcmMpIHtcbiAgICAgICAgICAgIGlmICgha2VlcFByZXZDaGFyKSB7XG4gICAgICAgICAgICAgICAgcHJldkNoYXIgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtlZXBQcmV2Q2hhciA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHRva2VuO1xuICAgICAgICAgICAgLy8gZXh0ZW5zaW9uc1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHRlbnNpb25zPy5pbmxpbmU/LnNvbWUoKGV4dFRva2VuaXplcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9IGV4dFRva2VuaXplci5jYWxsKHsgbGV4ZXI6IHRoaXMgfSwgc3JjLCB0b2tlbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlc2NhcGVcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmVzY2FwZShzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0YWdcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnRhZyhzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBsaW5rXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5saW5rKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlZmxpbmssIG5vbGlua1xuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIucmVmbGluayhzcmMsIHRoaXMudG9rZW5zLmxpbmtzKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdFRva2VuID0gdG9rZW5zLmF0KC0xKTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ3RleHQnICYmIGxhc3RUb2tlbj8udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gdG9rZW4ucmF3O1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSB0b2tlbi50ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVtICYgc3Ryb25nXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5lbVN0cm9uZyhzcmMsIG1hc2tlZFNyYywgcHJldkNoYXIpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb2RlXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5jb2Rlc3BhbihzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBiclxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuYnIoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZGVsIChnZm0pXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5kZWwoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYXV0b2xpbmtcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmF1dG9saW5rKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVybCAoZ2ZtKVxuICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmluTGluayAmJiAodG9rZW4gPSB0aGlzLnRva2VuaXplci51cmwoc3JjKSkpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRleHRcbiAgICAgICAgICAgIC8vIHByZXZlbnQgaW5saW5lVGV4dCBjb25zdW1pbmcgZXh0ZW5zaW9ucyBieSBjbGlwcGluZyAnc3JjJyB0byBleHRlbnNpb24gc3RhcnRcbiAgICAgICAgICAgIGxldCBjdXRTcmMgPSBzcmM7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnM/LnN0YXJ0SW5saW5lKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSBJbmZpbml0eTtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wU3JjID0gc3JjLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIGxldCB0ZW1wU3RhcnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuc3RhcnRJbmxpbmUuZm9yRWFjaCgoZ2V0U3RhcnRJbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wU3RhcnQgPSBnZXRTdGFydEluZGV4LmNhbGwoeyBsZXhlcjogdGhpcyB9LCB0ZW1wU3JjKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZW1wU3RhcnQgPT09ICdudW1iZXInICYmIHRlbXBTdGFydCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydEluZGV4ID0gTWF0aC5taW4oc3RhcnRJbmRleCwgdGVtcFN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydEluZGV4IDwgSW5maW5pdHkgJiYgc3RhcnRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1dFNyYyA9IHNyYy5zdWJzdHJpbmcoMCwgc3RhcnRJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmlubGluZVRleHQoY3V0U3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLnJhdy5zbGljZSgtMSkgIT09ICdfJykgeyAvLyBUcmFjayBwcmV2Q2hhciBiZWZvcmUgc3RyaW5nIG9mIF9fX18gc3RhcnRlZFxuICAgICAgICAgICAgICAgICAgICBwcmV2Q2hhciA9IHRva2VuLnJhdy5zbGljZSgtMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGtlZXBQcmV2Q2hhciA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdFRva2VuID0gdG9rZW5zLmF0KC0xKTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFRva2VuPy50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnJhdyArPSB0b2tlbi5yYXc7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi50ZXh0ICs9IHRva2VuLnRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNyYykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyck1zZyA9ICdJbmZpbml0ZSBsb29wIG9uIGJ5dGU6ICcgKyBzcmMuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxufVxuXG4vKipcbiAqIFJlbmRlcmVyXG4gKi9cbmNsYXNzIF9SZW5kZXJlciB7XG4gICAgb3B0aW9ucztcbiAgICBwYXJzZXI7IC8vIHNldCBieSB0aGUgcGFyc2VyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IF9kZWZhdWx0cztcbiAgICB9XG4gICAgc3BhY2UodG9rZW4pIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBjb2RlKHsgdGV4dCwgbGFuZywgZXNjYXBlZCB9KSB7XG4gICAgICAgIGNvbnN0IGxhbmdTdHJpbmcgPSAobGFuZyB8fCAnJykubWF0Y2gob3RoZXIubm90U3BhY2VTdGFydCk/LlswXTtcbiAgICAgICAgY29uc3QgY29kZSA9IHRleHQucmVwbGFjZShvdGhlci5lbmRpbmdOZXdsaW5lLCAnJykgKyAnXFxuJztcbiAgICAgICAgaWYgKCFsYW5nU3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gJzxwcmU+PGNvZGU+J1xuICAgICAgICAgICAgICAgICsgKGVzY2FwZWQgPyBjb2RlIDogZXNjYXBlKGNvZGUsIHRydWUpKVxuICAgICAgICAgICAgICAgICsgJzwvY29kZT48L3ByZT5cXG4nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnPHByZT48Y29kZSBjbGFzcz1cImxhbmd1YWdlLSdcbiAgICAgICAgICAgICsgZXNjYXBlKGxhbmdTdHJpbmcpXG4gICAgICAgICAgICArICdcIj4nXG4gICAgICAgICAgICArIChlc2NhcGVkID8gY29kZSA6IGVzY2FwZShjb2RlLCB0cnVlKSlcbiAgICAgICAgICAgICsgJzwvY29kZT48L3ByZT5cXG4nO1xuICAgIH1cbiAgICBibG9ja3F1b3RlKHsgdG9rZW5zIH0pIHtcbiAgICAgICAgY29uc3QgYm9keSA9IHRoaXMucGFyc2VyLnBhcnNlKHRva2Vucyk7XG4gICAgICAgIHJldHVybiBgPGJsb2NrcXVvdGU+XFxuJHtib2R5fTwvYmxvY2txdW90ZT5cXG5gO1xuICAgIH1cbiAgICBodG1sKHsgdGV4dCB9KSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBoZWFkaW5nKHsgdG9rZW5zLCBkZXB0aCB9KSB7XG4gICAgICAgIHJldHVybiBgPGgke2RlcHRofT4ke3RoaXMucGFyc2VyLnBhcnNlSW5saW5lKHRva2Vucyl9PC9oJHtkZXB0aH0+XFxuYDtcbiAgICB9XG4gICAgaHIodG9rZW4pIHtcbiAgICAgICAgcmV0dXJuICc8aHI+XFxuJztcbiAgICB9XG4gICAgbGlzdCh0b2tlbikge1xuICAgICAgICBjb25zdCBvcmRlcmVkID0gdG9rZW4ub3JkZXJlZDtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0b2tlbi5zdGFydDtcbiAgICAgICAgbGV0IGJvZHkgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0b2tlbi5pdGVtcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRva2VuLml0ZW1zW2pdO1xuICAgICAgICAgICAgYm9keSArPSB0aGlzLmxpc3RpdGVtKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR5cGUgPSBvcmRlcmVkID8gJ29sJyA6ICd1bCc7XG4gICAgICAgIGNvbnN0IHN0YXJ0QXR0ciA9IChvcmRlcmVkICYmIHN0YXJ0ICE9PSAxKSA/ICgnIHN0YXJ0PVwiJyArIHN0YXJ0ICsgJ1wiJykgOiAnJztcbiAgICAgICAgcmV0dXJuICc8JyArIHR5cGUgKyBzdGFydEF0dHIgKyAnPlxcbicgKyBib2R5ICsgJzwvJyArIHR5cGUgKyAnPlxcbic7XG4gICAgfVxuICAgIGxpc3RpdGVtKGl0ZW0pIHtcbiAgICAgICAgbGV0IGl0ZW1Cb2R5ID0gJyc7XG4gICAgICAgIGlmIChpdGVtLnRhc2spIHtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrYm94ID0gdGhpcy5jaGVja2JveCh7IGNoZWNrZWQ6ICEhaXRlbS5jaGVja2VkIH0pO1xuICAgICAgICAgICAgaWYgKGl0ZW0ubG9vc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS50b2tlbnNbMF0/LnR5cGUgPT09ICdwYXJhZ3JhcGgnKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0udG9rZW5zWzBdLnRleHQgPSBjaGVja2JveCArICcgJyArIGl0ZW0udG9rZW5zWzBdLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnRva2Vuc1swXS50b2tlbnMgJiYgaXRlbS50b2tlbnNbMF0udG9rZW5zLmxlbmd0aCA+IDAgJiYgaXRlbS50b2tlbnNbMF0udG9rZW5zWzBdLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS50b2tlbnNbMF0udG9rZW5zWzBdLnRleHQgPSBjaGVja2JveCArICcgJyArIGVzY2FwZShpdGVtLnRva2Vuc1swXS50b2tlbnNbMF0udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnRva2Vuc1swXS50b2tlbnNbMF0uZXNjYXBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0udG9rZW5zLnVuc2hpZnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3OiBjaGVja2JveCArICcgJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGNoZWNrYm94ICsgJyAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlbUJvZHkgKz0gY2hlY2tib3ggKyAnICc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaXRlbUJvZHkgKz0gdGhpcy5wYXJzZXIucGFyc2UoaXRlbS50b2tlbnMsICEhaXRlbS5sb29zZSk7XG4gICAgICAgIHJldHVybiBgPGxpPiR7aXRlbUJvZHl9PC9saT5cXG5gO1xuICAgIH1cbiAgICBjaGVja2JveCh7IGNoZWNrZWQgfSkge1xuICAgICAgICByZXR1cm4gJzxpbnB1dCAnXG4gICAgICAgICAgICArIChjaGVja2VkID8gJ2NoZWNrZWQ9XCJcIiAnIDogJycpXG4gICAgICAgICAgICArICdkaXNhYmxlZD1cIlwiIHR5cGU9XCJjaGVja2JveFwiPic7XG4gICAgfVxuICAgIHBhcmFncmFwaCh7IHRva2VucyB9KSB7XG4gICAgICAgIHJldHVybiBgPHA+JHt0aGlzLnBhcnNlci5wYXJzZUlubGluZSh0b2tlbnMpfTwvcD5cXG5gO1xuICAgIH1cbiAgICB0YWJsZSh0b2tlbikge1xuICAgICAgICBsZXQgaGVhZGVyID0gJyc7XG4gICAgICAgIC8vIGhlYWRlclxuICAgICAgICBsZXQgY2VsbCA9ICcnO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRva2VuLmhlYWRlci5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY2VsbCArPSB0aGlzLnRhYmxlY2VsbCh0b2tlbi5oZWFkZXJbal0pO1xuICAgICAgICB9XG4gICAgICAgIGhlYWRlciArPSB0aGlzLnRhYmxlcm93KHsgdGV4dDogY2VsbCB9KTtcbiAgICAgICAgbGV0IGJvZHkgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0b2tlbi5yb3dzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCByb3cgPSB0b2tlbi5yb3dzW2pdO1xuICAgICAgICAgICAgY2VsbCA9ICcnO1xuICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCByb3cubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICBjZWxsICs9IHRoaXMudGFibGVjZWxsKHJvd1trXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib2R5ICs9IHRoaXMudGFibGVyb3coeyB0ZXh0OiBjZWxsIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChib2R5KVxuICAgICAgICAgICAgYm9keSA9IGA8dGJvZHk+JHtib2R5fTwvdGJvZHk+YDtcbiAgICAgICAgcmV0dXJuICc8dGFibGU+XFxuJ1xuICAgICAgICAgICAgKyAnPHRoZWFkPlxcbidcbiAgICAgICAgICAgICsgaGVhZGVyXG4gICAgICAgICAgICArICc8L3RoZWFkPlxcbidcbiAgICAgICAgICAgICsgYm9keVxuICAgICAgICAgICAgKyAnPC90YWJsZT5cXG4nO1xuICAgIH1cbiAgICB0YWJsZXJvdyh7IHRleHQgfSkge1xuICAgICAgICByZXR1cm4gYDx0cj5cXG4ke3RleHR9PC90cj5cXG5gO1xuICAgIH1cbiAgICB0YWJsZWNlbGwodG9rZW4pIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IHRoaXMucGFyc2VyLnBhcnNlSW5saW5lKHRva2VuLnRva2Vucyk7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0b2tlbi5oZWFkZXIgPyAndGgnIDogJ3RkJztcbiAgICAgICAgY29uc3QgdGFnID0gdG9rZW4uYWxpZ25cbiAgICAgICAgICAgID8gYDwke3R5cGV9IGFsaWduPVwiJHt0b2tlbi5hbGlnbn1cIj5gXG4gICAgICAgICAgICA6IGA8JHt0eXBlfT5gO1xuICAgICAgICByZXR1cm4gdGFnICsgY29udGVudCArIGA8LyR7dHlwZX0+XFxuYDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogc3BhbiBsZXZlbCByZW5kZXJlclxuICAgICAqL1xuICAgIHN0cm9uZyh7IHRva2VucyB9KSB7XG4gICAgICAgIHJldHVybiBgPHN0cm9uZz4ke3RoaXMucGFyc2VyLnBhcnNlSW5saW5lKHRva2Vucyl9PC9zdHJvbmc+YDtcbiAgICB9XG4gICAgZW0oeyB0b2tlbnMgfSkge1xuICAgICAgICByZXR1cm4gYDxlbT4ke3RoaXMucGFyc2VyLnBhcnNlSW5saW5lKHRva2Vucyl9PC9lbT5gO1xuICAgIH1cbiAgICBjb2Rlc3Bhbih7IHRleHQgfSkge1xuICAgICAgICByZXR1cm4gYDxjb2RlPiR7ZXNjYXBlKHRleHQsIHRydWUpfTwvY29kZT5gO1xuICAgIH1cbiAgICBicih0b2tlbikge1xuICAgICAgICByZXR1cm4gJzxicj4nO1xuICAgIH1cbiAgICBkZWwoeyB0b2tlbnMgfSkge1xuICAgICAgICByZXR1cm4gYDxkZWw+JHt0aGlzLnBhcnNlci5wYXJzZUlubGluZSh0b2tlbnMpfTwvZGVsPmA7XG4gICAgfVxuICAgIGxpbmsoeyBocmVmLCB0aXRsZSwgdG9rZW5zIH0pIHtcbiAgICAgICAgY29uc3QgdGV4dCA9IHRoaXMucGFyc2VyLnBhcnNlSW5saW5lKHRva2Vucyk7XG4gICAgICAgIGNvbnN0IGNsZWFuSHJlZiA9IGNsZWFuVXJsKGhyZWYpO1xuICAgICAgICBpZiAoY2xlYW5IcmVmID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgICAgfVxuICAgICAgICBocmVmID0gY2xlYW5IcmVmO1xuICAgICAgICBsZXQgb3V0ID0gJzxhIGhyZWY9XCInICsgaHJlZiArICdcIic7XG4gICAgICAgIGlmICh0aXRsZSkge1xuICAgICAgICAgICAgb3V0ICs9ICcgdGl0bGU9XCInICsgKGVzY2FwZSh0aXRsZSkpICsgJ1wiJztcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gJz4nICsgdGV4dCArICc8L2E+JztcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgaW1hZ2UoeyBocmVmLCB0aXRsZSwgdGV4dCB9KSB7XG4gICAgICAgIGNvbnN0IGNsZWFuSHJlZiA9IGNsZWFuVXJsKGhyZWYpO1xuICAgICAgICBpZiAoY2xlYW5IcmVmID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZXNjYXBlKHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGhyZWYgPSBjbGVhbkhyZWY7XG4gICAgICAgIGxldCBvdXQgPSBgPGltZyBzcmM9XCIke2hyZWZ9XCIgYWx0PVwiJHt0ZXh0fVwiYDtcbiAgICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgICAgICBvdXQgKz0gYCB0aXRsZT1cIiR7ZXNjYXBlKHRpdGxlKX1cImA7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICc+JztcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgdGV4dCh0b2tlbikge1xuICAgICAgICByZXR1cm4gJ3Rva2VucycgaW4gdG9rZW4gJiYgdG9rZW4udG9rZW5zXG4gICAgICAgICAgICA/IHRoaXMucGFyc2VyLnBhcnNlSW5saW5lKHRva2VuLnRva2VucylcbiAgICAgICAgICAgIDogKCdlc2NhcGVkJyBpbiB0b2tlbiAmJiB0b2tlbi5lc2NhcGVkID8gdG9rZW4udGV4dCA6IGVzY2FwZSh0b2tlbi50ZXh0KSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRleHRSZW5kZXJlclxuICogcmV0dXJucyBvbmx5IHRoZSB0ZXh0dWFsIHBhcnQgb2YgdGhlIHRva2VuXG4gKi9cbmNsYXNzIF9UZXh0UmVuZGVyZXIge1xuICAgIC8vIG5vIG5lZWQgZm9yIGJsb2NrIGxldmVsIHJlbmRlcmVyc1xuICAgIHN0cm9uZyh7IHRleHQgfSkge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgZW0oeyB0ZXh0IH0pIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIGNvZGVzcGFuKHsgdGV4dCB9KSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBkZWwoeyB0ZXh0IH0pIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIGh0bWwoeyB0ZXh0IH0pIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIHRleHQoeyB0ZXh0IH0pIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIGxpbmsoeyB0ZXh0IH0pIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGV4dDtcbiAgICB9XG4gICAgaW1hZ2UoeyB0ZXh0IH0pIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGV4dDtcbiAgICB9XG4gICAgYnIoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59XG5cbi8qKlxuICogUGFyc2luZyAmIENvbXBpbGluZ1xuICovXG5jbGFzcyBfUGFyc2VyIHtcbiAgICBvcHRpb25zO1xuICAgIHJlbmRlcmVyO1xuICAgIHRleHRSZW5kZXJlcjtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgX2RlZmF1bHRzO1xuICAgICAgICB0aGlzLm9wdGlvbnMucmVuZGVyZXIgPSB0aGlzLm9wdGlvbnMucmVuZGVyZXIgfHwgbmV3IF9SZW5kZXJlcigpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHRoaXMucmVuZGVyZXIucGFyc2VyID0gdGhpcztcbiAgICAgICAgdGhpcy50ZXh0UmVuZGVyZXIgPSBuZXcgX1RleHRSZW5kZXJlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgUGFyc2UgTWV0aG9kXG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlKHRva2Vucywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBwYXJzZXIgPSBuZXcgX1BhcnNlcihvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlci5wYXJzZSh0b2tlbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgUGFyc2UgSW5saW5lIE1ldGhvZFxuICAgICAqL1xuICAgIHN0YXRpYyBwYXJzZUlubGluZSh0b2tlbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3IF9QYXJzZXIob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBwYXJzZXIucGFyc2VJbmxpbmUodG9rZW5zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UgTG9vcFxuICAgICAqL1xuICAgIHBhcnNlKHRva2VucywgdG9wID0gdHJ1ZSkge1xuICAgICAgICBsZXQgb3V0ID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBhbnlUb2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgIC8vIFJ1biBhbnkgcmVuZGVyZXIgZXh0ZW5zaW9uc1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHRlbnNpb25zPy5yZW5kZXJlcnM/LlthbnlUb2tlbi50eXBlXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGdlbmVyaWNUb2tlbiA9IGFueVRva2VuO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9IHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnJlbmRlcmVyc1tnZW5lcmljVG9rZW4udHlwZV0uY2FsbCh7IHBhcnNlcjogdGhpcyB9LCBnZW5lcmljVG9rZW4pO1xuICAgICAgICAgICAgICAgIGlmIChyZXQgIT09IGZhbHNlIHx8ICFbJ3NwYWNlJywgJ2hyJywgJ2hlYWRpbmcnLCAnY29kZScsICd0YWJsZScsICdibG9ja3F1b3RlJywgJ2xpc3QnLCAnaHRtbCcsICdwYXJhZ3JhcGgnLCAndGV4dCddLmluY2x1ZGVzKGdlbmVyaWNUb2tlbi50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmV0IHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IGFueVRva2VuO1xuICAgICAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3BhY2UnOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLnNwYWNlKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2hyJzoge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5ocih0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdoZWFkaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5oZWFkaW5nKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2NvZGUnOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmNvZGUodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAndGFibGUnOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLnRhYmxlKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jsb2NrcXVvdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmJsb2NrcXVvdGUodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnbGlzdCc6IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIubGlzdCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdodG1sJzoge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5odG1sKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ3BhcmFncmFwaCc6IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIucGFyYWdyYXBoKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ3RleHQnOiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0VG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJvZHkgPSB0aGlzLnJlbmRlcmVyLnRleHQodGV4dFRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGkgKyAxIDwgdG9rZW5zLmxlbmd0aCAmJiB0b2tlbnNbaSArIDFdLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFRva2VuID0gdG9rZW5zWysraV07XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ICs9ICdcXG4nICsgdGhpcy5yZW5kZXJlci50ZXh0KHRleHRUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIucGFyYWdyYXBoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncGFyYWdyYXBoJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXc6IGJvZHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogYm9keSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnM6IFt7IHR5cGU6ICd0ZXh0JywgcmF3OiBib2R5LCB0ZXh0OiBib2R5LCBlc2NhcGVkOiB0cnVlIH1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQgKz0gYm9keTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJNc2cgPSAnVG9rZW4gd2l0aCBcIicgKyB0b2tlbi50eXBlICsgJ1wiIHR5cGUgd2FzIG5vdCBmb3VuZC4nO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UgSW5saW5lIFRva2Vuc1xuICAgICAqL1xuICAgIHBhcnNlSW5saW5lKHRva2VucywgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyKSB7XG4gICAgICAgIGxldCBvdXQgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGFueVRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgLy8gUnVuIGFueSByZW5kZXJlciBleHRlbnNpb25zXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnM/LnJlbmRlcmVycz8uW2FueVRva2VuLnR5cGVdKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzW2FueVRva2VuLnR5cGVdLmNhbGwoeyBwYXJzZXI6IHRoaXMgfSwgYW55VG9rZW4pO1xuICAgICAgICAgICAgICAgIGlmIChyZXQgIT09IGZhbHNlIHx8ICFbJ2VzY2FwZScsICdodG1sJywgJ2xpbmsnLCAnaW1hZ2UnLCAnc3Ryb25nJywgJ2VtJywgJ2NvZGVzcGFuJywgJ2JyJywgJ2RlbCcsICd0ZXh0J10uaW5jbHVkZXMoYW55VG9rZW4udHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHJldCB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSBhbnlUb2tlbjtcbiAgICAgICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2VzY2FwZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLnRleHQodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnaHRtbCc6IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmh0bWwodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnbGluayc6IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmxpbmsodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnaW1hZ2UnOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5pbWFnZSh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdzdHJvbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5zdHJvbmcodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnZW0nOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5lbSh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdjb2Rlc3Bhbic6IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmNvZGVzcGFuKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2JyJzoge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuYnIodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnZGVsJzoge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuZGVsKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ3RleHQnOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci50ZXh0KHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyTXNnID0gJ1Rva2VuIHdpdGggXCInICsgdG9rZW4udHlwZSArICdcIiB0eXBlIHdhcyBub3QgZm91bmQuJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxufVxuXG5jbGFzcyBfSG9va3Mge1xuICAgIG9wdGlvbnM7XG4gICAgYmxvY2s7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IF9kZWZhdWx0cztcbiAgICB9XG4gICAgc3RhdGljIHBhc3NUaHJvdWdoSG9va3MgPSBuZXcgU2V0KFtcbiAgICAgICAgJ3ByZXByb2Nlc3MnLFxuICAgICAgICAncG9zdHByb2Nlc3MnLFxuICAgICAgICAncHJvY2Vzc0FsbFRva2VucycsXG4gICAgXSk7XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBtYXJrZG93biBiZWZvcmUgbWFya2VkXG4gICAgICovXG4gICAgcHJlcHJvY2VzcyhtYXJrZG93bikge1xuICAgICAgICByZXR1cm4gbWFya2Rvd247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgSFRNTCBhZnRlciBtYXJrZWQgaXMgZmluaXNoZWRcbiAgICAgKi9cbiAgICBwb3N0cHJvY2VzcyhodG1sKSB7XG4gICAgICAgIHJldHVybiBodG1sO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGFsbCB0b2tlbnMgYmVmb3JlIHdhbGsgdG9rZW5zXG4gICAgICovXG4gICAgcHJvY2Vzc0FsbFRva2Vucyh0b2tlbnMpIHtcbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvdmlkZSBmdW5jdGlvbiB0byB0b2tlbml6ZSBtYXJrZG93blxuICAgICAqL1xuICAgIHByb3ZpZGVMZXhlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmxvY2sgPyBfTGV4ZXIubGV4IDogX0xleGVyLmxleElubGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvdmlkZSBmdW5jdGlvbiB0byBwYXJzZSB0b2tlbnNcbiAgICAgKi9cbiAgICBwcm92aWRlUGFyc2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ibG9jayA/IF9QYXJzZXIucGFyc2UgOiBfUGFyc2VyLnBhcnNlSW5saW5lO1xuICAgIH1cbn1cblxuY2xhc3MgTWFya2VkIHtcbiAgICBkZWZhdWx0cyA9IF9nZXREZWZhdWx0cygpO1xuICAgIG9wdGlvbnMgPSB0aGlzLnNldE9wdGlvbnM7XG4gICAgcGFyc2UgPSB0aGlzLnBhcnNlTWFya2Rvd24odHJ1ZSk7XG4gICAgcGFyc2VJbmxpbmUgPSB0aGlzLnBhcnNlTWFya2Rvd24oZmFsc2UpO1xuICAgIFBhcnNlciA9IF9QYXJzZXI7XG4gICAgUmVuZGVyZXIgPSBfUmVuZGVyZXI7XG4gICAgVGV4dFJlbmRlcmVyID0gX1RleHRSZW5kZXJlcjtcbiAgICBMZXhlciA9IF9MZXhlcjtcbiAgICBUb2tlbml6ZXIgPSBfVG9rZW5pemVyO1xuICAgIEhvb2tzID0gX0hvb2tzO1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy51c2UoLi4uYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJ1biBjYWxsYmFjayBmb3IgZXZlcnkgdG9rZW5cbiAgICAgKi9cbiAgICB3YWxrVG9rZW5zKHRva2VucywgY2FsbGJhY2spIHtcbiAgICAgICAgbGV0IHZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIHRva2Vucykge1xuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdChjYWxsYmFjay5jYWxsKHRoaXMsIHRva2VuKSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd0YWJsZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFibGVUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNlbGwgb2YgdGFibGVUb2tlbi5oZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQodGhpcy53YWxrVG9rZW5zKGNlbGwudG9rZW5zLCBjYWxsYmFjaykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRhYmxlVG9rZW4ucm93cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjZWxsIG9mIHJvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQodGhpcy53YWxrVG9rZW5zKGNlbGwudG9rZW5zLCBjYWxsYmFjaykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdsaXN0Jzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaXN0VG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdCh0aGlzLndhbGtUb2tlbnMobGlzdFRva2VuLml0ZW1zLCBjYWxsYmFjaykpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBnZW5lcmljVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVmYXVsdHMuZXh0ZW5zaW9ucz8uY2hpbGRUb2tlbnM/LltnZW5lcmljVG9rZW4udHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmYXVsdHMuZXh0ZW5zaW9ucy5jaGlsZFRva2Vuc1tnZW5lcmljVG9rZW4udHlwZV0uZm9yRWFjaCgoY2hpbGRUb2tlbnMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbnMgPSBnZW5lcmljVG9rZW5bY2hpbGRUb2tlbnNdLmZsYXQoSW5maW5pdHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQodGhpcy53YWxrVG9rZW5zKHRva2VucywgY2FsbGJhY2spKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGdlbmVyaWNUb2tlbi50b2tlbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQodGhpcy53YWxrVG9rZW5zKGdlbmVyaWNUb2tlbi50b2tlbnMsIGNhbGxiYWNrKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gICAgdXNlKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuZGVmYXVsdHMuZXh0ZW5zaW9ucyB8fCB7IHJlbmRlcmVyczoge30sIGNoaWxkVG9rZW5zOiB7fSB9O1xuICAgICAgICBhcmdzLmZvckVhY2goKHBhY2spID0+IHtcbiAgICAgICAgICAgIC8vIGNvcHkgb3B0aW9ucyB0byBuZXcgb2JqZWN0XG4gICAgICAgICAgICBjb25zdCBvcHRzID0geyAuLi5wYWNrIH07XG4gICAgICAgICAgICAvLyBzZXQgYXN5bmMgdG8gdHJ1ZSBpZiBpdCB3YXMgc2V0IHRvIHRydWUgYmVmb3JlXG4gICAgICAgICAgICBvcHRzLmFzeW5jID0gdGhpcy5kZWZhdWx0cy5hc3luYyB8fCBvcHRzLmFzeW5jIHx8IGZhbHNlO1xuICAgICAgICAgICAgLy8gPT0tLSBQYXJzZSBcImFkZG9uXCIgZXh0ZW5zaW9ucyAtLT09IC8vXG4gICAgICAgICAgICBpZiAocGFjay5leHRlbnNpb25zKSB7XG4gICAgICAgICAgICAgICAgcGFjay5leHRlbnNpb25zLmZvckVhY2goKGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV4dC5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4dGVuc2lvbiBuYW1lIHJlcXVpcmVkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCdyZW5kZXJlcicgaW4gZXh0KSB7IC8vIFJlbmRlcmVyIGV4dGVuc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZSZW5kZXJlciA9IGV4dGVuc2lvbnMucmVuZGVyZXJzW2V4dC5uYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2UmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIGV4dGVuc2lvbiB3aXRoIGZ1bmMgdG8gcnVuIG5ldyBleHRlbnNpb24gYnV0IGZhbGwgYmFjayBpZiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnMucmVuZGVyZXJzW2V4dC5uYW1lXSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXQgPSBleHQucmVuZGVyZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBwcmV2UmVuZGVyZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5yZW5kZXJlcnNbZXh0Lm5hbWVdID0gZXh0LnJlbmRlcmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgndG9rZW5pemVyJyBpbiBleHQpIHsgLy8gVG9rZW5pemVyIEV4dGVuc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXh0LmxldmVsIHx8IChleHQubGV2ZWwgIT09ICdibG9jaycgJiYgZXh0LmxldmVsICE9PSAnaW5saW5lJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJleHRlbnNpb24gbGV2ZWwgbXVzdCBiZSAnYmxvY2snIG9yICdpbmxpbmUnXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXh0TGV2ZWwgPSBleHRlbnNpb25zW2V4dC5sZXZlbF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXh0TGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRMZXZlbC51bnNoaWZ0KGV4dC50b2tlbml6ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uc1tleHQubGV2ZWxdID0gW2V4dC50b2tlbml6ZXJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4dC5zdGFydCkgeyAvLyBGdW5jdGlvbiB0byBjaGVjayBmb3Igc3RhcnQgb2YgdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXh0LmxldmVsID09PSAnYmxvY2snKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHRlbnNpb25zLnN0YXJ0QmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnMuc3RhcnRCbG9jay5wdXNoKGV4dC5zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zLnN0YXJ0QmxvY2sgPSBbZXh0LnN0YXJ0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChleHQubGV2ZWwgPT09ICdpbmxpbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHRlbnNpb25zLnN0YXJ0SW5saW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zLnN0YXJ0SW5saW5lLnB1c2goZXh0LnN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnMuc3RhcnRJbmxpbmUgPSBbZXh0LnN0YXJ0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoJ2NoaWxkVG9rZW5zJyBpbiBleHQgJiYgZXh0LmNoaWxkVG9rZW5zKSB7IC8vIENoaWxkIHRva2VucyB0byBiZSB2aXNpdGVkIGJ5IHdhbGtUb2tlbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnMuY2hpbGRUb2tlbnNbZXh0Lm5hbWVdID0gZXh0LmNoaWxkVG9rZW5zO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgb3B0cy5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vID09LS0gUGFyc2UgXCJvdmVyd3JpdGVcIiBleHRlbnNpb25zIC0tPT0gLy9cbiAgICAgICAgICAgIGlmIChwYWNrLnJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLmRlZmF1bHRzLnJlbmRlcmVyIHx8IG5ldyBfUmVuZGVyZXIodGhpcy5kZWZhdWx0cyk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIHBhY2sucmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocHJvcCBpbiByZW5kZXJlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcmVuZGVyZXIgJyR7cHJvcH0nIGRvZXMgbm90IGV4aXN0YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKFsnb3B0aW9ucycsICdwYXJzZXInXS5pbmNsdWRlcyhwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIG9wdGlvbnMgcHJvcGVydHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVyUHJvcCA9IHByb3A7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVyRnVuYyA9IHBhY2sucmVuZGVyZXJbcmVuZGVyZXJQcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldlJlbmRlcmVyID0gcmVuZGVyZXJbcmVuZGVyZXJQcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVwbGFjZSByZW5kZXJlciB3aXRoIGZ1bmMgdG8gcnVuIGV4dGVuc2lvbiwgYnV0IGZhbGwgYmFjayBpZiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICByZW5kZXJlcltyZW5kZXJlclByb3BdID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXQgPSByZW5kZXJlckZ1bmMuYXBwbHkocmVuZGVyZXIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBwcmV2UmVuZGVyZXIuYXBwbHkocmVuZGVyZXIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldCB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0cy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhY2sudG9rZW5pemVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9rZW5pemVyID0gdGhpcy5kZWZhdWx0cy50b2tlbml6ZXIgfHwgbmV3IF9Ub2tlbml6ZXIodGhpcy5kZWZhdWx0cyk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIHBhY2sudG9rZW5pemVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHByb3AgaW4gdG9rZW5pemVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB0b2tlbml6ZXIgJyR7cHJvcH0nIGRvZXMgbm90IGV4aXN0YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKFsnb3B0aW9ucycsICdydWxlcycsICdsZXhlciddLmluY2x1ZGVzKHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgb3B0aW9ucywgcnVsZXMsIGFuZCBsZXhlciBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbml6ZXJQcm9wID0gcHJvcDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW5pemVyRnVuYyA9IHBhY2sudG9rZW5pemVyW3Rva2VuaXplclByb3BdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2VG9rZW5pemVyID0gdG9rZW5pemVyW3Rva2VuaXplclByb3BdO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIHRva2VuaXplciB3aXRoIGZ1bmMgdG8gcnVuIGV4dGVuc2lvbiwgYnV0IGZhbGwgYmFjayBpZiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGNhbm5vdCB0eXBlIHRva2VuaXplciBmdW5jdGlvbiBkeW5hbWljYWxseVxuICAgICAgICAgICAgICAgICAgICB0b2tlbml6ZXJbdG9rZW5pemVyUHJvcF0gPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJldCA9IHRva2VuaXplckZ1bmMuYXBwbHkodG9rZW5pemVyLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gcHJldlRva2VuaXplci5hcHBseSh0b2tlbml6ZXIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0cy50b2tlbml6ZXIgPSB0b2tlbml6ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyA9PS0tIFBhcnNlIEhvb2tzIGV4dGVuc2lvbnMgLS09PSAvL1xuICAgICAgICAgICAgaWYgKHBhY2suaG9va3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBob29rcyA9IHRoaXMuZGVmYXVsdHMuaG9va3MgfHwgbmV3IF9Ib29rcygpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBwYWNrLmhvb2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHByb3AgaW4gaG9va3MpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGhvb2sgJyR7cHJvcH0nIGRvZXMgbm90IGV4aXN0YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKFsnb3B0aW9ucycsICdibG9jayddLmluY2x1ZGVzKHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgb3B0aW9ucyBhbmQgYmxvY2sgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaG9va3NQcm9wID0gcHJvcDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaG9va3NGdW5jID0gcGFjay5ob29rc1tob29rc1Byb3BdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2SG9vayA9IGhvb2tzW2hvb2tzUHJvcF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChfSG9va3MucGFzc1Rocm91Z2hIb29rcy5oYXMocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgY2Fubm90IHR5cGUgaG9vayBmdW5jdGlvbiBkeW5hbWljYWxseVxuICAgICAgICAgICAgICAgICAgICAgICAgaG9va3NbaG9va3NQcm9wXSA9IChhcmcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWZhdWx0cy5hc3luYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGhvb2tzRnVuYy5jYWxsKGhvb2tzLCBhcmcpKS50aGVuKHJldCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJldkhvb2suY2FsbChob29rcywgcmV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9IGhvb2tzRnVuYy5jYWxsKGhvb2tzLCBhcmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmV2SG9vay5jYWxsKGhvb2tzLCByZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgY2Fubm90IHR5cGUgaG9vayBmdW5jdGlvbiBkeW5hbWljYWxseVxuICAgICAgICAgICAgICAgICAgICAgICAgaG9va3NbaG9va3NQcm9wXSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJldCA9IGhvb2tzRnVuYy5hcHBseShob29rcywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gcHJldkhvb2suYXBwbHkoaG9va3MsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRzLmhvb2tzID0gaG9va3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyA9PS0tIFBhcnNlIFdhbGtUb2tlbnMgZXh0ZW5zaW9ucyAtLT09IC8vXG4gICAgICAgICAgICBpZiAocGFjay53YWxrVG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2Fsa1Rva2VucyA9IHRoaXMuZGVmYXVsdHMud2Fsa1Rva2VucztcbiAgICAgICAgICAgICAgICBjb25zdCBwYWNrV2Fsa3Rva2VucyA9IHBhY2sud2Fsa1Rva2VucztcbiAgICAgICAgICAgICAgICBvcHRzLndhbGtUb2tlbnMgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChwYWNrV2Fsa3Rva2Vucy5jYWxsKHRoaXMsIHRva2VuKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3YWxrVG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHdhbGtUb2tlbnMuY2FsbCh0aGlzLCB0b2tlbikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdHMgPSB7IC4uLnRoaXMuZGVmYXVsdHMsIC4uLm9wdHMgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRPcHRpb25zKG9wdCkge1xuICAgICAgICB0aGlzLmRlZmF1bHRzID0geyAuLi50aGlzLmRlZmF1bHRzLCAuLi5vcHQgfTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGxleGVyKHNyYywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX0xleGVyLmxleChzcmMsIG9wdGlvbnMgPz8gdGhpcy5kZWZhdWx0cyk7XG4gICAgfVxuICAgIHBhcnNlcih0b2tlbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9QYXJzZXIucGFyc2UodG9rZW5zLCBvcHRpb25zID8/IHRoaXMuZGVmYXVsdHMpO1xuICAgIH1cbiAgICBwYXJzZU1hcmtkb3duKGJsb2NrVHlwZSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCBwYXJzZSA9IChzcmMsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdPcHQgPSB7IC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IG9wdCA9IHsgLi4udGhpcy5kZWZhdWx0cywgLi4ub3JpZ09wdCB9O1xuICAgICAgICAgICAgY29uc3QgdGhyb3dFcnJvciA9IHRoaXMub25FcnJvcighIW9wdC5zaWxlbnQsICEhb3B0LmFzeW5jKTtcbiAgICAgICAgICAgIC8vIHRocm93IGVycm9yIGlmIGFuIGV4dGVuc2lvbiBzZXQgYXN5bmMgdG8gdHJ1ZSBidXQgcGFyc2Ugd2FzIGNhbGxlZCB3aXRoIGFzeW5jOiBmYWxzZVxuICAgICAgICAgICAgaWYgKHRoaXMuZGVmYXVsdHMuYXN5bmMgPT09IHRydWUgJiYgb3JpZ09wdC5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihuZXcgRXJyb3IoJ21hcmtlZCgpOiBUaGUgYXN5bmMgb3B0aW9uIHdhcyBzZXQgdG8gdHJ1ZSBieSBhbiBleHRlbnNpb24uIFJlbW92ZSBhc3luYzogZmFsc2UgZnJvbSB0aGUgcGFyc2Ugb3B0aW9ucyBvYmplY3QgdG8gcmV0dXJuIGEgUHJvbWlzZS4nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aHJvdyBlcnJvciBpbiBjYXNlIG9mIG5vbiBzdHJpbmcgaW5wdXRcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3JjID09PSAndW5kZWZpbmVkJyB8fCBzcmMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihuZXcgRXJyb3IoJ21hcmtlZCgpOiBpbnB1dCBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkIG9yIG51bGwnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNyYyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihuZXcgRXJyb3IoJ21hcmtlZCgpOiBpbnB1dCBwYXJhbWV0ZXIgaXMgb2YgdHlwZSAnXG4gICAgICAgICAgICAgICAgICAgICsgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHNyYykgKyAnLCBzdHJpbmcgZXhwZWN0ZWQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0Lmhvb2tzKSB7XG4gICAgICAgICAgICAgICAgb3B0Lmhvb2tzLm9wdGlvbnMgPSBvcHQ7XG4gICAgICAgICAgICAgICAgb3B0Lmhvb2tzLmJsb2NrID0gYmxvY2tUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGV4ZXIgPSBvcHQuaG9va3MgPyBvcHQuaG9va3MucHJvdmlkZUxleGVyKCkgOiAoYmxvY2tUeXBlID8gX0xleGVyLmxleCA6IF9MZXhlci5sZXhJbmxpbmUpO1xuICAgICAgICAgICAgY29uc3QgcGFyc2VyID0gb3B0Lmhvb2tzID8gb3B0Lmhvb2tzLnByb3ZpZGVQYXJzZXIoKSA6IChibG9ja1R5cGUgPyBfUGFyc2VyLnBhcnNlIDogX1BhcnNlci5wYXJzZUlubGluZSk7XG4gICAgICAgICAgICBpZiAob3B0LmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShvcHQuaG9va3MgPyBvcHQuaG9va3MucHJlcHJvY2VzcyhzcmMpIDogc3JjKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihzcmMgPT4gbGV4ZXIoc3JjLCBvcHQpKVxuICAgICAgICAgICAgICAgICAgICAudGhlbih0b2tlbnMgPT4gb3B0Lmhvb2tzID8gb3B0Lmhvb2tzLnByb2Nlc3NBbGxUb2tlbnModG9rZW5zKSA6IHRva2VucylcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4odG9rZW5zID0+IG9wdC53YWxrVG9rZW5zID8gUHJvbWlzZS5hbGwodGhpcy53YWxrVG9rZW5zKHRva2Vucywgb3B0LndhbGtUb2tlbnMpKS50aGVuKCgpID0+IHRva2VucykgOiB0b2tlbnMpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHRva2VucyA9PiBwYXJzZXIodG9rZW5zLCBvcHQpKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihodG1sID0+IG9wdC5ob29rcyA/IG9wdC5ob29rcy5wb3N0cHJvY2VzcyhodG1sKSA6IGh0bWwpXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCh0aHJvd0Vycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdC5ob29rcykge1xuICAgICAgICAgICAgICAgICAgICBzcmMgPSBvcHQuaG9va3MucHJlcHJvY2VzcyhzcmMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgdG9rZW5zID0gbGV4ZXIoc3JjLCBvcHQpO1xuICAgICAgICAgICAgICAgIGlmIChvcHQuaG9va3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zID0gb3B0Lmhvb2tzLnByb2Nlc3NBbGxUb2tlbnModG9rZW5zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wdC53YWxrVG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2Fsa1Rva2Vucyh0b2tlbnMsIG9wdC53YWxrVG9rZW5zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGh0bWwgPSBwYXJzZXIodG9rZW5zLCBvcHQpO1xuICAgICAgICAgICAgICAgIGlmIChvcHQuaG9va3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbCA9IG9wdC5ob29rcy5wb3N0cHJvY2VzcyhodG1sKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcGFyc2U7XG4gICAgfVxuICAgIG9uRXJyb3Ioc2lsZW50LCBhc3luYykge1xuICAgICAgICByZXR1cm4gKGUpID0+IHtcbiAgICAgICAgICAgIGUubWVzc2FnZSArPSAnXFxuUGxlYXNlIHJlcG9ydCB0aGlzIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZWRqcy9tYXJrZWQuJztcbiAgICAgICAgICAgIGlmIChzaWxlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSAnPHA+QW4gZXJyb3Igb2NjdXJyZWQ6PC9wPjxwcmU+J1xuICAgICAgICAgICAgICAgICAgICArIGVzY2FwZShlLm1lc3NhZ2UgKyAnJywgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgKyAnPC9wcmU+JztcbiAgICAgICAgICAgICAgICBpZiAoYXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbXNnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFzeW5jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmNvbnN0IG1hcmtlZEluc3RhbmNlID0gbmV3IE1hcmtlZCgpO1xuZnVuY3Rpb24gbWFya2VkKHNyYywgb3B0KSB7XG4gICAgcmV0dXJuIG1hcmtlZEluc3RhbmNlLnBhcnNlKHNyYywgb3B0KTtcbn1cbi8qKlxuICogU2V0cyB0aGUgZGVmYXVsdCBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIEhhc2ggb2Ygb3B0aW9uc1xuICovXG5tYXJrZWQub3B0aW9ucyA9XG4gICAgbWFya2VkLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBtYXJrZWRJbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBtYXJrZWQuZGVmYXVsdHMgPSBtYXJrZWRJbnN0YW5jZS5kZWZhdWx0cztcbiAgICAgICAgY2hhbmdlRGVmYXVsdHMobWFya2VkLmRlZmF1bHRzKTtcbiAgICAgICAgcmV0dXJuIG1hcmtlZDtcbiAgICB9O1xuLyoqXG4gKiBHZXRzIHRoZSBvcmlnaW5hbCBtYXJrZWQgZGVmYXVsdCBvcHRpb25zLlxuICovXG5tYXJrZWQuZ2V0RGVmYXVsdHMgPSBfZ2V0RGVmYXVsdHM7XG5tYXJrZWQuZGVmYXVsdHMgPSBfZGVmYXVsdHM7XG4vKipcbiAqIFVzZSBFeHRlbnNpb25cbiAqL1xubWFya2VkLnVzZSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgbWFya2VkSW5zdGFuY2UudXNlKC4uLmFyZ3MpO1xuICAgIG1hcmtlZC5kZWZhdWx0cyA9IG1hcmtlZEluc3RhbmNlLmRlZmF1bHRzO1xuICAgIGNoYW5nZURlZmF1bHRzKG1hcmtlZC5kZWZhdWx0cyk7XG4gICAgcmV0dXJuIG1hcmtlZDtcbn07XG4vKipcbiAqIFJ1biBjYWxsYmFjayBmb3IgZXZlcnkgdG9rZW5cbiAqL1xubWFya2VkLndhbGtUb2tlbnMgPSBmdW5jdGlvbiAodG9rZW5zLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBtYXJrZWRJbnN0YW5jZS53YWxrVG9rZW5zKHRva2VucywgY2FsbGJhY2spO1xufTtcbi8qKlxuICogQ29tcGlsZXMgbWFya2Rvd24gdG8gSFRNTCB3aXRob3V0IGVuY2xvc2luZyBgcGAgdGFnLlxuICpcbiAqIEBwYXJhbSBzcmMgU3RyaW5nIG9mIG1hcmtkb3duIHNvdXJjZSB0byBiZSBjb21waWxlZFxuICogQHBhcmFtIG9wdGlvbnMgSGFzaCBvZiBvcHRpb25zXG4gKiBAcmV0dXJuIFN0cmluZyBvZiBjb21waWxlZCBIVE1MXG4gKi9cbm1hcmtlZC5wYXJzZUlubGluZSA9IG1hcmtlZEluc3RhbmNlLnBhcnNlSW5saW5lO1xuLyoqXG4gKiBFeHBvc2VcbiAqL1xubWFya2VkLlBhcnNlciA9IF9QYXJzZXI7XG5tYXJrZWQucGFyc2VyID0gX1BhcnNlci5wYXJzZTtcbm1hcmtlZC5SZW5kZXJlciA9IF9SZW5kZXJlcjtcbm1hcmtlZC5UZXh0UmVuZGVyZXIgPSBfVGV4dFJlbmRlcmVyO1xubWFya2VkLkxleGVyID0gX0xleGVyO1xubWFya2VkLmxleGVyID0gX0xleGVyLmxleDtcbm1hcmtlZC5Ub2tlbml6ZXIgPSBfVG9rZW5pemVyO1xubWFya2VkLkhvb2tzID0gX0hvb2tzO1xubWFya2VkLnBhcnNlID0gbWFya2VkO1xuY29uc3Qgb3B0aW9ucyA9IG1hcmtlZC5vcHRpb25zO1xuY29uc3Qgc2V0T3B0aW9ucyA9IG1hcmtlZC5zZXRPcHRpb25zO1xuY29uc3QgdXNlID0gbWFya2VkLnVzZTtcbmNvbnN0IHdhbGtUb2tlbnMgPSBtYXJrZWQud2Fsa1Rva2VucztcbmNvbnN0IHBhcnNlSW5saW5lID0gbWFya2VkLnBhcnNlSW5saW5lO1xuY29uc3QgcGFyc2UgPSBtYXJrZWQ7XG5jb25zdCBwYXJzZXIgPSBfUGFyc2VyLnBhcnNlO1xuY29uc3QgbGV4ZXIgPSBfTGV4ZXIubGV4O1xuXG5leHBvcnQgeyBfSG9va3MgYXMgSG9va3MsIF9MZXhlciBhcyBMZXhlciwgTWFya2VkLCBfUGFyc2VyIGFzIFBhcnNlciwgX1JlbmRlcmVyIGFzIFJlbmRlcmVyLCBfVGV4dFJlbmRlcmVyIGFzIFRleHRSZW5kZXJlciwgX1Rva2VuaXplciBhcyBUb2tlbml6ZXIsIF9kZWZhdWx0cyBhcyBkZWZhdWx0cywgX2dldERlZmF1bHRzIGFzIGdldERlZmF1bHRzLCBsZXhlciwgbWFya2VkLCBvcHRpb25zLCBwYXJzZSwgcGFyc2VJbmxpbmUsIHBhcnNlciwgc2V0T3B0aW9ucywgdXNlLCB3YWxrVG9rZW5zIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXJrZWQuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbIl9nZXREZWZhdWx0cyIsImFzeW5jIiwiYnJlYWtzIiwiZXh0ZW5zaW9ucyIsImdmbSIsImhvb2tzIiwicGVkYW50aWMiLCJyZW5kZXJlciIsInNpbGVudCIsInRva2VuaXplciIsIndhbGtUb2tlbnMiLCJfZGVmYXVsdHMiLCJjaGFuZ2VEZWZhdWx0cyIsIm5ld0RlZmF1bHRzIiwibm9vcFRlc3QiLCJleGVjIiwiZWRpdCIsInJlZ2V4Iiwib3B0Iiwic291cmNlIiwib2JqIiwicmVwbGFjZSIsIm5hbWUiLCJ2YWwiLCJ2YWxTb3VyY2UiLCJvdGhlciIsImNhcmV0IiwiZ2V0UmVnZXgiLCJSZWdFeHAiLCJjb2RlUmVtb3ZlSW5kZW50Iiwib3V0cHV0TGlua1JlcGxhY2UiLCJpbmRlbnRDb2RlQ29tcGVuc2F0aW9uIiwiYmVnaW5uaW5nU3BhY2UiLCJlbmRpbmdIYXNoIiwic3RhcnRpbmdTcGFjZUNoYXIiLCJlbmRpbmdTcGFjZUNoYXIiLCJub25TcGFjZUNoYXIiLCJuZXdMaW5lQ2hhckdsb2JhbCIsInRhYkNoYXJHbG9iYWwiLCJtdWx0aXBsZVNwYWNlR2xvYmFsIiwiYmxhbmtMaW5lIiwiZG91YmxlQmxhbmtMaW5lIiwiYmxvY2txdW90ZVN0YXJ0IiwiYmxvY2txdW90ZVNldGV4dFJlcGxhY2UiLCJibG9ja3F1b3RlU2V0ZXh0UmVwbGFjZTIiLCJsaXN0UmVwbGFjZVRhYnMiLCJsaXN0UmVwbGFjZU5lc3RpbmciLCJsaXN0SXNUYXNrIiwibGlzdFJlcGxhY2VUYXNrIiwiYW55TGluZSIsImhyZWZCcmFja2V0cyIsInRhYmxlRGVsaW1pdGVyIiwidGFibGVBbGlnbkNoYXJzIiwidGFibGVSb3dCbGFua0xpbmUiLCJ0YWJsZUFsaWduUmlnaHQiLCJ0YWJsZUFsaWduQ2VudGVyIiwidGFibGVBbGlnbkxlZnQiLCJzdGFydEFUYWciLCJlbmRBVGFnIiwic3RhcnRQcmVTY3JpcHRUYWciLCJlbmRQcmVTY3JpcHRUYWciLCJzdGFydEFuZ2xlQnJhY2tldCIsImVuZEFuZ2xlQnJhY2tldCIsInBlZGFudGljSHJlZlRpdGxlIiwidW5pY29kZUFscGhhTnVtZXJpYyIsImVzY2FwZVRlc3QiLCJlc2NhcGVSZXBsYWNlIiwiZXNjYXBlVGVzdE5vRW5jb2RlIiwiZXNjYXBlUmVwbGFjZU5vRW5jb2RlIiwidW5lc2NhcGVUZXN0IiwicGVyY2VudERlY29kZSIsImZpbmRQaXBlIiwic3BsaXRQaXBlIiwic2xhc2hQaXBlIiwiY2FycmlhZ2VSZXR1cm4iLCJzcGFjZUxpbmUiLCJub3RTcGFjZVN0YXJ0IiwiZW5kaW5nTmV3bGluZSIsImxpc3RJdGVtUmVnZXgiLCJidWxsIiwibmV4dEJ1bGxldFJlZ2V4IiwiaW5kZW50IiwiTWF0aCIsIm1pbiIsImhyUmVnZXgiLCJmZW5jZXNCZWdpblJlZ2V4IiwiaGVhZGluZ0JlZ2luUmVnZXgiLCJodG1sQmVnaW5SZWdleCIsIm5ld2xpbmUiLCJibG9ja0NvZGUiLCJmZW5jZXMiLCJociIsImhlYWRpbmciLCJidWxsZXQiLCJsaGVhZGluZyIsIl9wYXJhZ3JhcGgiLCJibG9ja1RleHQiLCJfYmxvY2tMYWJlbCIsImRlZiIsImxpc3QiLCJfdGFnIiwiX2NvbW1lbnQiLCJodG1sIiwicGFyYWdyYXBoIiwiYmxvY2txdW90ZSIsImJsb2NrTm9ybWFsIiwiY29kZSIsInRhYmxlIiwidGV4dCIsImdmbVRhYmxlIiwiYmxvY2tHZm0iLCJibG9ja1BlZGFudGljIiwiZXNjYXBlJDEiLCJpbmxpbmVDb2RlIiwiYnIiLCJpbmxpbmVUZXh0IiwiX3B1bmN0dWF0aW9uIiwiX3B1bmN0dWF0aW9uT3JTcGFjZSIsIl9ub3RQdW5jdHVhdGlvbk9yU3BhY2UiLCJwdW5jdHVhdGlvbiIsImJsb2NrU2tpcCIsImVtU3Ryb25nTERlbGltIiwiZW1TdHJvbmdSRGVsaW1Bc3QiLCJlbVN0cm9uZ1JEZWxpbVVuZCIsImFueVB1bmN0dWF0aW9uIiwiYXV0b2xpbmsiLCJfaW5saW5lQ29tbWVudCIsInRhZyIsIl9pbmxpbmVMYWJlbCIsImxpbmsiLCJyZWZsaW5rIiwibm9saW5rIiwicmVmbGlua1NlYXJjaCIsImlubGluZU5vcm1hbCIsIl9iYWNrcGVkYWwiLCJkZWwiLCJlc2NhcGUiLCJ1cmwiLCJpbmxpbmVQZWRhbnRpYyIsImlubGluZUdmbSIsImlubGluZUJyZWFrcyIsImJsb2NrIiwibm9ybWFsIiwiaW5saW5lIiwiZXNjYXBlUmVwbGFjZW1lbnRzIiwiZ2V0RXNjYXBlUmVwbGFjZW1lbnQiLCJjaCIsImVuY29kZSIsInRlc3QiLCJjbGVhblVybCIsImhyZWYiLCJlbmNvZGVVUkkiLCJzcGxpdENlbGxzIiwidGFibGVSb3ciLCJjb3VudCIsInJvdyIsIm1hdGNoIiwib2Zmc2V0Iiwic3RyIiwiZXNjYXBlZCIsImN1cnIiLCJjZWxscyIsInNwbGl0IiwiaSIsInRyaW0iLCJzaGlmdCIsImxlbmd0aCIsImF0IiwicG9wIiwic3BsaWNlIiwicHVzaCIsInJ0cmltIiwiYyIsImludmVydCIsImwiLCJzdWZmTGVuIiwiY3VyckNoYXIiLCJjaGFyQXQiLCJzbGljZSIsImZpbmRDbG9zaW5nQnJhY2tldCIsImIiLCJpbmRleE9mIiwibGV2ZWwiLCJvdXRwdXRMaW5rIiwiY2FwIiwicmF3IiwibGV4ZXIiLCJydWxlcyIsInRpdGxlIiwic3RhdGUiLCJpbkxpbmsiLCJ0b2tlbiIsInR5cGUiLCJ0b2tlbnMiLCJpbmxpbmVUb2tlbnMiLCJtYXRjaEluZGVudFRvQ29kZSIsImluZGVudFRvQ29kZSIsIm1hcCIsIm5vZGUiLCJtYXRjaEluZGVudEluTm9kZSIsImluZGVudEluTm9kZSIsImpvaW4iLCJfVG9rZW5pemVyIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwic3BhY2UiLCJzcmMiLCJjb2RlQmxvY2tTdHlsZSIsImxhbmciLCJ0cmltbWVkIiwiZGVwdGgiLCJsaW5lcyIsImluQmxvY2txdW90ZSIsImN1cnJlbnRMaW5lcyIsImN1cnJlbnRSYXciLCJjdXJyZW50VGV4dCIsInRvcCIsImJsb2NrVG9rZW5zIiwibGFzdFRva2VuIiwib2xkVG9rZW4iLCJuZXdUZXh0IiwibmV3VG9rZW4iLCJzdWJzdHJpbmciLCJpc29yZGVyZWQiLCJvcmRlcmVkIiwic3RhcnQiLCJsb29zZSIsIml0ZW1zIiwiaXRlbVJlZ2V4IiwiZW5kc1dpdGhCbGFua0xpbmUiLCJlbmRFYXJseSIsIml0ZW1Db250ZW50cyIsImxpbmUiLCJ0IiwicmVwZWF0IiwibmV4dExpbmUiLCJ0cmltU3RhcnQiLCJzZWFyY2giLCJyYXdMaW5lIiwibmV4dExpbmVXaXRob3V0VGFicyIsImlzdGFzayIsImlzY2hlY2tlZCIsInRhc2siLCJjaGVja2VkIiwibGFzdEl0ZW0iLCJ0cmltRW5kIiwic3BhY2VycyIsImZpbHRlciIsImhhc011bHRpcGxlTGluZUJyZWFrcyIsInNvbWUiLCJwcmUiLCJ0b0xvd2VyQ2FzZSIsImhlYWRlcnMiLCJhbGlnbnMiLCJyb3dzIiwiaXRlbSIsImhlYWRlciIsImFsaWduIiwiY2VsbCIsImluUmF3QmxvY2siLCJ0cmltbWVkVXJsIiwicnRyaW1TbGFzaCIsImxhc3RQYXJlbkluZGV4IiwibGlua0xlbiIsImxpbmtzIiwibGlua1N0cmluZyIsImVtU3Ryb25nIiwibWFza2VkU3JjIiwicHJldkNoYXIiLCJuZXh0Q2hhciIsImxMZW5ndGgiLCJyRGVsaW0iLCJyTGVuZ3RoIiwiZGVsaW1Ub3RhbCIsIm1pZERlbGltVG90YWwiLCJlbmRSZWciLCJsYXN0SW5kZXgiLCJsYXN0Q2hhckxlbmd0aCIsImluZGV4IiwiY29kZXNwYW4iLCJoYXNOb25TcGFjZUNoYXJzIiwiaGFzU3BhY2VDaGFyc09uQm90aEVuZHMiLCJwcmV2Q2FwWmVybyIsIl9MZXhlciIsIk9iamVjdCIsImNyZWF0ZSIsImlubGluZVF1ZXVlIiwibGV4IiwibGV4SW5saW5lIiwibmV4dCIsImxhc3RQYXJhZ3JhcGhDbGlwcGVkIiwiZXh0VG9rZW5pemVyIiwiY2FsbCIsInVuZGVmaW5lZCIsImN1dFNyYyIsInN0YXJ0QmxvY2siLCJzdGFydEluZGV4IiwiSW5maW5pdHkiLCJ0ZW1wU3JjIiwidGVtcFN0YXJ0IiwiZm9yRWFjaCIsImdldFN0YXJ0SW5kZXgiLCJlcnJNc2ciLCJjaGFyQ29kZUF0IiwiY29uc29sZSIsImVycm9yIiwiRXJyb3IiLCJrZXlzIiwiaW5jbHVkZXMiLCJsYXN0SW5kZXhPZiIsImtlZXBQcmV2Q2hhciIsInN0YXJ0SW5saW5lIiwiX1JlbmRlcmVyIiwibGFuZ1N0cmluZyIsImJvZHkiLCJwYXJzZXIiLCJwYXJzZSIsInBhcnNlSW5saW5lIiwiaiIsImxpc3RpdGVtIiwic3RhcnRBdHRyIiwiaXRlbUJvZHkiLCJjaGVja2JveCIsInVuc2hpZnQiLCJ0YWJsZWNlbGwiLCJ0YWJsZXJvdyIsImsiLCJjb250ZW50Iiwic3Ryb25nIiwiZW0iLCJjbGVhbkhyZWYiLCJvdXQiLCJpbWFnZSIsIl9UZXh0UmVuZGVyZXIiLCJfUGFyc2VyIiwidGV4dFJlbmRlcmVyIiwiYW55VG9rZW4iLCJyZW5kZXJlcnMiLCJnZW5lcmljVG9rZW4iLCJyZXQiLCJ0ZXh0VG9rZW4iLCJfSG9va3MiLCJwYXNzVGhyb3VnaEhvb2tzIiwiU2V0IiwicHJlcHJvY2VzcyIsIm1hcmtkb3duIiwicG9zdHByb2Nlc3MiLCJwcm9jZXNzQWxsVG9rZW5zIiwicHJvdmlkZUxleGVyIiwicHJvdmlkZVBhcnNlciIsIk1hcmtlZCIsImFyZ3MiLCJkZWZhdWx0cyIsInNldE9wdGlvbnMiLCJwYXJzZU1hcmtkb3duIiwiUGFyc2VyIiwiUmVuZGVyZXIiLCJUZXh0UmVuZGVyZXIiLCJMZXhlciIsIlRva2VuaXplciIsIkhvb2tzIiwidXNlIiwiY2FsbGJhY2siLCJ2YWx1ZXMiLCJjb25jYXQiLCJ0YWJsZVRva2VuIiwibGlzdFRva2VuIiwiY2hpbGRUb2tlbnMiLCJmbGF0IiwicGFjayIsIm9wdHMiLCJleHQiLCJwcmV2UmVuZGVyZXIiLCJhcHBseSIsImV4dExldmVsIiwicHJvcCIsInJlbmRlcmVyUHJvcCIsInJlbmRlcmVyRnVuYyIsInRva2VuaXplclByb3AiLCJ0b2tlbml6ZXJGdW5jIiwicHJldlRva2VuaXplciIsImhvb2tzUHJvcCIsImhvb2tzRnVuYyIsInByZXZIb29rIiwiaGFzIiwiYXJnIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwicGFja1dhbGt0b2tlbnMiLCJibG9ja1R5cGUiLCJvcmlnT3B0IiwidGhyb3dFcnJvciIsIm9uRXJyb3IiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImFsbCIsImNhdGNoIiwiZSIsIm1lc3NhZ2UiLCJtc2ciLCJyZWplY3QiLCJtYXJrZWRJbnN0YW5jZSIsIm1hcmtlZCIsImdldERlZmF1bHRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/marked/lib/marked.esm.js\n");

/***/ })

};
;