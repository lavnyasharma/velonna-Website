"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@glidejs";
exports.ids = ["vendor-chunks/@glidejs"];
exports.modules = {

/***/ "(ssr)/./node_modules/@glidejs/glide/dist/glide.esm.js":
/*!*******************************************************!*\
  !*** ./node_modules/@glidejs/glide/dist/glide.esm.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Glide)\n/* harmony export */ });\n/*!\n * Glide.js v3.6.0\n * (c) 2013-2022 Jędrzej Chałubek (https://github.com/jedrzejchalubek/)\n * Released under the MIT License.\n */ function _typeof(obj) {\n    \"@babel/helpers - typeof\";\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function(obj) {\n            return typeof obj;\n        };\n    } else {\n        _typeof = function(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n    }\n    return _typeof(obj);\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf(this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn(this, result);\n    };\n}\nfunction _superPropBase(object, property) {\n    while(!Object.prototype.hasOwnProperty.call(object, property)){\n        object = _getPrototypeOf(object);\n        if (object === null) break;\n    }\n    return object;\n}\nfunction _get() {\n    if (typeof Reflect !== \"undefined\" && Reflect.get) {\n        _get = Reflect.get;\n    } else {\n        _get = function _get(target, property, receiver) {\n            var base = _superPropBase(target, property);\n            if (!base) return;\n            var desc = Object.getOwnPropertyDescriptor(base, property);\n            if (desc.get) {\n                return desc.get.call(arguments.length < 3 ? target : receiver);\n            }\n            return desc.value;\n        };\n    }\n    return _get.apply(this, arguments);\n}\nvar defaults = {\n    /**\n   * Type of the movement.\n   *\n   * Available types:\n   * `slider` - Rewinds slider to the start/end when it reaches the first or last slide.\n   * `carousel` - Changes slides without starting over when it reaches the first or last slide.\n   *\n   * @type {String}\n   */ type: \"slider\",\n    /**\n   * Start at specific slide number defined with zero-based index.\n   *\n   * @type {Number}\n   */ startAt: 0,\n    /**\n   * A number of slides visible on the single viewport.\n   *\n   * @type {Number}\n   */ perView: 1,\n    /**\n   * Focus currently active slide at a specified position in the track.\n   *\n   * Available inputs:\n   * `center` - Current slide will be always focused at the center of a track.\n   * `0,1,2,3...` - Current slide will be focused on the specified zero-based index.\n   *\n   * @type {String|Number}\n   */ focusAt: 0,\n    /**\n   * A size of the gap added between slides.\n   *\n   * @type {Number}\n   */ gap: 10,\n    /**\n   * Change slides after a specified interval. Use `false` for turning off autoplay.\n   *\n   * @type {Number|Boolean}\n   */ autoplay: false,\n    /**\n   * Stop autoplay on mouseover event.\n   *\n   * @type {Boolean}\n   */ hoverpause: true,\n    /**\n   * Allow for changing slides with left and right keyboard arrows.\n   *\n   * @type {Boolean}\n   */ keyboard: true,\n    /**\n   * Stop running `perView` number of slides from the end. Use this\n   * option if you don't want to have an empty space after\n   * a slider. Works only with `slider` type and a\n   * non-centered `focusAt` setting.\n   *\n   * @type {Boolean}\n   */ bound: false,\n    /**\n   * Minimal swipe distance needed to change the slide. Use `false` for turning off a swiping.\n   *\n   * @type {Number|Boolean}\n   */ swipeThreshold: 80,\n    /**\n   * Minimal mouse drag distance needed to change the slide. Use `false` for turning off a dragging.\n   *\n   * @type {Number|Boolean}\n   */ dragThreshold: 120,\n    /**\n   * A number of slides moved on single swipe.\n   *\n   * Available types:\n   * `` - Moves slider by one slide per swipe\n   * `|` - Moves slider between views per swipe (number of slides defined in `perView` options)\n   *\n   * @type {String}\n   */ perSwipe: \"\",\n    /**\n   * Moving distance ratio of the slides on a swiping and dragging.\n   *\n   * @type {Number}\n   */ touchRatio: 0.5,\n    /**\n   * Angle required to activate slides moving on swiping or dragging.\n   *\n   * @type {Number}\n   */ touchAngle: 45,\n    /**\n   * Duration of the animation in milliseconds.\n   *\n   * @type {Number}\n   */ animationDuration: 400,\n    /**\n   * Allows looping the `slider` type. Slider will rewind to the first/last slide when it's at the start/end.\n   *\n   * @type {Boolean}\n   */ rewind: true,\n    /**\n   * Duration of the rewinding animation of the `slider` type in milliseconds.\n   *\n   * @type {Number}\n   */ rewindDuration: 800,\n    /**\n   * Easing function for the animation.\n   *\n   * @type {String}\n   */ animationTimingFunc: \"cubic-bezier(.165, .840, .440, 1)\",\n    /**\n   * Wait for the animation to finish until the next user input can be processed\n   *\n   * @type {boolean}\n   */ waitForTransition: true,\n    /**\n   * Throttle costly events at most once per every wait milliseconds.\n   *\n   * @type {Number}\n   */ throttle: 10,\n    /**\n   * Moving direction mode.\n   *\n   * Available inputs:\n   * - 'ltr' - left to right movement,\n   * - 'rtl' - right to left movement.\n   *\n   * @type {String}\n   */ direction: \"ltr\",\n    /**\n   * The distance value of the next and previous viewports which\n   * have to peek in the current view. Accepts number and\n   * pixels as a string. Left and right peeking can be\n   * set up separately with a directions object.\n   *\n   * For example:\n   * `100` - Peek 100px on the both sides.\n   * { before: 100, after: 50 }` - Peek 100px on the left side and 50px on the right side.\n   *\n   * @type {Number|String|Object}\n   */ peek: 0,\n    /**\n   * Defines how many clones of current viewport will be generated.\n   *\n   * @type {Number}\n   */ cloningRatio: 1,\n    /**\n   * Collection of options applied at specified media breakpoints.\n   * For example: display two slides per view under 800px.\n   * `{\n   *   '800px': {\n   *     perView: 2\n   *   }\n   * }`\n   */ breakpoints: {},\n    /**\n   * Collection of internally used HTML classes.\n   *\n   * @todo Refactor `slider` and `carousel` properties to single `type: { slider: '', carousel: '' }` object\n   * @type {Object}\n   */ classes: {\n        swipeable: \"glide--swipeable\",\n        dragging: \"glide--dragging\",\n        direction: {\n            ltr: \"glide--ltr\",\n            rtl: \"glide--rtl\"\n        },\n        type: {\n            slider: \"glide--slider\",\n            carousel: \"glide--carousel\"\n        },\n        slide: {\n            clone: \"glide__slide--clone\",\n            active: \"glide__slide--active\"\n        },\n        arrow: {\n            disabled: \"glide__arrow--disabled\"\n        },\n        nav: {\n            active: \"glide__bullet--active\"\n        }\n    }\n};\n/**\n * Outputs warning message to the bowser console.\n *\n * @param  {String} msg\n * @return {Void}\n */ function warn(msg) {\n    console.error(\"[Glide warn]: \".concat(msg));\n}\n/**\n * Converts value entered as number\n * or string to integer value.\n *\n * @param {String} value\n * @returns {Number}\n */ function toInt(value) {\n    return parseInt(value);\n}\n/**\n * Converts value entered as number\n * or string to flat value.\n *\n * @param {String} value\n * @returns {Number}\n */ function toFloat(value) {\n    return parseFloat(value);\n}\n/**\n * Indicates whether the specified value is a string.\n *\n * @param  {*}   value\n * @return {Boolean}\n */ function isString(value) {\n    return typeof value === \"string\";\n}\n/**\n * Indicates whether the specified value is an object.\n *\n * @param  {*} value\n * @return {Boolean}\n *\n * @see https://github.com/jashkenas/underscore\n */ function isObject(value) {\n    var type = _typeof(value);\n    return type === \"function\" || type === \"object\" && !!value; // eslint-disable-line no-mixed-operators\n}\n/**\n * Indicates whether the specified value is a function.\n *\n * @param  {*} value\n * @return {Boolean}\n */ function isFunction(value) {\n    return typeof value === \"function\";\n}\n/**\n * Indicates whether the specified value is undefined.\n *\n * @param  {*} value\n * @return {Boolean}\n */ function isUndefined(value) {\n    return typeof value === \"undefined\";\n}\n/**\n * Indicates whether the specified value is an array.\n *\n * @param  {*} value\n * @return {Boolean}\n */ function isArray(value) {\n    return value.constructor === Array;\n}\n/**\n * Creates and initializes specified collection of extensions.\n * Each extension receives access to instance of glide and rest of components.\n *\n * @param {Object} glide\n * @param {Object} extensions\n *\n * @returns {Object}\n */ function mount(glide, extensions, events) {\n    var components = {};\n    for(var name in extensions){\n        if (isFunction(extensions[name])) {\n            components[name] = extensions[name](glide, components, events);\n        } else {\n            warn(\"Extension must be a function\");\n        }\n    }\n    for(var _name in components){\n        if (isFunction(components[_name].mount)) {\n            components[_name].mount();\n        }\n    }\n    return components;\n}\n/**\n * Defines getter and setter property on the specified object.\n *\n * @param  {Object} obj         Object where property has to be defined.\n * @param  {String} prop        Name of the defined property.\n * @param  {Object} definition  Get and set definitions for the property.\n * @return {Void}\n */ function define(obj, prop, definition) {\n    Object.defineProperty(obj, prop, definition);\n}\n/**\n * Sorts aphabetically object keys.\n *\n * @param  {Object} obj\n * @return {Object}\n */ function sortKeys(obj) {\n    return Object.keys(obj).sort().reduce(function(r, k) {\n        r[k] = obj[k];\n        return r[k], r;\n    }, {});\n}\n/**\n * Merges passed settings object with default options.\n *\n * @param  {Object} defaults\n * @param  {Object} settings\n * @return {Object}\n */ function mergeOptions(defaults, settings) {\n    var options = Object.assign({}, defaults, settings); // `Object.assign` do not deeply merge objects, so we\n    // have to do it manually for every nested object\n    // in options. Although it does not look smart,\n    // it's smaller and faster than some fancy\n    // merging deep-merge algorithm script.\n    if (settings.hasOwnProperty(\"classes\")) {\n        options.classes = Object.assign({}, defaults.classes, settings.classes);\n        if (settings.classes.hasOwnProperty(\"direction\")) {\n            options.classes.direction = Object.assign({}, defaults.classes.direction, settings.classes.direction);\n        }\n        if (settings.classes.hasOwnProperty(\"type\")) {\n            options.classes.type = Object.assign({}, defaults.classes.type, settings.classes.type);\n        }\n        if (settings.classes.hasOwnProperty(\"slide\")) {\n            options.classes.slide = Object.assign({}, defaults.classes.slide, settings.classes.slide);\n        }\n        if (settings.classes.hasOwnProperty(\"arrow\")) {\n            options.classes.arrow = Object.assign({}, defaults.classes.arrow, settings.classes.arrow);\n        }\n        if (settings.classes.hasOwnProperty(\"nav\")) {\n            options.classes.nav = Object.assign({}, defaults.classes.nav, settings.classes.nav);\n        }\n    }\n    if (settings.hasOwnProperty(\"breakpoints\")) {\n        options.breakpoints = Object.assign({}, defaults.breakpoints, settings.breakpoints);\n    }\n    return options;\n}\nvar EventsBus = /*#__PURE__*/ function() {\n    /**\n   * Construct a EventBus instance.\n   *\n   * @param {Object} events\n   */ function EventsBus() {\n        var events = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        _classCallCheck(this, EventsBus);\n        this.events = events;\n        this.hop = events.hasOwnProperty;\n    }\n    /**\n   * Adds listener to the specifed event.\n   *\n   * @param {String|Array} event\n   * @param {Function} handler\n   */ _createClass(EventsBus, [\n        {\n            key: \"on\",\n            value: function on(event, handler) {\n                if (isArray(event)) {\n                    for(var i = 0; i < event.length; i++){\n                        this.on(event[i], handler);\n                    }\n                    return;\n                } // Create the event's object if not yet created\n                if (!this.hop.call(this.events, event)) {\n                    this.events[event] = [];\n                } // Add the handler to queue\n                var index = this.events[event].push(handler) - 1; // Provide handle back for removal of event\n                return {\n                    remove: function remove() {\n                        delete this.events[event][index];\n                    }\n                };\n            }\n        },\n        {\n            key: \"emit\",\n            value: function emit(event, context) {\n                if (isArray(event)) {\n                    for(var i = 0; i < event.length; i++){\n                        this.emit(event[i], context);\n                    }\n                    return;\n                } // If the event doesn't exist, or there's no handlers in queue, just leave\n                if (!this.hop.call(this.events, event)) {\n                    return;\n                } // Cycle through events queue, fire!\n                this.events[event].forEach(function(item) {\n                    item(context || {});\n                });\n            }\n        }\n    ]);\n    return EventsBus;\n}();\nvar Glide$1 = /*#__PURE__*/ function() {\n    /**\r\n   * Construct glide.\r\n   *\r\n   * @param  {String} selector\r\n   * @param  {Object} options\r\n   */ function Glide(selector) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        _classCallCheck(this, Glide);\n        this._c = {};\n        this._t = [];\n        this._e = new EventsBus();\n        this.disabled = false;\n        this.selector = selector;\n        this.settings = mergeOptions(defaults, options);\n        this.index = this.settings.startAt;\n    }\n    /**\r\n   * Initializes glide.\r\n   *\r\n   * @param {Object} extensions Collection of extensions to initialize.\r\n   * @return {Glide}\r\n   */ _createClass(Glide, [\n        {\n            key: \"mount\",\n            value: function mount$1() {\n                var extensions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n                this._e.emit(\"mount.before\");\n                if (isObject(extensions)) {\n                    this._c = mount(this, extensions, this._e);\n                } else {\n                    warn(\"You need to provide a object on `mount()`\");\n                }\n                this._e.emit(\"mount.after\");\n                return this;\n            }\n        },\n        {\n            key: \"mutate\",\n            value: function mutate() {\n                var transformers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n                if (isArray(transformers)) {\n                    this._t = transformers;\n                } else {\n                    warn(\"You need to provide a array on `mutate()`\");\n                }\n                return this;\n            }\n        },\n        {\n            key: \"update\",\n            value: function update() {\n                var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n                this.settings = mergeOptions(this.settings, settings);\n                if (settings.hasOwnProperty(\"startAt\")) {\n                    this.index = settings.startAt;\n                }\n                this._e.emit(\"update\");\n                return this;\n            }\n        },\n        {\n            key: \"go\",\n            value: function go(pattern) {\n                this._c.Run.make(pattern);\n                return this;\n            }\n        },\n        {\n            key: \"move\",\n            value: function move(distance) {\n                this._c.Transition.disable();\n                this._c.Move.make(distance);\n                return this;\n            }\n        },\n        {\n            key: \"destroy\",\n            value: function destroy() {\n                this._e.emit(\"destroy\");\n                return this;\n            }\n        },\n        {\n            key: \"play\",\n            value: function play() {\n                var interval = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n                if (interval) {\n                    this.settings.autoplay = interval;\n                }\n                this._e.emit(\"play\");\n                return this;\n            }\n        },\n        {\n            key: \"pause\",\n            value: function pause() {\n                this._e.emit(\"pause\");\n                return this;\n            }\n        },\n        {\n            key: \"disable\",\n            value: function disable() {\n                this.disabled = true;\n                return this;\n            }\n        },\n        {\n            key: \"enable\",\n            value: function enable() {\n                this.disabled = false;\n                return this;\n            }\n        },\n        {\n            key: \"on\",\n            value: function on(event, handler) {\n                this._e.on(event, handler);\n                return this;\n            }\n        },\n        {\n            key: \"isType\",\n            value: function isType(name) {\n                return this.settings.type === name;\n            }\n        },\n        {\n            key: \"settings\",\n            get: function get() {\n                return this._o;\n            },\n            set: function set(o) {\n                if (isObject(o)) {\n                    this._o = o;\n                } else {\n                    warn(\"Options must be an `object` instance.\");\n                }\n            }\n        },\n        {\n            key: \"index\",\n            get: function get() {\n                return this._i;\n            },\n            set: function set(i) {\n                this._i = toInt(i);\n            }\n        },\n        {\n            key: \"type\",\n            get: function get() {\n                return this.settings.type;\n            }\n        },\n        {\n            key: \"disabled\",\n            get: function get() {\n                return this._d;\n            },\n            set: function set(status) {\n                this._d = !!status;\n            }\n        }\n    ]);\n    return Glide;\n}();\nfunction Run(Glide, Components, Events) {\n    var Run = {\n        /**\n     * Initializes autorunning of the glide.\n     *\n     * @return {Void}\n     */ mount: function mount() {\n            this._o = false;\n        },\n        /**\n     * Makes glides running based on the passed moving schema.\n     *\n     * @param {String} move\n     */ make: function make(move) {\n            var _this = this;\n            if (!Glide.disabled) {\n                !Glide.settings.waitForTransition || Glide.disable();\n                this.move = move;\n                Events.emit(\"run.before\", this.move);\n                this.calculate();\n                Events.emit(\"run\", this.move);\n                Components.Transition.after(function() {\n                    if (_this.isStart()) {\n                        Events.emit(\"run.start\", _this.move);\n                    }\n                    if (_this.isEnd()) {\n                        Events.emit(\"run.end\", _this.move);\n                    }\n                    if (_this.isOffset()) {\n                        _this._o = false;\n                        Events.emit(\"run.offset\", _this.move);\n                    }\n                    Events.emit(\"run.after\", _this.move);\n                    Glide.enable();\n                });\n            }\n        },\n        /**\n     * Calculates current index based on defined move.\n     *\n     * @return {Number|Undefined}\n     */ calculate: function calculate() {\n            var move = this.move, length = this.length;\n            var steps = move.steps, direction = move.direction; // By default assume that size of view is equal to one slide\n            var viewSize = 1; // While direction is `=` we want jump to\n            // a specified index described in steps.\n            if (direction === \"=\") {\n                // Check if bound is true, \n                // as we want to avoid whitespaces.\n                if (Glide.settings.bound && toInt(steps) > length) {\n                    Glide.index = length;\n                    return;\n                }\n                Glide.index = steps;\n                return;\n            } // When pattern is equal to `>>` we want\n            // fast forward to the last slide.\n            if (direction === \">\" && steps === \">\") {\n                Glide.index = length;\n                return;\n            } // When pattern is equal to `<<` we want\n            // fast forward to the first slide.\n            if (direction === \"<\" && steps === \"<\") {\n                Glide.index = 0;\n                return;\n            } // pagination movement\n            if (direction === \"|\") {\n                viewSize = Glide.settings.perView || 1;\n            } // we are moving forward\n            if (direction === \">\" || direction === \"|\" && steps === \">\") {\n                var index = calculateForwardIndex(viewSize);\n                if (index > length) {\n                    this._o = true;\n                }\n                Glide.index = normalizeForwardIndex(index, viewSize);\n                return;\n            } // we are moving backward\n            if (direction === \"<\" || direction === \"|\" && steps === \"<\") {\n                var _index = calculateBackwardIndex(viewSize);\n                if (_index < 0) {\n                    this._o = true;\n                }\n                Glide.index = normalizeBackwardIndex(_index, viewSize);\n                return;\n            }\n            warn(\"Invalid direction pattern [\".concat(direction).concat(steps, \"] has been used\"));\n        },\n        /**\n     * Checks if we are on the first slide.\n     *\n     * @return {Boolean}\n     */ isStart: function isStart() {\n            return Glide.index <= 0;\n        },\n        /**\n     * Checks if we are on the last slide.\n     *\n     * @return {Boolean}\n     */ isEnd: function isEnd() {\n            return Glide.index >= this.length;\n        },\n        /**\n     * Checks if we are making a offset run.\n     *\n     * @param {String} direction\n     * @return {Boolean}\n     */ isOffset: function isOffset() {\n            var direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n            if (!direction) {\n                return this._o;\n            }\n            if (!this._o) {\n                return false;\n            } // did we view to the right?\n            if (direction === \"|>\") {\n                return this.move.direction === \"|\" && this.move.steps === \">\";\n            } // did we view to the left?\n            if (direction === \"|<\") {\n                return this.move.direction === \"|\" && this.move.steps === \"<\";\n            }\n            return this.move.direction === direction;\n        },\n        /**\n     * Checks if bound mode is active\n     *\n     * @return {Boolean}\n     */ isBound: function isBound() {\n            return Glide.isType(\"slider\") && Glide.settings.focusAt !== \"center\" && Glide.settings.bound;\n        }\n    };\n    /**\n   * Returns index value to move forward/to the right\n   *\n   * @param viewSize\n   * @returns {Number}\n   */ function calculateForwardIndex(viewSize) {\n        var index = Glide.index;\n        if (Glide.isType(\"carousel\")) {\n            return index + viewSize;\n        }\n        return index + (viewSize - index % viewSize);\n    }\n    /**\n   * Normalizes the given forward index based on glide settings, preventing it to exceed certain boundaries\n   *\n   * @param index\n   * @param length\n   * @param viewSize\n   * @returns {Number}\n   */ function normalizeForwardIndex(index, viewSize) {\n        var length = Run.length;\n        if (index <= length) {\n            return index;\n        }\n        if (Glide.isType(\"carousel\")) {\n            return index - (length + 1);\n        }\n        if (Glide.settings.rewind) {\n            // bound does funny things with the length, therefor we have to be certain\n            // that we are on the last possible index value given by bound\n            if (Run.isBound() && !Run.isEnd()) {\n                return length;\n            }\n            return 0;\n        }\n        if (Run.isBound()) {\n            return length;\n        }\n        return Math.floor(length / viewSize) * viewSize;\n    }\n    /**\n   * Calculates index value to move backward/to the left\n   *\n   * @param viewSize\n   * @returns {Number}\n   */ function calculateBackwardIndex(viewSize) {\n        var index = Glide.index;\n        if (Glide.isType(\"carousel\")) {\n            return index - viewSize;\n        } // ensure our back navigation results in the same index as a forward navigation\n        // to experience a homogeneous paging\n        var view = Math.ceil(index / viewSize);\n        return (view - 1) * viewSize;\n    }\n    /**\n   * Normalizes the given backward index based on glide settings, preventing it to exceed certain boundaries\n   *\n   * @param index\n   * @param length\n   * @param viewSize\n   * @returns {*}\n   */ function normalizeBackwardIndex(index, viewSize) {\n        var length = Run.length;\n        if (index >= 0) {\n            return index;\n        }\n        if (Glide.isType(\"carousel\")) {\n            return index + (length + 1);\n        }\n        if (Glide.settings.rewind) {\n            // bound does funny things with the length, therefor we have to be certain\n            // that we are on first possible index value before we to rewind to the length given by bound\n            if (Run.isBound() && Run.isStart()) {\n                return length;\n            }\n            return Math.floor(length / viewSize) * viewSize;\n        }\n        return 0;\n    }\n    define(Run, \"move\", {\n        /**\n     * Gets value of the move schema.\n     *\n     * @returns {Object}\n     */ get: function get() {\n            return this._m;\n        },\n        /**\n     * Sets value of the move schema.\n     *\n     * @returns {Object}\n     */ set: function set(value) {\n            var step = value.substr(1);\n            this._m = {\n                direction: value.substr(0, 1),\n                steps: step ? toInt(step) ? toInt(step) : step : 0\n            };\n        }\n    });\n    define(Run, \"length\", {\n        /**\n     * Gets value of the running distance based\n     * on zero-indexing number of slides.\n     *\n     * @return {Number}\n     */ get: function get() {\n            var settings = Glide.settings;\n            var length = Components.Html.slides.length; // If the `bound` option is active, a maximum running distance should be\n            // reduced by `perView` and `focusAt` settings. Running distance\n            // should end before creating an empty space after instance.\n            if (this.isBound()) {\n                return length - 1 - (toInt(settings.perView) - 1) + toInt(settings.focusAt);\n            }\n            return length - 1;\n        }\n    });\n    define(Run, \"offset\", {\n        /**\n     * Gets status of the offsetting flag.\n     *\n     * @return {Boolean}\n     */ get: function get() {\n            return this._o;\n        }\n    });\n    return Run;\n}\n/**\n * Returns a current time.\n *\n * @return {Number}\n */ function now() {\n    return new Date().getTime();\n}\n/**\n * Returns a function, that, when invoked, will only be triggered\n * at most once during a given window of time.\n *\n * @param {Function} func\n * @param {Number} wait\n * @param {Object=} options\n * @return {Function}\n *\n * @see https://github.com/jashkenas/underscore\n */ function throttle(func, wait, options) {\n    var timeout, context, args, result;\n    var previous = 0;\n    if (!options) options = {};\n    var later = function later() {\n        previous = options.leading === false ? 0 : now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n    };\n    var throttled = function throttled() {\n        var at = now();\n        if (!previous && options.leading === false) previous = at;\n        var remaining = wait - (at - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            previous = at;\n            result = func.apply(context, args);\n            if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) {\n            timeout = setTimeout(later, remaining);\n        }\n        return result;\n    };\n    throttled.cancel = function() {\n        clearTimeout(timeout);\n        previous = 0;\n        timeout = context = args = null;\n    };\n    return throttled;\n}\nvar MARGIN_TYPE = {\n    ltr: [\n        \"marginLeft\",\n        \"marginRight\"\n    ],\n    rtl: [\n        \"marginRight\",\n        \"marginLeft\"\n    ]\n};\nfunction Gaps(Glide, Components, Events) {\n    var Gaps = {\n        /**\n     * Applies gaps between slides. First and last\n     * slides do not receive it's edge margins.\n     *\n     * @param {HTMLCollection} slides\n     * @return {Void}\n     */ apply: function apply(slides) {\n            for(var i = 0, len = slides.length; i < len; i++){\n                var style = slides[i].style;\n                var direction = Components.Direction.value;\n                if (i !== 0) {\n                    style[MARGIN_TYPE[direction][0]] = \"\".concat(this.value / 2, \"px\");\n                } else {\n                    style[MARGIN_TYPE[direction][0]] = \"\";\n                }\n                if (i !== slides.length - 1) {\n                    style[MARGIN_TYPE[direction][1]] = \"\".concat(this.value / 2, \"px\");\n                } else {\n                    style[MARGIN_TYPE[direction][1]] = \"\";\n                }\n            }\n        },\n        /**\n     * Removes gaps from the slides.\n     *\n     * @param {HTMLCollection} slides\n     * @returns {Void}\n    */ remove: function remove(slides) {\n            for(var i = 0, len = slides.length; i < len; i++){\n                var style = slides[i].style;\n                style.marginLeft = \"\";\n                style.marginRight = \"\";\n            }\n        }\n    };\n    define(Gaps, \"value\", {\n        /**\n     * Gets value of the gap.\n     *\n     * @returns {Number}\n     */ get: function get() {\n            return toInt(Glide.settings.gap);\n        }\n    });\n    define(Gaps, \"grow\", {\n        /**\n     * Gets additional dimensions value caused by gaps.\n     * Used to increase width of the slides wrapper.\n     *\n     * @returns {Number}\n     */ get: function get() {\n            return Gaps.value * Components.Sizes.length;\n        }\n    });\n    define(Gaps, \"reductor\", {\n        /**\n     * Gets reduction value caused by gaps.\n     * Used to subtract width of the slides.\n     *\n     * @returns {Number}\n     */ get: function get() {\n            var perView = Glide.settings.perView;\n            return Gaps.value * (perView - 1) / perView;\n        }\n    });\n    /**\n   * Apply calculated gaps:\n   * - after building, so slides (including clones) will receive proper margins\n   * - on updating via API, to recalculate gaps with new options\n   */ Events.on([\n        \"build.after\",\n        \"update\"\n    ], throttle(function() {\n        Gaps.apply(Components.Html.wrapper.children);\n    }, 30));\n    /**\n   * Remove gaps:\n   * - on destroying to bring markup to its inital state\n   */ Events.on(\"destroy\", function() {\n        Gaps.remove(Components.Html.wrapper.children);\n    });\n    return Gaps;\n}\n/**\n * Finds siblings nodes of the passed node.\n *\n * @param  {Element} node\n * @return {Array}\n */ function siblings(node) {\n    if (node && node.parentNode) {\n        var n = node.parentNode.firstChild;\n        var matched = [];\n        for(; n; n = n.nextSibling){\n            if (n.nodeType === 1 && n !== node) {\n                matched.push(n);\n            }\n        }\n        return matched;\n    }\n    return [];\n}\n/**\n * Checks if passed node exist and is a valid element.\n *\n * @param  {Element} node\n * @return {Boolean}\n */ function exist(node) {\n    if (node && node instanceof window.HTMLElement) {\n        return true;\n    }\n    return false;\n}\n/**\n * Coerces a NodeList to an Array.\n *\n * @param  {NodeList} nodeList\n * @return {Array}\n */ function toArray(nodeList) {\n    return Array.prototype.slice.call(nodeList);\n}\nvar TRACK_SELECTOR = '[data-glide-el=\"track\"]';\nfunction Html(Glide, Components, Events) {\n    var Html = {\n        /**\n     * Setup slider HTML nodes.\n     *\n     * @param {Glide} glide\n     */ mount: function mount() {\n            this.root = Glide.selector;\n            this.track = this.root.querySelector(TRACK_SELECTOR);\n            this.collectSlides();\n        },\n        /**\n     * Collect slides\n     */ collectSlides: function collectSlides() {\n            this.slides = toArray(this.wrapper.children).filter(function(slide) {\n                return !slide.classList.contains(Glide.settings.classes.slide.clone);\n            });\n        }\n    };\n    define(Html, \"root\", {\n        /**\n     * Gets node of the glide main element.\n     *\n     * @return {Object}\n     */ get: function get() {\n            return Html._r;\n        },\n        /**\n     * Sets node of the glide main element.\n     *\n     * @return {Object}\n     */ set: function set(r) {\n            if (isString(r)) {\n                r = document.querySelector(r);\n            }\n            if (exist(r)) {\n                Html._r = r;\n            } else {\n                warn(\"Root element must be a existing Html node\");\n            }\n        }\n    });\n    define(Html, \"track\", {\n        /**\n     * Gets node of the glide track with slides.\n     *\n     * @return {Object}\n     */ get: function get() {\n            return Html._t;\n        },\n        /**\n     * Sets node of the glide track with slides.\n     *\n     * @return {Object}\n     */ set: function set(t) {\n            if (exist(t)) {\n                Html._t = t;\n            } else {\n                warn(\"Could not find track element. Please use \".concat(TRACK_SELECTOR, \" attribute.\"));\n            }\n        }\n    });\n    define(Html, \"wrapper\", {\n        /**\n     * Gets node of the slides wrapper.\n     *\n     * @return {Object}\n     */ get: function get() {\n            return Html.track.children[0];\n        }\n    });\n    /**\n   * Add/remove/reorder dynamic slides\n   */ Events.on(\"update\", function() {\n        Html.collectSlides();\n    });\n    return Html;\n}\nfunction Peek(Glide, Components, Events) {\n    var Peek = {\n        /**\n     * Setups how much to peek based on settings.\n     *\n     * @return {Void}\n     */ mount: function mount() {\n            this.value = Glide.settings.peek;\n        }\n    };\n    define(Peek, \"value\", {\n        /**\n     * Gets value of the peek.\n     *\n     * @returns {Number|Object}\n     */ get: function get() {\n            return Peek._v;\n        },\n        /**\n     * Sets value of the peek.\n     *\n     * @param {Number|Object} value\n     * @return {Void}\n     */ set: function set(value) {\n            if (isObject(value)) {\n                value.before = toInt(value.before);\n                value.after = toInt(value.after);\n            } else {\n                value = toInt(value);\n            }\n            Peek._v = value;\n        }\n    });\n    define(Peek, \"reductor\", {\n        /**\n     * Gets reduction value caused by peek.\n     *\n     * @returns {Number}\n     */ get: function get() {\n            var value = Peek.value;\n            var perView = Glide.settings.perView;\n            if (isObject(value)) {\n                return value.before / perView + value.after / perView;\n            }\n            return value * 2 / perView;\n        }\n    });\n    /**\n   * Recalculate peeking sizes on:\n   * - when resizing window to update to proper percents\n   */ Events.on([\n        \"resize\",\n        \"update\"\n    ], function() {\n        Peek.mount();\n    });\n    return Peek;\n}\nfunction Move(Glide, Components, Events) {\n    var Move = {\n        /**\n     * Constructs move component.\n     *\n     * @returns {Void}\n     */ mount: function mount() {\n            this._o = 0;\n        },\n        /**\n     * Calculates a movement value based on passed offset and currently active index.\n     *\n     * @param  {Number} offset\n     * @return {Void}\n     */ make: function make() {\n            var _this = this;\n            var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n            this.offset = offset;\n            Events.emit(\"move\", {\n                movement: this.value\n            });\n            Components.Transition.after(function() {\n                Events.emit(\"move.after\", {\n                    movement: _this.value\n                });\n            });\n        }\n    };\n    define(Move, \"offset\", {\n        /**\n     * Gets an offset value used to modify current translate.\n     *\n     * @return {Object}\n     */ get: function get() {\n            return Move._o;\n        },\n        /**\n     * Sets an offset value used to modify current translate.\n     *\n     * @return {Object}\n     */ set: function set(value) {\n            Move._o = !isUndefined(value) ? toInt(value) : 0;\n        }\n    });\n    define(Move, \"translate\", {\n        /**\n     * Gets a raw movement value.\n     *\n     * @return {Number}\n     */ get: function get() {\n            return Components.Sizes.slideWidth * Glide.index;\n        }\n    });\n    define(Move, \"value\", {\n        /**\n     * Gets an actual movement value corrected by offset.\n     *\n     * @return {Number}\n     */ get: function get() {\n            var offset = this.offset;\n            var translate = this.translate;\n            if (Components.Direction.is(\"rtl\")) {\n                return translate + offset;\n            }\n            return translate - offset;\n        }\n    });\n    /**\n   * Make movement to proper slide on:\n   * - before build, so glide will start at `startAt` index\n   * - on each standard run to move to newly calculated index\n   */ Events.on([\n        \"build.before\",\n        \"run\"\n    ], function() {\n        Move.make();\n    });\n    return Move;\n}\nfunction Sizes(Glide, Components, Events) {\n    var Sizes = {\n        /**\n     * Setups dimensions of slides.\n     *\n     * @return {Void}\n     */ setupSlides: function setupSlides() {\n            var width = \"\".concat(this.slideWidth, \"px\");\n            var slides = Components.Html.slides;\n            for(var i = 0; i < slides.length; i++){\n                slides[i].style.width = width;\n            }\n        },\n        /**\n     * Setups dimensions of slides wrapper.\n     *\n     * @return {Void}\n     */ setupWrapper: function setupWrapper() {\n            Components.Html.wrapper.style.width = \"\".concat(this.wrapperSize, \"px\");\n        },\n        /**\n     * Removes applied styles from HTML elements.\n     *\n     * @returns {Void}\n     */ remove: function remove() {\n            var slides = Components.Html.slides;\n            for(var i = 0; i < slides.length; i++){\n                slides[i].style.width = \"\";\n            }\n            Components.Html.wrapper.style.width = \"\";\n        }\n    };\n    define(Sizes, \"length\", {\n        /**\n     * Gets count number of the slides.\n     *\n     * @return {Number}\n     */ get: function get() {\n            return Components.Html.slides.length;\n        }\n    });\n    define(Sizes, \"width\", {\n        /**\n     * Gets width value of the slider (visible area).\n     *\n     * @return {Number}\n     */ get: function get() {\n            return Components.Html.track.offsetWidth;\n        }\n    });\n    define(Sizes, \"wrapperSize\", {\n        /**\n     * Gets size of the slides wrapper.\n     *\n     * @return {Number}\n     */ get: function get() {\n            return Sizes.slideWidth * Sizes.length + Components.Gaps.grow + Components.Clones.grow;\n        }\n    });\n    define(Sizes, \"slideWidth\", {\n        /**\n     * Gets width value of a single slide.\n     *\n     * @return {Number}\n     */ get: function get() {\n            return Sizes.width / Glide.settings.perView - Components.Peek.reductor - Components.Gaps.reductor;\n        }\n    });\n    /**\n   * Apply calculated glide's dimensions:\n   * - before building, so other dimensions (e.g. translate) will be calculated propertly\n   * - when resizing window to recalculate sildes dimensions\n   * - on updating via API, to calculate dimensions based on new options\n   */ Events.on([\n        \"build.before\",\n        \"resize\",\n        \"update\"\n    ], function() {\n        Sizes.setupSlides();\n        Sizes.setupWrapper();\n    });\n    /**\n   * Remove calculated glide's dimensions:\n   * - on destoting to bring markup to its inital state\n   */ Events.on(\"destroy\", function() {\n        Sizes.remove();\n    });\n    return Sizes;\n}\nfunction Build(Glide, Components, Events) {\n    var Build = {\n        /**\n     * Init glide building. Adds classes, sets\n     * dimensions and setups initial state.\n     *\n     * @return {Void}\n     */ mount: function mount() {\n            Events.emit(\"build.before\");\n            this.typeClass();\n            this.activeClass();\n            Events.emit(\"build.after\");\n        },\n        /**\n     * Adds `type` class to the glide element.\n     *\n     * @return {Void}\n     */ typeClass: function typeClass() {\n            Components.Html.root.classList.add(Glide.settings.classes.type[Glide.settings.type]);\n        },\n        /**\n     * Sets active class to current slide.\n     *\n     * @return {Void}\n     */ activeClass: function activeClass() {\n            var classes = Glide.settings.classes;\n            var slide = Components.Html.slides[Glide.index];\n            if (slide) {\n                slide.classList.add(classes.slide.active);\n                siblings(slide).forEach(function(sibling) {\n                    sibling.classList.remove(classes.slide.active);\n                });\n            }\n        },\n        /**\n     * Removes HTML classes applied at building.\n     *\n     * @return {Void}\n     */ removeClasses: function removeClasses() {\n            var _Glide$settings$class = Glide.settings.classes, type = _Glide$settings$class.type, slide = _Glide$settings$class.slide;\n            Components.Html.root.classList.remove(type[Glide.settings.type]);\n            Components.Html.slides.forEach(function(sibling) {\n                sibling.classList.remove(slide.active);\n            });\n        }\n    };\n    /**\n   * Clear building classes:\n   * - on destroying to bring HTML to its initial state\n   * - on updating to remove classes before remounting component\n   */ Events.on([\n        \"destroy\",\n        \"update\"\n    ], function() {\n        Build.removeClasses();\n    });\n    /**\n   * Remount component:\n   * - on resizing of the window to calculate new dimensions\n   * - on updating settings via API\n   */ Events.on([\n        \"resize\",\n        \"update\"\n    ], function() {\n        Build.mount();\n    });\n    /**\n   * Swap active class of current slide:\n   * - after each move to the new index\n   */ Events.on(\"move.after\", function() {\n        Build.activeClass();\n    });\n    return Build;\n}\nfunction Clones(Glide, Components, Events) {\n    var Clones = {\n        /**\n     * Create pattern map and collect slides to be cloned.\n     */ mount: function mount() {\n            this.items = [];\n            if (Glide.isType(\"carousel\")) {\n                this.items = this.collect();\n            }\n        },\n        /**\n     * Collect clones with pattern.\n     *\n     * @return {[]}\n     */ collect: function collect() {\n            var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n            var slides = Components.Html.slides;\n            var _Glide$settings = Glide.settings, perView = _Glide$settings.perView, classes = _Glide$settings.classes, cloningRatio = _Glide$settings.cloningRatio;\n            if (slides.length !== 0) {\n                var peekIncrementer = +!!Glide.settings.peek;\n                var cloneCount = perView + peekIncrementer + Math.round(perView / 2);\n                var append = slides.slice(0, cloneCount).reverse();\n                var prepend = slides.slice(cloneCount * -1);\n                for(var r = 0; r < Math.max(cloningRatio, Math.floor(perView / slides.length)); r++){\n                    for(var i = 0; i < append.length; i++){\n                        var clone = append[i].cloneNode(true);\n                        clone.classList.add(classes.slide.clone);\n                        items.push(clone);\n                    }\n                    for(var _i = 0; _i < prepend.length; _i++){\n                        var _clone = prepend[_i].cloneNode(true);\n                        _clone.classList.add(classes.slide.clone);\n                        items.unshift(_clone);\n                    }\n                }\n            }\n            return items;\n        },\n        /**\n     * Append cloned slides with generated pattern.\n     *\n     * @return {Void}\n     */ append: function append() {\n            var items = this.items;\n            var _Components$Html = Components.Html, wrapper = _Components$Html.wrapper, slides = _Components$Html.slides;\n            var half = Math.floor(items.length / 2);\n            var prepend = items.slice(0, half).reverse();\n            var append = items.slice(half * -1).reverse();\n            var width = \"\".concat(Components.Sizes.slideWidth, \"px\");\n            for(var i = 0; i < append.length; i++){\n                wrapper.appendChild(append[i]);\n            }\n            for(var _i2 = 0; _i2 < prepend.length; _i2++){\n                wrapper.insertBefore(prepend[_i2], slides[0]);\n            }\n            for(var _i3 = 0; _i3 < items.length; _i3++){\n                items[_i3].style.width = width;\n            }\n        },\n        /**\n     * Remove all cloned slides.\n     *\n     * @return {Void}\n     */ remove: function remove() {\n            var items = this.items;\n            for(var i = 0; i < items.length; i++){\n                Components.Html.wrapper.removeChild(items[i]);\n            }\n        }\n    };\n    define(Clones, \"grow\", {\n        /**\n     * Gets additional dimensions value caused by clones.\n     *\n     * @return {Number}\n     */ get: function get() {\n            return (Components.Sizes.slideWidth + Components.Gaps.value) * Clones.items.length;\n        }\n    });\n    /**\n   * Append additional slide's clones:\n   * - while glide's type is `carousel`\n   */ Events.on(\"update\", function() {\n        Clones.remove();\n        Clones.mount();\n        Clones.append();\n    });\n    /**\n   * Append additional slide's clones:\n   * - while glide's type is `carousel`\n   */ Events.on(\"build.before\", function() {\n        if (Glide.isType(\"carousel\")) {\n            Clones.append();\n        }\n    });\n    /**\n   * Remove clones HTMLElements:\n   * - on destroying, to bring HTML to its initial state\n   */ Events.on(\"destroy\", function() {\n        Clones.remove();\n    });\n    return Clones;\n}\nvar EventsBinder = /*#__PURE__*/ function() {\n    /**\n   * Construct a EventsBinder instance.\n   */ function EventsBinder() {\n        var listeners = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        _classCallCheck(this, EventsBinder);\n        this.listeners = listeners;\n    }\n    /**\n   * Adds events listeners to arrows HTML elements.\n   *\n   * @param  {String|Array} events\n   * @param  {Element|Window|Document} el\n   * @param  {Function} closure\n   * @param  {Boolean|Object} capture\n   * @return {Void}\n   */ _createClass(EventsBinder, [\n        {\n            key: \"on\",\n            value: function on(events, el, closure) {\n                var capture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n                if (isString(events)) {\n                    events = [\n                        events\n                    ];\n                }\n                for(var i = 0; i < events.length; i++){\n                    this.listeners[events[i]] = closure;\n                    el.addEventListener(events[i], this.listeners[events[i]], capture);\n                }\n            }\n        },\n        {\n            key: \"off\",\n            value: function off(events, el) {\n                var capture = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n                if (isString(events)) {\n                    events = [\n                        events\n                    ];\n                }\n                for(var i = 0; i < events.length; i++){\n                    el.removeEventListener(events[i], this.listeners[events[i]], capture);\n                }\n            }\n        },\n        {\n            key: \"destroy\",\n            value: function destroy() {\n                delete this.listeners;\n            }\n        }\n    ]);\n    return EventsBinder;\n}();\nfunction Resize(Glide, Components, Events) {\n    /**\n   * Instance of the binder for DOM Events.\n   *\n   * @type {EventsBinder}\n   */ var Binder = new EventsBinder();\n    var Resize = {\n        /**\n     * Initializes window bindings.\n     */ mount: function mount() {\n            this.bind();\n        },\n        /**\n     * Binds `rezsize` listener to the window.\n     * It's a costly event, so we are debouncing it.\n     *\n     * @return {Void}\n     */ bind: function bind() {\n            Binder.on(\"resize\", window, throttle(function() {\n                Events.emit(\"resize\");\n            }, Glide.settings.throttle));\n        },\n        /**\n     * Unbinds listeners from the window.\n     *\n     * @return {Void}\n     */ unbind: function unbind() {\n            Binder.off(\"resize\", window);\n        }\n    };\n    /**\n   * Remove bindings from window:\n   * - on destroying, to remove added EventListener\n   */ Events.on(\"destroy\", function() {\n        Resize.unbind();\n        Binder.destroy();\n    });\n    return Resize;\n}\nvar VALID_DIRECTIONS = [\n    \"ltr\",\n    \"rtl\"\n];\nvar FLIPED_MOVEMENTS = {\n    \">\": \"<\",\n    \"<\": \">\",\n    \"=\": \"=\"\n};\nfunction Direction(Glide, Components, Events) {\n    var Direction = {\n        /**\n     * Setups gap value based on settings.\n     *\n     * @return {Void}\n     */ mount: function mount() {\n            this.value = Glide.settings.direction;\n        },\n        /**\n     * Resolves pattern based on direction value\n     *\n     * @param {String} pattern\n     * @returns {String}\n     */ resolve: function resolve(pattern) {\n            var token = pattern.slice(0, 1);\n            if (this.is(\"rtl\")) {\n                return pattern.split(token).join(FLIPED_MOVEMENTS[token]);\n            }\n            return pattern;\n        },\n        /**\n     * Checks value of direction mode.\n     *\n     * @param {String} direction\n     * @returns {Boolean}\n     */ is: function is(direction) {\n            return this.value === direction;\n        },\n        /**\n     * Applies direction class to the root HTML element.\n     *\n     * @return {Void}\n     */ addClass: function addClass() {\n            Components.Html.root.classList.add(Glide.settings.classes.direction[this.value]);\n        },\n        /**\n     * Removes direction class from the root HTML element.\n     *\n     * @return {Void}\n     */ removeClass: function removeClass() {\n            Components.Html.root.classList.remove(Glide.settings.classes.direction[this.value]);\n        }\n    };\n    define(Direction, \"value\", {\n        /**\n     * Gets value of the direction.\n     *\n     * @returns {Number}\n     */ get: function get() {\n            return Direction._v;\n        },\n        /**\n     * Sets value of the direction.\n     *\n     * @param {String} value\n     * @return {Void}\n     */ set: function set(value) {\n            if (VALID_DIRECTIONS.indexOf(value) > -1) {\n                Direction._v = value;\n            } else {\n                warn(\"Direction value must be `ltr` or `rtl`\");\n            }\n        }\n    });\n    /**\n   * Clear direction class:\n   * - on destroy to bring HTML to its initial state\n   * - on update to remove class before reappling bellow\n   */ Events.on([\n        \"destroy\",\n        \"update\"\n    ], function() {\n        Direction.removeClass();\n    });\n    /**\n   * Remount component:\n   * - on update to reflect changes in direction value\n   */ Events.on(\"update\", function() {\n        Direction.mount();\n    });\n    /**\n   * Apply direction class:\n   * - before building to apply class for the first time\n   * - on updating to reapply direction class that may changed\n   */ Events.on([\n        \"build.before\",\n        \"update\"\n    ], function() {\n        Direction.addClass();\n    });\n    return Direction;\n}\n/**\n * Reflects value of glide movement.\n *\n * @param  {Object} Glide\n * @param  {Object} Components\n * @return {Object}\n */ function Rtl(Glide, Components) {\n    return {\n        /**\n     * Negates the passed translate if glide is in RTL option.\n     *\n     * @param  {Number} translate\n     * @return {Number}\n     */ modify: function modify(translate) {\n            if (Components.Direction.is(\"rtl\")) {\n                return -translate;\n            }\n            return translate;\n        }\n    };\n}\n/**\n * Updates glide movement with a `gap` settings.\n *\n * @param  {Object} Glide\n * @param  {Object} Components\n * @return {Object}\n */ function Gap(Glide, Components) {\n    return {\n        /**\n     * Modifies passed translate value with number in the `gap` settings.\n     *\n     * @param  {Number} translate\n     * @return {Number}\n     */ modify: function modify(translate) {\n            var multiplier = Math.floor(translate / Components.Sizes.slideWidth);\n            return translate + Components.Gaps.value * multiplier;\n        }\n    };\n}\n/**\n * Updates glide movement with width of additional clones width.\n *\n * @param  {Object} Glide\n * @param  {Object} Components\n * @return {Object}\n */ function Grow(Glide, Components) {\n    return {\n        /**\n     * Adds to the passed translate width of the half of clones.\n     *\n     * @param  {Number} translate\n     * @return {Number}\n     */ modify: function modify(translate) {\n            return translate + Components.Clones.grow / 2;\n        }\n    };\n}\n/**\n * Updates glide movement with a `peek` settings.\n *\n * @param  {Object} Glide\n * @param  {Object} Components\n * @return {Object}\n */ function Peeking(Glide, Components) {\n    return {\n        /**\n     * Modifies passed translate value with a `peek` setting.\n     *\n     * @param  {Number} translate\n     * @return {Number}\n     */ modify: function modify(translate) {\n            if (Glide.settings.focusAt >= 0) {\n                var peek = Components.Peek.value;\n                if (isObject(peek)) {\n                    return translate - peek.before;\n                }\n                return translate - peek;\n            }\n            return translate;\n        }\n    };\n}\n/**\n * Updates glide movement with a `focusAt` settings.\n *\n * @param  {Object} Glide\n * @param  {Object} Components\n * @return {Object}\n */ function Focusing(Glide, Components) {\n    return {\n        /**\n     * Modifies passed translate value with index in the `focusAt` setting.\n     *\n     * @param  {Number} translate\n     * @return {Number}\n     */ modify: function modify(translate) {\n            var gap = Components.Gaps.value;\n            var width = Components.Sizes.width;\n            var focusAt = Glide.settings.focusAt;\n            var slideWidth = Components.Sizes.slideWidth;\n            if (focusAt === \"center\") {\n                return translate - (width / 2 - slideWidth / 2);\n            }\n            return translate - slideWidth * focusAt - gap * focusAt;\n        }\n    };\n}\n/**\n * Applies diffrent transformers on translate value.\n *\n * @param  {Object} Glide\n * @param  {Object} Components\n * @return {Object}\n */ function mutator(Glide, Components, Events) {\n    /**\n   * Merge instance transformers with collection of default transformers.\n   * It's important that the Rtl component be last on the list,\n   * so it reflects all previous transformations.\n   *\n   * @type {Array}\n   */ var TRANSFORMERS = [\n        Gap,\n        Grow,\n        Peeking,\n        Focusing\n    ].concat(Glide._t, [\n        Rtl\n    ]);\n    return {\n        /**\n     * Piplines translate value with registered transformers.\n     *\n     * @param  {Number} translate\n     * @return {Number}\n     */ mutate: function mutate(translate) {\n            for(var i = 0; i < TRANSFORMERS.length; i++){\n                var transformer = TRANSFORMERS[i];\n                if (isFunction(transformer) && isFunction(transformer().modify)) {\n                    translate = transformer(Glide, Components, Events).modify(translate);\n                } else {\n                    warn(\"Transformer should be a function that returns an object with `modify()` method\");\n                }\n            }\n            return translate;\n        }\n    };\n}\nfunction Translate(Glide, Components, Events) {\n    var Translate = {\n        /**\n     * Sets value of translate on HTML element.\n     *\n     * @param {Number} value\n     * @return {Void}\n     */ set: function set(value) {\n            var transform = mutator(Glide, Components).mutate(value);\n            var translate3d = \"translate3d(\".concat(-1 * transform, \"px, 0px, 0px)\");\n            Components.Html.wrapper.style.mozTransform = translate3d; // needed for supported Firefox 10-15\n            Components.Html.wrapper.style.webkitTransform = translate3d; // needed for supported Chrome 10-35, Safari 5.1-8, and Opera 15-22\n            Components.Html.wrapper.style.transform = translate3d;\n        },\n        /**\n     * Removes value of translate from HTML element.\n     *\n     * @return {Void}\n     */ remove: function remove() {\n            Components.Html.wrapper.style.transform = \"\";\n        },\n        /**\n     * @return {number}\n     */ getStartIndex: function getStartIndex() {\n            var length = Components.Sizes.length;\n            var index = Glide.index;\n            var perView = Glide.settings.perView;\n            if (Components.Run.isOffset(\">\") || Components.Run.isOffset(\"|>\")) {\n                return length + (index - perView);\n            } // \"modulo length\" converts an index that equals length to zero\n            return (index + perView) % length;\n        },\n        /**\n     * @return {number}\n     */ getTravelDistance: function getTravelDistance() {\n            var travelDistance = Components.Sizes.slideWidth * Glide.settings.perView;\n            if (Components.Run.isOffset(\">\") || Components.Run.isOffset(\"|>\")) {\n                // reverse travel distance so that we don't have to change subtract operations\n                return travelDistance * -1;\n            }\n            return travelDistance;\n        }\n    };\n    /**\n   * Set new translate value:\n   * - on move to reflect index change\n   * - on updating via API to reflect possible changes in options\n   */ Events.on(\"move\", function(context) {\n        if (!Glide.isType(\"carousel\") || !Components.Run.isOffset()) {\n            return Translate.set(context.movement);\n        }\n        Components.Transition.after(function() {\n            Events.emit(\"translate.jump\");\n            Translate.set(Components.Sizes.slideWidth * Glide.index);\n        });\n        var startWidth = Components.Sizes.slideWidth * Components.Translate.getStartIndex();\n        return Translate.set(startWidth - Components.Translate.getTravelDistance());\n    });\n    /**\n   * Remove translate:\n   * - on destroying to bring markup to its inital state\n   */ Events.on(\"destroy\", function() {\n        Translate.remove();\n    });\n    return Translate;\n}\nfunction Transition(Glide, Components, Events) {\n    /**\n   * Holds inactivity status of transition.\n   * When true transition is not applied.\n   *\n   * @type {Boolean}\n   */ var disabled = false;\n    var Transition = {\n        /**\n     * Composes string of the CSS transition.\n     *\n     * @param {String} property\n     * @return {String}\n     */ compose: function compose(property) {\n            var settings = Glide.settings;\n            if (!disabled) {\n                return \"\".concat(property, \" \").concat(this.duration, \"ms \").concat(settings.animationTimingFunc);\n            }\n            return \"\".concat(property, \" 0ms \").concat(settings.animationTimingFunc);\n        },\n        /**\n     * Sets value of transition on HTML element.\n     *\n     * @param {String=} property\n     * @return {Void}\n     */ set: function set() {\n            var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"transform\";\n            Components.Html.wrapper.style.transition = this.compose(property);\n        },\n        /**\n     * Removes value of transition from HTML element.\n     *\n     * @return {Void}\n     */ remove: function remove() {\n            Components.Html.wrapper.style.transition = \"\";\n        },\n        /**\n     * Runs callback after animation.\n     *\n     * @param  {Function} callback\n     * @return {Void}\n     */ after: function after(callback) {\n            setTimeout(function() {\n                callback();\n            }, this.duration);\n        },\n        /**\n     * Enable transition.\n     *\n     * @return {Void}\n     */ enable: function enable() {\n            disabled = false;\n            this.set();\n        },\n        /**\n     * Disable transition.\n     *\n     * @return {Void}\n     */ disable: function disable() {\n            disabled = true;\n            this.set();\n        }\n    };\n    define(Transition, \"duration\", {\n        /**\n     * Gets duration of the transition based\n     * on currently running animation type.\n     *\n     * @return {Number}\n     */ get: function get() {\n            var settings = Glide.settings;\n            if (Glide.isType(\"slider\") && Components.Run.offset) {\n                return settings.rewindDuration;\n            }\n            return settings.animationDuration;\n        }\n    });\n    /**\n   * Set transition `style` value:\n   * - on each moving, because it may be cleared by offset move\n   */ Events.on(\"move\", function() {\n        Transition.set();\n    });\n    /**\n   * Disable transition:\n   * - before initial build to avoid transitioning from `0` to `startAt` index\n   * - while resizing window and recalculating dimensions\n   * - on jumping from offset transition at start and end edges in `carousel` type\n   */ Events.on([\n        \"build.before\",\n        \"resize\",\n        \"translate.jump\"\n    ], function() {\n        Transition.disable();\n    });\n    /**\n   * Enable transition:\n   * - on each running, because it may be disabled by offset move\n   */ Events.on(\"run\", function() {\n        Transition.enable();\n    });\n    /**\n   * Remove transition:\n   * - on destroying to bring markup to its inital state\n   */ Events.on(\"destroy\", function() {\n        Transition.remove();\n    });\n    return Transition;\n}\n/**\n * Test via a getter in the options object to see\n * if the passive property is accessed.\n *\n * @see https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection\n */ var supportsPassive = false;\ntry {\n    var opts = Object.defineProperty({}, \"passive\", {\n        get: function get() {\n            supportsPassive = true;\n        }\n    });\n    window.addEventListener(\"testPassive\", null, opts);\n    window.removeEventListener(\"testPassive\", null, opts);\n} catch (e) {}\nvar supportsPassive$1 = supportsPassive;\nvar START_EVENTS = [\n    \"touchstart\",\n    \"mousedown\"\n];\nvar MOVE_EVENTS = [\n    \"touchmove\",\n    \"mousemove\"\n];\nvar END_EVENTS = [\n    \"touchend\",\n    \"touchcancel\",\n    \"mouseup\",\n    \"mouseleave\"\n];\nvar MOUSE_EVENTS = [\n    \"mousedown\",\n    \"mousemove\",\n    \"mouseup\",\n    \"mouseleave\"\n];\nfunction Swipe(Glide, Components, Events) {\n    /**\n   * Instance of the binder for DOM Events.\n   *\n   * @type {EventsBinder}\n   */ var Binder = new EventsBinder();\n    var swipeSin = 0;\n    var swipeStartX = 0;\n    var swipeStartY = 0;\n    var disabled = false;\n    var capture = supportsPassive$1 ? {\n        passive: true\n    } : false;\n    var Swipe = {\n        /**\n     * Initializes swipe bindings.\n     *\n     * @return {Void}\n     */ mount: function mount() {\n            this.bindSwipeStart();\n        },\n        /**\n     * Handler for `swipestart` event. Calculates entry points of the user's tap.\n     *\n     * @param {Object} event\n     * @return {Void}\n     */ start: function start(event) {\n            if (!disabled && !Glide.disabled) {\n                this.disable();\n                var swipe = this.touches(event);\n                swipeSin = null;\n                swipeStartX = toInt(swipe.pageX);\n                swipeStartY = toInt(swipe.pageY);\n                this.bindSwipeMove();\n                this.bindSwipeEnd();\n                Events.emit(\"swipe.start\");\n            }\n        },\n        /**\n     * Handler for `swipemove` event. Calculates user's tap angle and distance.\n     *\n     * @param {Object} event\n     */ move: function move(event) {\n            if (!Glide.disabled) {\n                var _Glide$settings = Glide.settings, touchAngle = _Glide$settings.touchAngle, touchRatio = _Glide$settings.touchRatio, classes = _Glide$settings.classes;\n                var swipe = this.touches(event);\n                var subExSx = toInt(swipe.pageX) - swipeStartX;\n                var subEySy = toInt(swipe.pageY) - swipeStartY;\n                var powEX = Math.abs(subExSx << 2);\n                var powEY = Math.abs(subEySy << 2);\n                var swipeHypotenuse = Math.sqrt(powEX + powEY);\n                var swipeCathetus = Math.sqrt(powEY);\n                swipeSin = Math.asin(swipeCathetus / swipeHypotenuse);\n                if (swipeSin * 180 / Math.PI < touchAngle) {\n                    event.stopPropagation();\n                    Components.Move.make(subExSx * toFloat(touchRatio));\n                    Components.Html.root.classList.add(classes.dragging);\n                    Events.emit(\"swipe.move\");\n                } else {\n                    return false;\n                }\n            }\n        },\n        /**\n     * Handler for `swipeend` event. Finitializes user's tap and decides about glide move.\n     *\n     * @param {Object} event\n     * @return {Void}\n     */ end: function end(event) {\n            if (!Glide.disabled) {\n                var _Glide$settings2 = Glide.settings, perSwipe = _Glide$settings2.perSwipe, touchAngle = _Glide$settings2.touchAngle, classes = _Glide$settings2.classes;\n                var swipe = this.touches(event);\n                var threshold = this.threshold(event);\n                var swipeDistance = swipe.pageX - swipeStartX;\n                var swipeDeg = swipeSin * 180 / Math.PI;\n                this.enable();\n                if (swipeDistance > threshold && swipeDeg < touchAngle) {\n                    Components.Run.make(Components.Direction.resolve(\"\".concat(perSwipe, \"<\")));\n                } else if (swipeDistance < -threshold && swipeDeg < touchAngle) {\n                    Components.Run.make(Components.Direction.resolve(\"\".concat(perSwipe, \">\")));\n                } else {\n                    // While swipe don't reach distance apply previous transform.\n                    Components.Move.make();\n                }\n                Components.Html.root.classList.remove(classes.dragging);\n                this.unbindSwipeMove();\n                this.unbindSwipeEnd();\n                Events.emit(\"swipe.end\");\n            }\n        },\n        /**\n     * Binds swipe's starting event.\n     *\n     * @return {Void}\n     */ bindSwipeStart: function bindSwipeStart() {\n            var _this = this;\n            var _Glide$settings3 = Glide.settings, swipeThreshold = _Glide$settings3.swipeThreshold, dragThreshold = _Glide$settings3.dragThreshold;\n            if (swipeThreshold) {\n                Binder.on(START_EVENTS[0], Components.Html.wrapper, function(event) {\n                    _this.start(event);\n                }, capture);\n            }\n            if (dragThreshold) {\n                Binder.on(START_EVENTS[1], Components.Html.wrapper, function(event) {\n                    _this.start(event);\n                }, capture);\n            }\n        },\n        /**\n     * Unbinds swipe's starting event.\n     *\n     * @return {Void}\n     */ unbindSwipeStart: function unbindSwipeStart() {\n            Binder.off(START_EVENTS[0], Components.Html.wrapper, capture);\n            Binder.off(START_EVENTS[1], Components.Html.wrapper, capture);\n        },\n        /**\n     * Binds swipe's moving event.\n     *\n     * @return {Void}\n     */ bindSwipeMove: function bindSwipeMove() {\n            var _this2 = this;\n            Binder.on(MOVE_EVENTS, Components.Html.wrapper, throttle(function(event) {\n                _this2.move(event);\n            }, Glide.settings.throttle), capture);\n        },\n        /**\n     * Unbinds swipe's moving event.\n     *\n     * @return {Void}\n     */ unbindSwipeMove: function unbindSwipeMove() {\n            Binder.off(MOVE_EVENTS, Components.Html.wrapper, capture);\n        },\n        /**\n     * Binds swipe's ending event.\n     *\n     * @return {Void}\n     */ bindSwipeEnd: function bindSwipeEnd() {\n            var _this3 = this;\n            Binder.on(END_EVENTS, Components.Html.wrapper, function(event) {\n                _this3.end(event);\n            });\n        },\n        /**\n     * Unbinds swipe's ending event.\n     *\n     * @return {Void}\n     */ unbindSwipeEnd: function unbindSwipeEnd() {\n            Binder.off(END_EVENTS, Components.Html.wrapper);\n        },\n        /**\n     * Normalizes event touches points accorting to different types.\n     *\n     * @param {Object} event\n     */ touches: function touches(event) {\n            if (MOUSE_EVENTS.indexOf(event.type) > -1) {\n                return event;\n            }\n            return event.touches[0] || event.changedTouches[0];\n        },\n        /**\n     * Gets value of minimum swipe distance settings based on event type.\n     *\n     * @return {Number}\n     */ threshold: function threshold(event) {\n            var settings = Glide.settings;\n            if (MOUSE_EVENTS.indexOf(event.type) > -1) {\n                return settings.dragThreshold;\n            }\n            return settings.swipeThreshold;\n        },\n        /**\n     * Enables swipe event.\n     *\n     * @return {self}\n     */ enable: function enable() {\n            disabled = false;\n            Components.Transition.enable();\n            return this;\n        },\n        /**\n     * Disables swipe event.\n     *\n     * @return {self}\n     */ disable: function disable() {\n            disabled = true;\n            Components.Transition.disable();\n            return this;\n        }\n    };\n    /**\n   * Add component class:\n   * - after initial building\n   */ Events.on(\"build.after\", function() {\n        Components.Html.root.classList.add(Glide.settings.classes.swipeable);\n    });\n    /**\n   * Remove swiping bindings:\n   * - on destroying, to remove added EventListeners\n   */ Events.on(\"destroy\", function() {\n        Swipe.unbindSwipeStart();\n        Swipe.unbindSwipeMove();\n        Swipe.unbindSwipeEnd();\n        Binder.destroy();\n    });\n    return Swipe;\n}\nfunction Images(Glide, Components, Events) {\n    /**\n   * Instance of the binder for DOM Events.\n   *\n   * @type {EventsBinder}\n   */ var Binder = new EventsBinder();\n    var Images = {\n        /**\n     * Binds listener to glide wrapper.\n     *\n     * @return {Void}\n     */ mount: function mount() {\n            this.bind();\n        },\n        /**\n     * Binds `dragstart` event on wrapper to prevent dragging images.\n     *\n     * @return {Void}\n     */ bind: function bind() {\n            Binder.on(\"dragstart\", Components.Html.wrapper, this.dragstart);\n        },\n        /**\n     * Unbinds `dragstart` event on wrapper.\n     *\n     * @return {Void}\n     */ unbind: function unbind() {\n            Binder.off(\"dragstart\", Components.Html.wrapper);\n        },\n        /**\n     * Event handler. Prevents dragging.\n     *\n     * @return {Void}\n     */ dragstart: function dragstart(event) {\n            event.preventDefault();\n        }\n    };\n    /**\n   * Remove bindings from images:\n   * - on destroying, to remove added EventListeners\n   */ Events.on(\"destroy\", function() {\n        Images.unbind();\n        Binder.destroy();\n    });\n    return Images;\n}\nfunction Anchors(Glide, Components, Events) {\n    /**\n   * Instance of the binder for DOM Events.\n   *\n   * @type {EventsBinder}\n   */ var Binder = new EventsBinder();\n    /**\n   * Holds detaching status of anchors.\n   * Prevents detaching of already detached anchors.\n   *\n   * @private\n   * @type {Boolean}\n   */ var detached = false;\n    /**\n   * Holds preventing status of anchors.\n   * If `true` redirection after click will be disabled.\n   *\n   * @private\n   * @type {Boolean}\n   */ var prevented = false;\n    var Anchors = {\n        /**\n     * Setups a initial state of anchors component.\n     *\n     * @returns {Void}\n     */ mount: function mount() {\n            /**\n       * Holds collection of anchors elements.\n       *\n       * @private\n       * @type {HTMLCollection}\n       */ this._a = Components.Html.wrapper.querySelectorAll(\"a\");\n            this.bind();\n        },\n        /**\n     * Binds events to anchors inside a track.\n     *\n     * @return {Void}\n     */ bind: function bind() {\n            Binder.on(\"click\", Components.Html.wrapper, this.click);\n        },\n        /**\n     * Unbinds events attached to anchors inside a track.\n     *\n     * @return {Void}\n     */ unbind: function unbind() {\n            Binder.off(\"click\", Components.Html.wrapper);\n        },\n        /**\n     * Handler for click event. Prevents clicks when glide is in `prevent` status.\n     *\n     * @param  {Object} event\n     * @return {Void}\n     */ click: function click(event) {\n            if (prevented) {\n                event.stopPropagation();\n                event.preventDefault();\n            }\n        },\n        /**\n     * Detaches anchors click event inside glide.\n     *\n     * @return {self}\n     */ detach: function detach() {\n            prevented = true;\n            if (!detached) {\n                for(var i = 0; i < this.items.length; i++){\n                    this.items[i].draggable = false;\n                }\n                detached = true;\n            }\n            return this;\n        },\n        /**\n     * Attaches anchors click events inside glide.\n     *\n     * @return {self}\n     */ attach: function attach() {\n            prevented = false;\n            if (detached) {\n                for(var i = 0; i < this.items.length; i++){\n                    this.items[i].draggable = true;\n                }\n                detached = false;\n            }\n            return this;\n        }\n    };\n    define(Anchors, \"items\", {\n        /**\n     * Gets collection of the arrows HTML elements.\n     *\n     * @return {HTMLElement[]}\n     */ get: function get() {\n            return Anchors._a;\n        }\n    });\n    /**\n   * Detach anchors inside slides:\n   * - on swiping, so they won't redirect to its `href` attributes\n   */ Events.on(\"swipe.move\", function() {\n        Anchors.detach();\n    });\n    /**\n   * Attach anchors inside slides:\n   * - after swiping and transitions ends, so they can redirect after click again\n   */ Events.on(\"swipe.end\", function() {\n        Components.Transition.after(function() {\n            Anchors.attach();\n        });\n    });\n    /**\n   * Unbind anchors inside slides:\n   * - on destroying, to bring anchors to its initial state\n   */ Events.on(\"destroy\", function() {\n        Anchors.attach();\n        Anchors.unbind();\n        Binder.destroy();\n    });\n    return Anchors;\n}\nvar NAV_SELECTOR = '[data-glide-el=\"controls[nav]\"]';\nvar CONTROLS_SELECTOR = '[data-glide-el^=\"controls\"]';\nvar PREVIOUS_CONTROLS_SELECTOR = \"\".concat(CONTROLS_SELECTOR, ' [data-glide-dir*=\"<\"]');\nvar NEXT_CONTROLS_SELECTOR = \"\".concat(CONTROLS_SELECTOR, ' [data-glide-dir*=\">\"]');\nfunction Controls(Glide, Components, Events) {\n    /**\n   * Instance of the binder for DOM Events.\n   *\n   * @type {EventsBinder}\n   */ var Binder = new EventsBinder();\n    var capture = supportsPassive$1 ? {\n        passive: true\n    } : false;\n    var Controls = {\n        /**\n     * Inits arrows. Binds events listeners\n     * to the arrows HTML elements.\n     *\n     * @return {Void}\n     */ mount: function mount() {\n            /**\n       * Collection of navigation HTML elements.\n       *\n       * @private\n       * @type {HTMLCollection}\n       */ this._n = Components.Html.root.querySelectorAll(NAV_SELECTOR);\n            /**\n       * Collection of controls HTML elements.\n       *\n       * @private\n       * @type {HTMLCollection}\n       */ this._c = Components.Html.root.querySelectorAll(CONTROLS_SELECTOR);\n            /**\n       * Collection of arrow control HTML elements.\n       *\n       * @private\n       * @type {Object}\n       */ this._arrowControls = {\n                previous: Components.Html.root.querySelectorAll(PREVIOUS_CONTROLS_SELECTOR),\n                next: Components.Html.root.querySelectorAll(NEXT_CONTROLS_SELECTOR)\n            };\n            this.addBindings();\n        },\n        /**\n     * Sets active class to current slide.\n     *\n     * @return {Void}\n     */ setActive: function setActive() {\n            for(var i = 0; i < this._n.length; i++){\n                this.addClass(this._n[i].children);\n            }\n        },\n        /**\n     * Removes active class to current slide.\n     *\n     * @return {Void}\n     */ removeActive: function removeActive() {\n            for(var i = 0; i < this._n.length; i++){\n                this.removeClass(this._n[i].children);\n            }\n        },\n        /**\n     * Toggles active class on items inside navigation.\n     *\n     * @param  {HTMLElement} controls\n     * @return {Void}\n     */ addClass: function addClass(controls) {\n            var settings = Glide.settings;\n            var item = controls[Glide.index];\n            if (!item) {\n                return;\n            }\n            if (item) {\n                item.classList.add(settings.classes.nav.active);\n                siblings(item).forEach(function(sibling) {\n                    sibling.classList.remove(settings.classes.nav.active);\n                });\n            }\n        },\n        /**\n     * Removes active class from active control.\n     *\n     * @param  {HTMLElement} controls\n     * @return {Void}\n     */ removeClass: function removeClass(controls) {\n            var item = controls[Glide.index];\n            if (item) {\n                item.classList.remove(Glide.settings.classes.nav.active);\n            }\n        },\n        /**\n     * Calculates, removes or adds `Glide.settings.classes.disabledArrow` class on the control arrows\n     */ setArrowState: function setArrowState() {\n            if (Glide.settings.rewind) {\n                return;\n            }\n            var next = Controls._arrowControls.next;\n            var previous = Controls._arrowControls.previous;\n            this.resetArrowState(next, previous);\n            if (Glide.index === 0) {\n                this.disableArrow(previous);\n            }\n            if (Glide.index === Components.Run.length) {\n                this.disableArrow(next);\n            }\n        },\n        /**\n     * Removes `Glide.settings.classes.disabledArrow` from given NodeList elements\n     *\n     * @param {NodeList[]} lists\n     */ resetArrowState: function resetArrowState() {\n            var settings = Glide.settings;\n            for(var _len = arguments.length, lists = new Array(_len), _key = 0; _key < _len; _key++){\n                lists[_key] = arguments[_key];\n            }\n            lists.forEach(function(list) {\n                toArray(list).forEach(function(element) {\n                    element.classList.remove(settings.classes.arrow.disabled);\n                });\n            });\n        },\n        /**\n     * Adds `Glide.settings.classes.disabledArrow` to given NodeList elements\n     *\n     * @param {NodeList[]} lists\n     */ disableArrow: function disableArrow() {\n            var settings = Glide.settings;\n            for(var _len2 = arguments.length, lists = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n                lists[_key2] = arguments[_key2];\n            }\n            lists.forEach(function(list) {\n                toArray(list).forEach(function(element) {\n                    element.classList.add(settings.classes.arrow.disabled);\n                });\n            });\n        },\n        /**\n     * Adds handles to the each group of controls.\n     *\n     * @return {Void}\n     */ addBindings: function addBindings() {\n            for(var i = 0; i < this._c.length; i++){\n                this.bind(this._c[i].children);\n            }\n        },\n        /**\n     * Removes handles from the each group of controls.\n     *\n     * @return {Void}\n     */ removeBindings: function removeBindings() {\n            for(var i = 0; i < this._c.length; i++){\n                this.unbind(this._c[i].children);\n            }\n        },\n        /**\n     * Binds events to arrows HTML elements.\n     *\n     * @param {HTMLCollection} elements\n     * @return {Void}\n     */ bind: function bind(elements) {\n            for(var i = 0; i < elements.length; i++){\n                Binder.on(\"click\", elements[i], this.click);\n                Binder.on(\"touchstart\", elements[i], this.click, capture);\n            }\n        },\n        /**\n     * Unbinds events binded to the arrows HTML elements.\n     *\n     * @param {HTMLCollection} elements\n     * @return {Void}\n     */ unbind: function unbind(elements) {\n            for(var i = 0; i < elements.length; i++){\n                Binder.off([\n                    \"click\",\n                    \"touchstart\"\n                ], elements[i]);\n            }\n        },\n        /**\n     * Handles `click` event on the arrows HTML elements.\n     * Moves slider in direction given via the\n     * `data-glide-dir` attribute.\n     *\n     * @param {Object} event\n     * @return {void}\n     */ click: function click(event) {\n            if (!supportsPassive$1 && event.type === \"touchstart\") {\n                event.preventDefault();\n            }\n            var direction = event.currentTarget.getAttribute(\"data-glide-dir\");\n            Components.Run.make(Components.Direction.resolve(direction));\n        }\n    };\n    define(Controls, \"items\", {\n        /**\n     * Gets collection of the controls HTML elements.\n     *\n     * @return {HTMLElement[]}\n     */ get: function get() {\n            return Controls._c;\n        }\n    });\n    /**\n   * Swap active class of current navigation item:\n   * - after mounting to set it to initial index\n   * - after each move to the new index\n   */ Events.on([\n        \"mount.after\",\n        \"move.after\"\n    ], function() {\n        Controls.setActive();\n    });\n    /**\n   * Add or remove disabled class of arrow elements\n   */ Events.on([\n        \"mount.after\",\n        \"run\"\n    ], function() {\n        Controls.setArrowState();\n    });\n    /**\n   * Remove bindings and HTML Classes:\n   * - on destroying, to bring markup to its initial state\n   */ Events.on(\"destroy\", function() {\n        Controls.removeBindings();\n        Controls.removeActive();\n        Binder.destroy();\n    });\n    return Controls;\n}\nfunction Keyboard(Glide, Components, Events) {\n    /**\n   * Instance of the binder for DOM Events.\n   *\n   * @type {EventsBinder}\n   */ var Binder = new EventsBinder();\n    var Keyboard = {\n        /**\n     * Binds keyboard events on component mount.\n     *\n     * @return {Void}\n     */ mount: function mount() {\n            if (Glide.settings.keyboard) {\n                this.bind();\n            }\n        },\n        /**\n     * Adds keyboard press events.\n     *\n     * @return {Void}\n     */ bind: function bind() {\n            Binder.on(\"keyup\", document, this.press);\n        },\n        /**\n     * Removes keyboard press events.\n     *\n     * @return {Void}\n     */ unbind: function unbind() {\n            Binder.off(\"keyup\", document);\n        },\n        /**\n     * Handles keyboard's arrows press and moving glide foward and backward.\n     *\n     * @param  {Object} event\n     * @return {Void}\n     */ press: function press(event) {\n            var perSwipe = Glide.settings.perSwipe;\n            if (event.code === \"ArrowRight\") {\n                Components.Run.make(Components.Direction.resolve(\"\".concat(perSwipe, \">\")));\n            }\n            if (event.code === \"ArrowLeft\") {\n                Components.Run.make(Components.Direction.resolve(\"\".concat(perSwipe, \"<\")));\n            }\n        }\n    };\n    /**\n   * Remove bindings from keyboard:\n   * - on destroying to remove added events\n   * - on updating to remove events before remounting\n   */ Events.on([\n        \"destroy\",\n        \"update\"\n    ], function() {\n        Keyboard.unbind();\n    });\n    /**\n   * Remount component\n   * - on updating to reflect potential changes in settings\n   */ Events.on(\"update\", function() {\n        Keyboard.mount();\n    });\n    /**\n   * Destroy binder:\n   * - on destroying to remove listeners\n   */ Events.on(\"destroy\", function() {\n        Binder.destroy();\n    });\n    return Keyboard;\n}\nfunction Autoplay(Glide, Components, Events) {\n    /**\n   * Instance of the binder for DOM Events.\n   *\n   * @type {EventsBinder}\n   */ var Binder = new EventsBinder();\n    var Autoplay = {\n        /**\n     * Initializes autoplaying and events.\n     *\n     * @return {Void}\n     */ mount: function mount() {\n            this.enable();\n            this.start();\n            if (Glide.settings.hoverpause) {\n                this.bind();\n            }\n        },\n        /**\n     * Enables autoplaying\n     *\n     * @returns {Void}\n     */ enable: function enable() {\n            this._e = true;\n        },\n        /**\n     * Disables autoplaying.\n     *\n     * @returns {Void}\n     */ disable: function disable() {\n            this._e = false;\n        },\n        /**\n     * Starts autoplaying in configured interval.\n     *\n     * @param {Boolean|Number} force Run autoplaying with passed interval regardless of `autoplay` settings\n     * @return {Void}\n     */ start: function start() {\n            var _this = this;\n            if (!this._e) {\n                return;\n            }\n            this.enable();\n            if (Glide.settings.autoplay) {\n                if (isUndefined(this._i)) {\n                    this._i = setInterval(function() {\n                        _this.stop();\n                        Components.Run.make(\">\");\n                        _this.start();\n                        Events.emit(\"autoplay\");\n                    }, this.time);\n                }\n            }\n        },\n        /**\n     * Stops autorunning of the glide.\n     *\n     * @return {Void}\n     */ stop: function stop() {\n            this._i = clearInterval(this._i);\n        },\n        /**\n     * Stops autoplaying while mouse is over glide's area.\n     *\n     * @return {Void}\n     */ bind: function bind() {\n            var _this2 = this;\n            Binder.on(\"mouseover\", Components.Html.root, function() {\n                if (_this2._e) {\n                    _this2.stop();\n                }\n            });\n            Binder.on(\"mouseout\", Components.Html.root, function() {\n                if (_this2._e) {\n                    _this2.start();\n                }\n            });\n        },\n        /**\n     * Unbind mouseover events.\n     *\n     * @returns {Void}\n     */ unbind: function unbind() {\n            Binder.off([\n                \"mouseover\",\n                \"mouseout\"\n            ], Components.Html.root);\n        }\n    };\n    define(Autoplay, \"time\", {\n        /**\n     * Gets time period value for the autoplay interval. Prioritizes\n     * times in `data-glide-autoplay` attrubutes over options.\n     *\n     * @return {Number}\n     */ get: function get() {\n            var autoplay = Components.Html.slides[Glide.index].getAttribute(\"data-glide-autoplay\");\n            if (autoplay) {\n                return toInt(autoplay);\n            }\n            return toInt(Glide.settings.autoplay);\n        }\n    });\n    /**\n   * Stop autoplaying and unbind events:\n   * - on destroying, to clear defined interval\n   * - on updating via API to reset interval that may changed\n   */ Events.on([\n        \"destroy\",\n        \"update\"\n    ], function() {\n        Autoplay.unbind();\n    });\n    /**\n   * Stop autoplaying:\n   * - before each run, to restart autoplaying\n   * - on pausing via API\n   * - on destroying, to clear defined interval\n   * - while starting a swipe\n   * - on updating via API to reset interval that may changed\n   */ Events.on([\n        \"run.before\",\n        \"swipe.start\",\n        \"update\"\n    ], function() {\n        Autoplay.stop();\n    });\n    Events.on([\n        \"pause\",\n        \"destroy\"\n    ], function() {\n        Autoplay.disable();\n        Autoplay.stop();\n    });\n    /**\n   * Start autoplaying:\n   * - after each run, to restart autoplaying\n   * - on playing via API\n   * - while ending a swipe\n   */ Events.on([\n        \"run.after\",\n        \"swipe.end\"\n    ], function() {\n        Autoplay.start();\n    });\n    /**\n   * Start autoplaying:\n   * - after each run, to restart autoplaying\n   * - on playing via API\n   * - while ending a swipe\n   */ Events.on([\n        \"play\"\n    ], function() {\n        Autoplay.enable();\n        Autoplay.start();\n    });\n    /**\n   * Remount autoplaying:\n   * - on updating via API to reset interval that may changed\n   */ Events.on(\"update\", function() {\n        Autoplay.mount();\n    });\n    /**\n   * Destroy a binder:\n   * - on destroying glide instance to clearup listeners\n   */ Events.on(\"destroy\", function() {\n        Binder.destroy();\n    });\n    return Autoplay;\n}\n/**\n * Sorts keys of breakpoint object so they will be ordered from lower to bigger.\n *\n * @param {Object} points\n * @returns {Object}\n */ function sortBreakpoints(points) {\n    if (isObject(points)) {\n        return sortKeys(points);\n    } else {\n        warn(\"Breakpoints option must be an object\");\n    }\n    return {};\n}\nfunction Breakpoints(Glide, Components, Events) {\n    /**\n   * Instance of the binder for DOM Events.\n   *\n   * @type {EventsBinder}\n   */ var Binder = new EventsBinder();\n    /**\n   * Holds reference to settings.\n   *\n   * @type {Object}\n   */ var settings = Glide.settings;\n    /**\n   * Holds reference to breakpoints object in settings. Sorts breakpoints\n   * from smaller to larger. It is required in order to proper\n   * matching currently active breakpoint settings.\n   *\n   * @type {Object}\n   */ var points = sortBreakpoints(settings.breakpoints);\n    /**\n   * Cache initial settings before overwritting.\n   *\n   * @type {Object}\n   */ var defaults = Object.assign({}, settings);\n    var Breakpoints = {\n        /**\n     * Matches settings for currectly matching media breakpoint.\n     *\n     * @param {Object} points\n     * @returns {Object}\n     */ match: function match(points) {\n            if (typeof window.matchMedia !== \"undefined\") {\n                for(var point in points){\n                    if (points.hasOwnProperty(point)) {\n                        if (window.matchMedia(\"(max-width: \".concat(point, \"px)\")).matches) {\n                            return points[point];\n                        }\n                    }\n                }\n            }\n            return defaults;\n        }\n    };\n    /**\n   * Overwrite instance settings with currently matching breakpoint settings.\n   * This happens right after component initialization.\n   */ Object.assign(settings, Breakpoints.match(points));\n    /**\n   * Update glide with settings of matched brekpoint:\n   * - window resize to update slider\n   */ Binder.on(\"resize\", window, throttle(function() {\n        Glide.settings = mergeOptions(settings, Breakpoints.match(points));\n    }, Glide.settings.throttle));\n    /**\n   * Resort and update default settings:\n   * - on reinit via API, so breakpoint matching will be performed with options\n   */ Events.on(\"update\", function() {\n        points = sortBreakpoints(points);\n        defaults = Object.assign({}, settings);\n    });\n    /**\n   * Unbind resize listener:\n   * - on destroying, to bring markup to its initial state\n   */ Events.on(\"destroy\", function() {\n        Binder.off(\"resize\", window);\n    });\n    return Breakpoints;\n}\nvar COMPONENTS = {\n    // Required\n    Html: Html,\n    Translate: Translate,\n    Transition: Transition,\n    Direction: Direction,\n    Peek: Peek,\n    Sizes: Sizes,\n    Gaps: Gaps,\n    Move: Move,\n    Clones: Clones,\n    Resize: Resize,\n    Build: Build,\n    Run: Run,\n    // Optional\n    Swipe: Swipe,\n    Images: Images,\n    Anchors: Anchors,\n    Controls: Controls,\n    Keyboard: Keyboard,\n    Autoplay: Autoplay,\n    Breakpoints: Breakpoints\n};\nvar Glide = /*#__PURE__*/ function(_Core) {\n    _inherits(Glide, _Core);\n    var _super = _createSuper(Glide);\n    function Glide() {\n        _classCallCheck(this, Glide);\n        return _super.apply(this, arguments);\n    }\n    _createClass(Glide, [\n        {\n            key: \"mount\",\n            value: function mount() {\n                var extensions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n                return _get(_getPrototypeOf(Glide.prototype), \"mount\", this).call(this, Object.assign({}, COMPONENTS, extensions));\n            }\n        }\n    ]);\n    return Glide;\n}(Glide$1);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlanMvZ2xpZGUvZGlzdC9nbGlkZS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7O0NBSUMsR0FFRCxTQUFTQSxRQUFRQyxHQUFHO0lBQ2xCO0lBRUEsSUFBSSxPQUFPQyxXQUFXLGNBQWMsT0FBT0EsT0FBT0MsUUFBUSxLQUFLLFVBQVU7UUFDdkVILFVBQVUsU0FBVUMsR0FBRztZQUNyQixPQUFPLE9BQU9BO1FBQ2hCO0lBQ0YsT0FBTztRQUNMRCxVQUFVLFNBQVVDLEdBQUc7WUFDckIsT0FBT0EsT0FBTyxPQUFPQyxXQUFXLGNBQWNELElBQUlHLFdBQVcsS0FBS0YsVUFBVUQsUUFBUUMsT0FBT0csU0FBUyxHQUFHLFdBQVcsT0FBT0o7UUFDM0g7SUFDRjtJQUVBLE9BQU9ELFFBQVFDO0FBQ2pCO0FBRUEsU0FBU0ssZ0JBQWdCQyxRQUFRLEVBQUVDLFdBQVc7SUFDNUMsSUFBSSxDQUFFRCxDQUFBQSxvQkFBb0JDLFdBQVUsR0FBSTtRQUN0QyxNQUFNLElBQUlDLFVBQVU7SUFDdEI7QUFDRjtBQUVBLFNBQVNDLGtCQUFrQkMsTUFBTSxFQUFFQyxLQUFLO0lBQ3RDLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRCxNQUFNRSxNQUFNLEVBQUVELElBQUs7UUFDckMsSUFBSUUsYUFBYUgsS0FBSyxDQUFDQyxFQUFFO1FBQ3pCRSxXQUFXQyxVQUFVLEdBQUdELFdBQVdDLFVBQVUsSUFBSTtRQUNqREQsV0FBV0UsWUFBWSxHQUFHO1FBQzFCLElBQUksV0FBV0YsWUFBWUEsV0FBV0csUUFBUSxHQUFHO1FBQ2pEQyxPQUFPQyxjQUFjLENBQUNULFFBQVFJLFdBQVdNLEdBQUcsRUFBRU47SUFDaEQ7QUFDRjtBQUVBLFNBQVNPLGFBQWFkLFdBQVcsRUFBRWUsVUFBVSxFQUFFQyxXQUFXO0lBQ3hELElBQUlELFlBQVliLGtCQUFrQkYsWUFBWUgsU0FBUyxFQUFFa0I7SUFDekQsSUFBSUMsYUFBYWQsa0JBQWtCRixhQUFh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TzBILE1BQU0sQ0FBQyxDQUFDLEdBQUdnVCxZQUFZalU7WUFDeEc7UUFDRjtLQUFFO0lBRUYsT0FBT2dDO0FBQ1QsRUFBRUQ7QUFFMEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9GTEFBS0tPLy4vbm9kZV9tb2R1bGVzL0BnbGlkZWpzL2dsaWRlL2Rpc3QvZ2xpZGUuZXNtLmpzP2JmM2MiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBHbGlkZS5qcyB2My42LjBcbiAqIChjKSAyMDEzLTIwMjIgSsSZZHJ6ZWogQ2hhxYJ1YmVrIChodHRwczovL2dpdGh1Yi5jb20vamVkcnplamNoYWx1YmVrLylcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcblxuICB0cnkge1xuICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgfVxuXG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLFxuICAgICAgICByZXN1bHQ7XG5cbiAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcblxuICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkge1xuICB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgIG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgIGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuZnVuY3Rpb24gX2dldCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7XG4gICAgX2dldCA9IFJlZmxlY3QuZ2V0O1xuICB9IGVsc2Uge1xuICAgIF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuXG4gICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG5cbiAgICAgIGlmIChkZXNjLmdldCkge1xuICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHRhcmdldCA6IHJlY2VpdmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIFR5cGUgb2YgdGhlIG1vdmVtZW50LlxuICAgKlxuICAgKiBBdmFpbGFibGUgdHlwZXM6XG4gICAqIGBzbGlkZXJgIC0gUmV3aW5kcyBzbGlkZXIgdG8gdGhlIHN0YXJ0L2VuZCB3aGVuIGl0IHJlYWNoZXMgdGhlIGZpcnN0IG9yIGxhc3Qgc2xpZGUuXG4gICAqIGBjYXJvdXNlbGAgLSBDaGFuZ2VzIHNsaWRlcyB3aXRob3V0IHN0YXJ0aW5nIG92ZXIgd2hlbiBpdCByZWFjaGVzIHRoZSBmaXJzdCBvciBsYXN0IHNsaWRlLlxuICAgKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgdHlwZTogJ3NsaWRlcicsXG5cbiAgLyoqXG4gICAqIFN0YXJ0IGF0IHNwZWNpZmljIHNsaWRlIG51bWJlciBkZWZpbmVkIHdpdGggemVyby1iYXNlZCBpbmRleC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIHN0YXJ0QXQ6IDAsXG5cbiAgLyoqXG4gICAqIEEgbnVtYmVyIG9mIHNsaWRlcyB2aXNpYmxlIG9uIHRoZSBzaW5nbGUgdmlld3BvcnQuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBwZXJWaWV3OiAxLFxuXG4gIC8qKlxuICAgKiBGb2N1cyBjdXJyZW50bHkgYWN0aXZlIHNsaWRlIGF0IGEgc3BlY2lmaWVkIHBvc2l0aW9uIGluIHRoZSB0cmFjay5cbiAgICpcbiAgICogQXZhaWxhYmxlIGlucHV0czpcbiAgICogYGNlbnRlcmAgLSBDdXJyZW50IHNsaWRlIHdpbGwgYmUgYWx3YXlzIGZvY3VzZWQgYXQgdGhlIGNlbnRlciBvZiBhIHRyYWNrLlxuICAgKiBgMCwxLDIsMy4uLmAgLSBDdXJyZW50IHNsaWRlIHdpbGwgYmUgZm9jdXNlZCBvbiB0aGUgc3BlY2lmaWVkIHplcm8tYmFzZWQgaW5kZXguXG4gICAqXG4gICAqIEB0eXBlIHtTdHJpbmd8TnVtYmVyfVxuICAgKi9cbiAgZm9jdXNBdDogMCxcblxuICAvKipcbiAgICogQSBzaXplIG9mIHRoZSBnYXAgYWRkZWQgYmV0d2VlbiBzbGlkZXMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnYXA6IDEwLFxuXG4gIC8qKlxuICAgKiBDaGFuZ2Ugc2xpZGVzIGFmdGVyIGEgc3BlY2lmaWVkIGludGVydmFsLiBVc2UgYGZhbHNlYCBmb3IgdHVybmluZyBvZmYgYXV0b3BsYXkuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ8Qm9vbGVhbn1cbiAgICovXG4gIGF1dG9wbGF5OiBmYWxzZSxcblxuICAvKipcbiAgICogU3RvcCBhdXRvcGxheSBvbiBtb3VzZW92ZXIgZXZlbnQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgaG92ZXJwYXVzZTogdHJ1ZSxcblxuICAvKipcbiAgICogQWxsb3cgZm9yIGNoYW5naW5nIHNsaWRlcyB3aXRoIGxlZnQgYW5kIHJpZ2h0IGtleWJvYXJkIGFycm93cy5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBrZXlib2FyZDogdHJ1ZSxcblxuICAvKipcbiAgICogU3RvcCBydW5uaW5nIGBwZXJWaWV3YCBudW1iZXIgb2Ygc2xpZGVzIGZyb20gdGhlIGVuZC4gVXNlIHRoaXNcbiAgICogb3B0aW9uIGlmIHlvdSBkb24ndCB3YW50IHRvIGhhdmUgYW4gZW1wdHkgc3BhY2UgYWZ0ZXJcbiAgICogYSBzbGlkZXIuIFdvcmtzIG9ubHkgd2l0aCBgc2xpZGVyYCB0eXBlIGFuZCBhXG4gICAqIG5vbi1jZW50ZXJlZCBgZm9jdXNBdGAgc2V0dGluZy5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBib3VuZDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIE1pbmltYWwgc3dpcGUgZGlzdGFuY2UgbmVlZGVkIHRvIGNoYW5nZSB0aGUgc2xpZGUuIFVzZSBgZmFsc2VgIGZvciB0dXJuaW5nIG9mZiBhIHN3aXBpbmcuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ8Qm9vbGVhbn1cbiAgICovXG4gIHN3aXBlVGhyZXNob2xkOiA4MCxcblxuICAvKipcbiAgICogTWluaW1hbCBtb3VzZSBkcmFnIGRpc3RhbmNlIG5lZWRlZCB0byBjaGFuZ2UgdGhlIHNsaWRlLiBVc2UgYGZhbHNlYCBmb3IgdHVybmluZyBvZmYgYSBkcmFnZ2luZy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcnxCb29sZWFufVxuICAgKi9cbiAgZHJhZ1RocmVzaG9sZDogMTIwLFxuXG4gIC8qKlxuICAgKiBBIG51bWJlciBvZiBzbGlkZXMgbW92ZWQgb24gc2luZ2xlIHN3aXBlLlxuICAgKlxuICAgKiBBdmFpbGFibGUgdHlwZXM6XG4gICAqIGBgIC0gTW92ZXMgc2xpZGVyIGJ5IG9uZSBzbGlkZSBwZXIgc3dpcGVcbiAgICogYHxgIC0gTW92ZXMgc2xpZGVyIGJldHdlZW4gdmlld3MgcGVyIHN3aXBlIChudW1iZXIgb2Ygc2xpZGVzIGRlZmluZWQgaW4gYHBlclZpZXdgIG9wdGlvbnMpXG4gICAqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBwZXJTd2lwZTogJycsXG5cbiAgLyoqXG4gICAqIE1vdmluZyBkaXN0YW5jZSByYXRpbyBvZiB0aGUgc2xpZGVzIG9uIGEgc3dpcGluZyBhbmQgZHJhZ2dpbmcuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICB0b3VjaFJhdGlvOiAwLjUsXG5cbiAgLyoqXG4gICAqIEFuZ2xlIHJlcXVpcmVkIHRvIGFjdGl2YXRlIHNsaWRlcyBtb3Zpbmcgb24gc3dpcGluZyBvciBkcmFnZ2luZy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIHRvdWNoQW5nbGU6IDQ1LFxuXG4gIC8qKlxuICAgKiBEdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiA0MDAsXG5cbiAgLyoqXG4gICAqIEFsbG93cyBsb29waW5nIHRoZSBgc2xpZGVyYCB0eXBlLiBTbGlkZXIgd2lsbCByZXdpbmQgdG8gdGhlIGZpcnN0L2xhc3Qgc2xpZGUgd2hlbiBpdCdzIGF0IHRoZSBzdGFydC9lbmQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgcmV3aW5kOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBEdXJhdGlvbiBvZiB0aGUgcmV3aW5kaW5nIGFuaW1hdGlvbiBvZiB0aGUgYHNsaWRlcmAgdHlwZSBpbiBtaWxsaXNlY29uZHMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICByZXdpbmREdXJhdGlvbjogODAwLFxuXG4gIC8qKlxuICAgKiBFYXNpbmcgZnVuY3Rpb24gZm9yIHRoZSBhbmltYXRpb24uXG4gICAqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBhbmltYXRpb25UaW1pbmdGdW5jOiAnY3ViaWMtYmV6aWVyKC4xNjUsIC44NDAsIC40NDAsIDEpJyxcblxuICAvKipcbiAgICogV2FpdCBmb3IgdGhlIGFuaW1hdGlvbiB0byBmaW5pc2ggdW50aWwgdGhlIG5leHQgdXNlciBpbnB1dCBjYW4gYmUgcHJvY2Vzc2VkXG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgd2FpdEZvclRyYW5zaXRpb246IHRydWUsXG5cbiAgLyoqXG4gICAqIFRocm90dGxlIGNvc3RseSBldmVudHMgYXQgbW9zdCBvbmNlIHBlciBldmVyeSB3YWl0IG1pbGxpc2Vjb25kcy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIHRocm90dGxlOiAxMCxcblxuICAvKipcbiAgICogTW92aW5nIGRpcmVjdGlvbiBtb2RlLlxuICAgKlxuICAgKiBBdmFpbGFibGUgaW5wdXRzOlxuICAgKiAtICdsdHInIC0gbGVmdCB0byByaWdodCBtb3ZlbWVudCxcbiAgICogLSAncnRsJyAtIHJpZ2h0IHRvIGxlZnQgbW92ZW1lbnQuXG4gICAqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBkaXJlY3Rpb246ICdsdHInLFxuXG4gIC8qKlxuICAgKiBUaGUgZGlzdGFuY2UgdmFsdWUgb2YgdGhlIG5leHQgYW5kIHByZXZpb3VzIHZpZXdwb3J0cyB3aGljaFxuICAgKiBoYXZlIHRvIHBlZWsgaW4gdGhlIGN1cnJlbnQgdmlldy4gQWNjZXB0cyBudW1iZXIgYW5kXG4gICAqIHBpeGVscyBhcyBhIHN0cmluZy4gTGVmdCBhbmQgcmlnaHQgcGVla2luZyBjYW4gYmVcbiAgICogc2V0IHVwIHNlcGFyYXRlbHkgd2l0aCBhIGRpcmVjdGlvbnMgb2JqZWN0LlxuICAgKlxuICAgKiBGb3IgZXhhbXBsZTpcbiAgICogYDEwMGAgLSBQZWVrIDEwMHB4IG9uIHRoZSBib3RoIHNpZGVzLlxuICAgKiB7IGJlZm9yZTogMTAwLCBhZnRlcjogNTAgfWAgLSBQZWVrIDEwMHB4IG9uIHRoZSBsZWZ0IHNpZGUgYW5kIDUwcHggb24gdGhlIHJpZ2h0IHNpZGUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ8U3RyaW5nfE9iamVjdH1cbiAgICovXG4gIHBlZWs6IDAsXG5cbiAgLyoqXG4gICAqIERlZmluZXMgaG93IG1hbnkgY2xvbmVzIG9mIGN1cnJlbnQgdmlld3BvcnQgd2lsbCBiZSBnZW5lcmF0ZWQuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBjbG9uaW5nUmF0aW86IDEsXG5cbiAgLyoqXG4gICAqIENvbGxlY3Rpb24gb2Ygb3B0aW9ucyBhcHBsaWVkIGF0IHNwZWNpZmllZCBtZWRpYSBicmVha3BvaW50cy5cbiAgICogRm9yIGV4YW1wbGU6IGRpc3BsYXkgdHdvIHNsaWRlcyBwZXIgdmlldyB1bmRlciA4MDBweC5cbiAgICogYHtcbiAgICogICAnODAwcHgnOiB7XG4gICAqICAgICBwZXJWaWV3OiAyXG4gICAqICAgfVxuICAgKiB9YFxuICAgKi9cbiAgYnJlYWtwb2ludHM6IHt9LFxuXG4gIC8qKlxuICAgKiBDb2xsZWN0aW9uIG9mIGludGVybmFsbHkgdXNlZCBIVE1MIGNsYXNzZXMuXG4gICAqXG4gICAqIEB0b2RvIFJlZmFjdG9yIGBzbGlkZXJgIGFuZCBgY2Fyb3VzZWxgIHByb3BlcnRpZXMgdG8gc2luZ2xlIGB0eXBlOiB7IHNsaWRlcjogJycsIGNhcm91c2VsOiAnJyB9YCBvYmplY3RcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIGNsYXNzZXM6IHtcbiAgICBzd2lwZWFibGU6ICdnbGlkZS0tc3dpcGVhYmxlJyxcbiAgICBkcmFnZ2luZzogJ2dsaWRlLS1kcmFnZ2luZycsXG4gICAgZGlyZWN0aW9uOiB7XG4gICAgICBsdHI6ICdnbGlkZS0tbHRyJyxcbiAgICAgIHJ0bDogJ2dsaWRlLS1ydGwnXG4gICAgfSxcbiAgICB0eXBlOiB7XG4gICAgICBzbGlkZXI6ICdnbGlkZS0tc2xpZGVyJyxcbiAgICAgIGNhcm91c2VsOiAnZ2xpZGUtLWNhcm91c2VsJ1xuICAgIH0sXG4gICAgc2xpZGU6IHtcbiAgICAgIGNsb25lOiAnZ2xpZGVfX3NsaWRlLS1jbG9uZScsXG4gICAgICBhY3RpdmU6ICdnbGlkZV9fc2xpZGUtLWFjdGl2ZSdcbiAgICB9LFxuICAgIGFycm93OiB7XG4gICAgICBkaXNhYmxlZDogJ2dsaWRlX19hcnJvdy0tZGlzYWJsZWQnXG4gICAgfSxcbiAgICBuYXY6IHtcbiAgICAgIGFjdGl2ZTogJ2dsaWRlX19idWxsZXQtLWFjdGl2ZSdcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogT3V0cHV0cyB3YXJuaW5nIG1lc3NhZ2UgdG8gdGhlIGJvd3NlciBjb25zb2xlLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gbXNnXG4gKiBAcmV0dXJuIHtWb2lkfVxuICovXG5mdW5jdGlvbiB3YXJuKG1zZykge1xuICBjb25zb2xlLmVycm9yKFwiW0dsaWRlIHdhcm5dOiBcIi5jb25jYXQobXNnKSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgdmFsdWUgZW50ZXJlZCBhcyBudW1iZXJcbiAqIG9yIHN0cmluZyB0byBpbnRlZ2VyIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gdG9JbnQodmFsdWUpIHtcbiAgcmV0dXJuIHBhcnNlSW50KHZhbHVlKTtcbn1cbi8qKlxuICogQ29udmVydHMgdmFsdWUgZW50ZXJlZCBhcyBudW1iZXJcbiAqIG9yIHN0cmluZyB0byBmbGF0IHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge051bWJlcn1cbiAqL1xuXG5mdW5jdGlvbiB0b0Zsb2F0KHZhbHVlKSB7XG4gIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcbn1cbi8qKlxuICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHsqfSAgIHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xufVxuLyoqXG4gKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZVxuICovXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gX3R5cGVvZih2YWx1ZSk7XG5cbiAgcmV0dXJuIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZSA9PT0gJ29iamVjdCcgJiYgISF2YWx1ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1taXhlZC1vcGVyYXRvcnNcbn1cbi8qKlxuICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSAgeyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cbi8qKlxuICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyB1bmRlZmluZWQuXG4gKlxuICogQHBhcmFtICB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCc7XG59XG4vKipcbiAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYW4gYXJyYXkuXG4gKlxuICogQHBhcmFtICB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUuY29uc3RydWN0b3IgPT09IEFycmF5O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW5kIGluaXRpYWxpemVzIHNwZWNpZmllZCBjb2xsZWN0aW9uIG9mIGV4dGVuc2lvbnMuXG4gKiBFYWNoIGV4dGVuc2lvbiByZWNlaXZlcyBhY2Nlc3MgdG8gaW5zdGFuY2Ugb2YgZ2xpZGUgYW5kIHJlc3Qgb2YgY29tcG9uZW50cy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZ2xpZGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbnNpb25zXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBtb3VudChnbGlkZSwgZXh0ZW5zaW9ucywgZXZlbnRzKSB7XG4gIHZhciBjb21wb25lbnRzID0ge307XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBleHRlbnNpb25zKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24oZXh0ZW5zaW9uc1tuYW1lXSkpIHtcbiAgICAgIGNvbXBvbmVudHNbbmFtZV0gPSBleHRlbnNpb25zW25hbWVdKGdsaWRlLCBjb21wb25lbnRzLCBldmVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKCdFeHRlbnNpb24gbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgX25hbWUgaW4gY29tcG9uZW50cykge1xuICAgIGlmIChpc0Z1bmN0aW9uKGNvbXBvbmVudHNbX25hbWVdLm1vdW50KSkge1xuICAgICAgY29tcG9uZW50c1tfbmFtZV0ubW91bnQoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29tcG9uZW50cztcbn1cblxuLyoqXG4gKiBEZWZpbmVzIGdldHRlciBhbmQgc2V0dGVyIHByb3BlcnR5IG9uIHRoZSBzcGVjaWZpZWQgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gb2JqICAgICAgICAgT2JqZWN0IHdoZXJlIHByb3BlcnR5IGhhcyB0byBiZSBkZWZpbmVkLlxuICogQHBhcmFtICB7U3RyaW5nfSBwcm9wICAgICAgICBOYW1lIG9mIHRoZSBkZWZpbmVkIHByb3BlcnR5LlxuICogQHBhcmFtICB7T2JqZWN0fSBkZWZpbml0aW9uICBHZXQgYW5kIHNldCBkZWZpbml0aW9ucyBmb3IgdGhlIHByb3BlcnR5LlxuICogQHJldHVybiB7Vm9pZH1cbiAqL1xuZnVuY3Rpb24gZGVmaW5lKG9iaiwgcHJvcCwgZGVmaW5pdGlvbikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCBkZWZpbml0aW9uKTtcbn1cbi8qKlxuICogU29ydHMgYXBoYWJldGljYWxseSBvYmplY3Qga2V5cy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIHNvcnRLZXlzKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5zb3J0KCkucmVkdWNlKGZ1bmN0aW9uIChyLCBrKSB7XG4gICAgcltrXSA9IG9ialtrXTtcbiAgICByZXR1cm4gcltrXSwgcjtcbiAgfSwge30pO1xufVxuLyoqXG4gKiBNZXJnZXMgcGFzc2VkIHNldHRpbmdzIG9iamVjdCB3aXRoIGRlZmF1bHQgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IGRlZmF1bHRzXG4gKiBAcGFyYW0gIHtPYmplY3R9IHNldHRpbmdzXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gbWVyZ2VPcHRpb25zKGRlZmF1bHRzLCBzZXR0aW5ncykge1xuICB2YXIgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzLCBzZXR0aW5ncyk7IC8vIGBPYmplY3QuYXNzaWduYCBkbyBub3QgZGVlcGx5IG1lcmdlIG9iamVjdHMsIHNvIHdlXG4gIC8vIGhhdmUgdG8gZG8gaXQgbWFudWFsbHkgZm9yIGV2ZXJ5IG5lc3RlZCBvYmplY3RcbiAgLy8gaW4gb3B0aW9ucy4gQWx0aG91Z2ggaXQgZG9lcyBub3QgbG9vayBzbWFydCxcbiAgLy8gaXQncyBzbWFsbGVyIGFuZCBmYXN0ZXIgdGhhbiBzb21lIGZhbmN5XG4gIC8vIG1lcmdpbmcgZGVlcC1tZXJnZSBhbGdvcml0aG0gc2NyaXB0LlxuXG4gIGlmIChzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eSgnY2xhc3NlcycpKSB7XG4gICAgb3B0aW9ucy5jbGFzc2VzID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMuY2xhc3Nlcywgc2V0dGluZ3MuY2xhc3Nlcyk7XG5cbiAgICBpZiAoc2V0dGluZ3MuY2xhc3Nlcy5oYXNPd25Qcm9wZXJ0eSgnZGlyZWN0aW9uJykpIHtcbiAgICAgIG9wdGlvbnMuY2xhc3Nlcy5kaXJlY3Rpb24gPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cy5jbGFzc2VzLmRpcmVjdGlvbiwgc2V0dGluZ3MuY2xhc3Nlcy5kaXJlY3Rpb24pO1xuICAgIH1cblxuICAgIGlmIChzZXR0aW5ncy5jbGFzc2VzLmhhc093blByb3BlcnR5KCd0eXBlJykpIHtcbiAgICAgIG9wdGlvbnMuY2xhc3Nlcy50eXBlID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMuY2xhc3Nlcy50eXBlLCBzZXR0aW5ncy5jbGFzc2VzLnR5cGUpO1xuICAgIH1cblxuICAgIGlmIChzZXR0aW5ncy5jbGFzc2VzLmhhc093blByb3BlcnR5KCdzbGlkZScpKSB7XG4gICAgICBvcHRpb25zLmNsYXNzZXMuc2xpZGUgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cy5jbGFzc2VzLnNsaWRlLCBzZXR0aW5ncy5jbGFzc2VzLnNsaWRlKTtcbiAgICB9XG5cbiAgICBpZiAoc2V0dGluZ3MuY2xhc3Nlcy5oYXNPd25Qcm9wZXJ0eSgnYXJyb3cnKSkge1xuICAgICAgb3B0aW9ucy5jbGFzc2VzLmFycm93ID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMuY2xhc3Nlcy5hcnJvdywgc2V0dGluZ3MuY2xhc3Nlcy5hcnJvdyk7XG4gICAgfVxuXG4gICAgaWYgKHNldHRpbmdzLmNsYXNzZXMuaGFzT3duUHJvcGVydHkoJ25hdicpKSB7XG4gICAgICBvcHRpb25zLmNsYXNzZXMubmF2ID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMuY2xhc3Nlcy5uYXYsIHNldHRpbmdzLmNsYXNzZXMubmF2KTtcbiAgICB9XG4gIH1cblxuICBpZiAoc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoJ2JyZWFrcG9pbnRzJykpIHtcbiAgICBvcHRpb25zLmJyZWFrcG9pbnRzID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMuYnJlYWtwb2ludHMsIHNldHRpbmdzLmJyZWFrcG9pbnRzKTtcbiAgfVxuXG4gIHJldHVybiBvcHRpb25zO1xufVxuXG52YXIgRXZlbnRzQnVzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIEV2ZW50QnVzIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRzXG4gICAqL1xuICBmdW5jdGlvbiBFdmVudHNCdXMoKSB7XG4gICAgdmFyIGV2ZW50cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXZlbnRzQnVzKTtcblxuICAgIHRoaXMuZXZlbnRzID0gZXZlbnRzO1xuICAgIHRoaXMuaG9wID0gZXZlbnRzLmhhc093blByb3BlcnR5O1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGxpc3RlbmVyIHRvIHRoZSBzcGVjaWZlZCBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGV2ZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoRXZlbnRzQnVzLCBbe1xuICAgIGtleTogXCJvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbihldmVudCwgaGFuZGxlcikge1xuICAgICAgaWYgKGlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLm9uKGV2ZW50W2ldLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gQ3JlYXRlIHRoZSBldmVudCdzIG9iamVjdCBpZiBub3QgeWV0IGNyZWF0ZWRcblxuXG4gICAgICBpZiAoIXRoaXMuaG9wLmNhbGwodGhpcy5ldmVudHMsIGV2ZW50KSkge1xuICAgICAgICB0aGlzLmV2ZW50c1tldmVudF0gPSBbXTtcbiAgICAgIH0gLy8gQWRkIHRoZSBoYW5kbGVyIHRvIHF1ZXVlXG5cblxuICAgICAgdmFyIGluZGV4ID0gdGhpcy5ldmVudHNbZXZlbnRdLnB1c2goaGFuZGxlcikgLSAxOyAvLyBQcm92aWRlIGhhbmRsZSBiYWNrIGZvciByZW1vdmFsIG9mIGV2ZW50XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLmV2ZW50c1tldmVudF1baW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSdW5zIHJlZ2lzdGVyZWQgaGFuZGxlcnMgZm9yIHNwZWNpZmllZCBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBldmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gY29udGV4dFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZW1pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbWl0KGV2ZW50LCBjb250ZXh0KSB7XG4gICAgICBpZiAoaXNBcnJheShldmVudCkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuZW1pdChldmVudFtpXSwgY29udGV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIElmIHRoZSBldmVudCBkb2Vzbid0IGV4aXN0LCBvciB0aGVyZSdzIG5vIGhhbmRsZXJzIGluIHF1ZXVlLCBqdXN0IGxlYXZlXG5cblxuICAgICAgaWYgKCF0aGlzLmhvcC5jYWxsKHRoaXMuZXZlbnRzLCBldmVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBDeWNsZSB0aHJvdWdoIGV2ZW50cyBxdWV1ZSwgZmlyZSFcblxuXG4gICAgICB0aGlzLmV2ZW50c1tldmVudF0uZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpdGVtKGNvbnRleHQgfHwge30pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEV2ZW50c0J1cztcbn0oKTtcblxudmFyIEdsaWRlJDEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcclxuICAgKiBDb25zdHJ1Y3QgZ2xpZGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHNlbGVjdG9yXHJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICovXG4gIGZ1bmN0aW9uIEdsaWRlKHNlbGVjdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEdsaWRlKTtcblxuICAgIHRoaXMuX2MgPSB7fTtcbiAgICB0aGlzLl90ID0gW107XG4gICAgdGhpcy5fZSA9IG5ldyBFdmVudHNCdXMoKTtcbiAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBtZXJnZU9wdGlvbnMoZGVmYXVsdHMsIG9wdGlvbnMpO1xuICAgIHRoaXMuaW5kZXggPSB0aGlzLnNldHRpbmdzLnN0YXJ0QXQ7XG4gIH1cbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZXMgZ2xpZGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXh0ZW5zaW9ucyBDb2xsZWN0aW9uIG9mIGV4dGVuc2lvbnMgdG8gaW5pdGlhbGl6ZS5cclxuICAgKiBAcmV0dXJuIHtHbGlkZX1cclxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhHbGlkZSwgW3tcbiAgICBrZXk6IFwibW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW91bnQkMSgpIHtcbiAgICAgIHZhciBleHRlbnNpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgdGhpcy5fZS5lbWl0KCdtb3VudC5iZWZvcmUnKTtcblxuICAgICAgaWYgKGlzT2JqZWN0KGV4dGVuc2lvbnMpKSB7XG4gICAgICAgIHRoaXMuX2MgPSBtb3VudCh0aGlzLCBleHRlbnNpb25zLCB0aGlzLl9lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oJ1lvdSBuZWVkIHRvIHByb3ZpZGUgYSBvYmplY3Qgb24gYG1vdW50KClgJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2UuZW1pdCgnbW91bnQuYWZ0ZXInKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogQ29sbGVjdHMgYW4gaW5zdGFuY2UgYHRyYW5zbGF0ZWAgdHJhbnNmb3JtZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSB0cmFuc2Zvcm1lcnMgQ29sbGVjdGlvbiBvZiB0cmFuc2Zvcm1lcnMuXHJcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtdXRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbXV0YXRlKCkge1xuICAgICAgdmFyIHRyYW5zZm9ybWVycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG5cbiAgICAgIGlmIChpc0FycmF5KHRyYW5zZm9ybWVycykpIHtcbiAgICAgICAgdGhpcy5fdCA9IHRyYW5zZm9ybWVycztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oJ1lvdSBuZWVkIHRvIHByb3ZpZGUgYSBhcnJheSBvbiBgbXV0YXRlKClgJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgZ2xpZGUgd2l0aCBzcGVjaWZpZWQgc2V0dGluZ3MuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzXHJcbiAgICAgKiBAcmV0dXJuIHtHbGlkZX1cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgIHZhciBzZXR0aW5ncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICB0aGlzLnNldHRpbmdzID0gbWVyZ2VPcHRpb25zKHRoaXMuc2V0dGluZ3MsIHNldHRpbmdzKTtcblxuICAgICAgaWYgKHNldHRpbmdzLmhhc093blByb3BlcnR5KCdzdGFydEF0JykpIHtcbiAgICAgICAgdGhpcy5pbmRleCA9IHNldHRpbmdzLnN0YXJ0QXQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2UuZW1pdCgndXBkYXRlJyk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIENoYW5nZSBzbGlkZSB3aXRoIHNwZWNpZmllZCBwYXR0ZXJuLiBBIHBhdHRlcm4gbXVzdCBiZSBpbiB0aGUgc3BlY2lhbCBmb3JtYXQ6XHJcbiAgICAgKiBgPmAgLSBNb3ZlIG9uZSBmb3J3YXJkXHJcbiAgICAgKiBgPGAgLSBNb3ZlIG9uZSBiYWNrd2FyZFxyXG4gICAgICogYD17aX1gIC0gR28gdG8ge2l9IHplcm8tYmFzZWQgc2xpZGUgKGVxLiAnPTEnLCB3aWxsIGdvIHRvIHNlY29uZCBzbGlkZSlcclxuICAgICAqIGA+PmAgLSBSZXdpbmRzIHRvIGVuZCAobGFzdCBzbGlkZSlcclxuICAgICAqIGA8PGAgLSBSZXdpbmRzIHRvIHN0YXJ0IChmaXJzdCBzbGlkZSlcclxuICAgICAqIGB8PmAgLSBNb3ZlIG9uZSB2aWV3cG9ydCBmb3J3YXJkXHJcbiAgICAgKiBgfDxgIC0gTW92ZSBvbmUgdmlld3BvcnQgYmFja3dhcmRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0dGVyblxyXG4gICAgICogQHJldHVybiB7R2xpZGV9XHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdvKHBhdHRlcm4pIHtcbiAgICAgIHRoaXMuX2MuUnVuLm1ha2UocGF0dGVybik7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIE1vdmUgdHJhY2sgYnkgc3BlY2lmaWVkIGRpc3RhbmNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkaXN0YW5jZVxyXG4gICAgICogQHJldHVybiB7R2xpZGV9XHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZShkaXN0YW5jZSkge1xuICAgICAgdGhpcy5fYy5UcmFuc2l0aW9uLmRpc2FibGUoKTtcblxuICAgICAgdGhpcy5fYy5Nb3ZlLm1ha2UoZGlzdGFuY2UpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95IGluc3RhbmNlIGFuZCByZXZlcnQgYWxsIGNoYW5nZXMgZG9uZSBieSB0aGlzLl9jLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge0dsaWRlfVxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLl9lLmVtaXQoJ2Rlc3Ryb3knKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogU3RhcnQgaW5zdGFuY2UgYXV0b3BsYXlpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufE51bWJlcn0gaW50ZXJ2YWwgUnVuIGF1dG9wbGF5aW5nIHdpdGggcGFzc2VkIGludGVydmFsIHJlZ2FyZGxlc3Mgb2YgYGF1dG9wbGF5YCBzZXR0aW5nc1xyXG4gICAgICogQHJldHVybiB7R2xpZGV9XHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBsYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGxheSgpIHtcbiAgICAgIHZhciBpbnRlcnZhbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG5cbiAgICAgIGlmIChpbnRlcnZhbCkge1xuICAgICAgICB0aGlzLnNldHRpbmdzLmF1dG9wbGF5ID0gaW50ZXJ2YWw7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2UuZW1pdCgncGxheScpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBTdG9wIGluc3RhbmNlIGF1dG9wbGF5aW5nLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge0dsaWRlfVxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwYXVzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICAgIHRoaXMuX2UuZW1pdCgncGF1c2UnKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogU2V0cyBnbGlkZSBpbnRvIGEgaWRsZSBzdGF0dXMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7R2xpZGV9XHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc2FibGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICAgIHRoaXMuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogU2V0cyBnbGlkZSBpbnRvIGEgYWN0aXZlIHN0YXR1cy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtHbGlkZX1cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZW5hYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEFkZHMgY3V1dG9tIGV2ZW50IGxpc3RlbmVyIHdpdGggaGFuZGxlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd8QXJyYXl9IGV2ZW50XHJcbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gaGFuZGxlclxyXG4gICAgICogQHJldHVybiB7R2xpZGV9XHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgICB0aGlzLl9lLm9uKGV2ZW50LCBoYW5kbGVyKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIGdsaWRlIGlzIGEgcHJlY2lzZWQgdHlwZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWVcclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzVHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1R5cGUobmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3MudHlwZSA9PT0gbmFtZTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHZhbHVlIG9mIHRoZSBjb3JlIG9wdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXR0aW5nc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX287XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogU2V0cyB2YWx1ZSBvZiB0aGUgY29yZSBvcHRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gb1xyXG4gICAgICogQHJldHVybiB7Vm9pZH1cclxuICAgICAqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChvKSB7XG4gICAgICBpZiAoaXNPYmplY3QobykpIHtcbiAgICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKCdPcHRpb25zIG11c3QgYmUgYW4gYG9iamVjdGAgaW5zdGFuY2UuJyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogR2V0cyBjdXJyZW50IGluZGV4IG9mIHRoZSBzbGlkZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpbmRleFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2k7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogU2V0cyBjdXJyZW50IGluZGV4IGEgc2xpZGVyLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgICAqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChpKSB7XG4gICAgICB0aGlzLl9pID0gdG9JbnQoaSk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0eXBlIG5hbWUgb2YgdGhlIHNsaWRlci5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInR5cGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzLnR5cGU7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogR2V0cyB2YWx1ZSBvZiB0aGUgaWRsZSBzdGF0dXMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzYWJsZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFNldHMgdmFsdWUgb2YgdGhlIGlkbGUgc3RhdHVzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoc3RhdHVzKSB7XG4gICAgICB0aGlzLl9kID0gISFzdGF0dXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEdsaWRlO1xufSgpO1xuXG5mdW5jdGlvbiBSdW4gKEdsaWRlLCBDb21wb25lbnRzLCBFdmVudHMpIHtcbiAgdmFyIFJ1biA9IHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhdXRvcnVubmluZyBvZiB0aGUgZ2xpZGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIG1vdW50OiBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICAgIHRoaXMuX28gPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZXMgZ2xpZGVzIHJ1bm5pbmcgYmFzZWQgb24gdGhlIHBhc3NlZCBtb3Zpbmcgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1vdmVcbiAgICAgKi9cbiAgICBtYWtlOiBmdW5jdGlvbiBtYWtlKG1vdmUpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICghR2xpZGUuZGlzYWJsZWQpIHtcbiAgICAgICAgIUdsaWRlLnNldHRpbmdzLndhaXRGb3JUcmFuc2l0aW9uIHx8IEdsaWRlLmRpc2FibGUoKTtcbiAgICAgICAgdGhpcy5tb3ZlID0gbW92ZTtcbiAgICAgICAgRXZlbnRzLmVtaXQoJ3J1bi5iZWZvcmUnLCB0aGlzLm1vdmUpO1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZSgpO1xuICAgICAgICBFdmVudHMuZW1pdCgncnVuJywgdGhpcy5tb3ZlKTtcbiAgICAgICAgQ29tcG9uZW50cy5UcmFuc2l0aW9uLmFmdGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoX3RoaXMuaXNTdGFydCgpKSB7XG4gICAgICAgICAgICBFdmVudHMuZW1pdCgncnVuLnN0YXJ0JywgX3RoaXMubW92ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF90aGlzLmlzRW5kKCkpIHtcbiAgICAgICAgICAgIEV2ZW50cy5lbWl0KCdydW4uZW5kJywgX3RoaXMubW92ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF90aGlzLmlzT2Zmc2V0KCkpIHtcbiAgICAgICAgICAgIF90aGlzLl9vID0gZmFsc2U7XG4gICAgICAgICAgICBFdmVudHMuZW1pdCgncnVuLm9mZnNldCcsIF90aGlzLm1vdmUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIEV2ZW50cy5lbWl0KCdydW4uYWZ0ZXInLCBfdGhpcy5tb3ZlKTtcbiAgICAgICAgICBHbGlkZS5lbmFibGUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgY3VycmVudCBpbmRleCBiYXNlZCBvbiBkZWZpbmVkIG1vdmUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ8VW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGNhbGN1bGF0ZTogZnVuY3Rpb24gY2FsY3VsYXRlKCkge1xuICAgICAgdmFyIG1vdmUgPSB0aGlzLm1vdmUsXG4gICAgICAgICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgICB2YXIgc3RlcHMgPSBtb3ZlLnN0ZXBzLFxuICAgICAgICAgIGRpcmVjdGlvbiA9IG1vdmUuZGlyZWN0aW9uOyAvLyBCeSBkZWZhdWx0IGFzc3VtZSB0aGF0IHNpemUgb2YgdmlldyBpcyBlcXVhbCB0byBvbmUgc2xpZGVcblxuICAgICAgdmFyIHZpZXdTaXplID0gMTsgLy8gV2hpbGUgZGlyZWN0aW9uIGlzIGA9YCB3ZSB3YW50IGp1bXAgdG9cbiAgICAgIC8vIGEgc3BlY2lmaWVkIGluZGV4IGRlc2NyaWJlZCBpbiBzdGVwcy5cblxuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJz0nKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIGJvdW5kIGlzIHRydWUsIFxuICAgICAgICAvLyBhcyB3ZSB3YW50IHRvIGF2b2lkIHdoaXRlc3BhY2VzLlxuICAgICAgICBpZiAoR2xpZGUuc2V0dGluZ3MuYm91bmQgJiYgdG9JbnQoc3RlcHMpID4gbGVuZ3RoKSB7XG4gICAgICAgICAgR2xpZGUuaW5kZXggPSBsZW5ndGg7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgR2xpZGUuaW5kZXggPSBzdGVwcztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBXaGVuIHBhdHRlcm4gaXMgZXF1YWwgdG8gYD4+YCB3ZSB3YW50XG4gICAgICAvLyBmYXN0IGZvcndhcmQgdG8gdGhlIGxhc3Qgc2xpZGUuXG5cblxuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJz4nICYmIHN0ZXBzID09PSAnPicpIHtcbiAgICAgICAgR2xpZGUuaW5kZXggPSBsZW5ndGg7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gV2hlbiBwYXR0ZXJuIGlzIGVxdWFsIHRvIGA8PGAgd2Ugd2FudFxuICAgICAgLy8gZmFzdCBmb3J3YXJkIHRvIHRoZSBmaXJzdCBzbGlkZS5cblxuXG4gICAgICBpZiAoZGlyZWN0aW9uID09PSAnPCcgJiYgc3RlcHMgPT09ICc8Jykge1xuICAgICAgICBHbGlkZS5pbmRleCA9IDA7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gcGFnaW5hdGlvbiBtb3ZlbWVudFxuXG5cbiAgICAgIGlmIChkaXJlY3Rpb24gPT09ICd8Jykge1xuICAgICAgICB2aWV3U2l6ZSA9IEdsaWRlLnNldHRpbmdzLnBlclZpZXcgfHwgMTtcbiAgICAgIH0gLy8gd2UgYXJlIG1vdmluZyBmb3J3YXJkXG5cblxuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJz4nIHx8IGRpcmVjdGlvbiA9PT0gJ3wnICYmIHN0ZXBzID09PSAnPicpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gY2FsY3VsYXRlRm9yd2FyZEluZGV4KHZpZXdTaXplKTtcblxuICAgICAgICBpZiAoaW5kZXggPiBsZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLl9vID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIEdsaWRlLmluZGV4ID0gbm9ybWFsaXplRm9yd2FyZEluZGV4KGluZGV4LCB2aWV3U2l6ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gd2UgYXJlIG1vdmluZyBiYWNrd2FyZFxuXG5cbiAgICAgIGlmIChkaXJlY3Rpb24gPT09ICc8JyB8fCBkaXJlY3Rpb24gPT09ICd8JyAmJiBzdGVwcyA9PT0gJzwnKSB7XG4gICAgICAgIHZhciBfaW5kZXggPSBjYWxjdWxhdGVCYWNrd2FyZEluZGV4KHZpZXdTaXplKTtcblxuICAgICAgICBpZiAoX2luZGV4IDwgMCkge1xuICAgICAgICAgIHRoaXMuX28gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgR2xpZGUuaW5kZXggPSBub3JtYWxpemVCYWNrd2FyZEluZGV4KF9pbmRleCwgdmlld1NpemUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHdhcm4oXCJJbnZhbGlkIGRpcmVjdGlvbiBwYXR0ZXJuIFtcIi5jb25jYXQoZGlyZWN0aW9uKS5jb25jYXQoc3RlcHMsIFwiXSBoYXMgYmVlbiB1c2VkXCIpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHdlIGFyZSBvbiB0aGUgZmlyc3Qgc2xpZGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzU3RhcnQ6IGZ1bmN0aW9uIGlzU3RhcnQoKSB7XG4gICAgICByZXR1cm4gR2xpZGUuaW5kZXggPD0gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHdlIGFyZSBvbiB0aGUgbGFzdCBzbGlkZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNFbmQ6IGZ1bmN0aW9uIGlzRW5kKCkge1xuICAgICAgcmV0dXJuIEdsaWRlLmluZGV4ID49IHRoaXMubGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgd2UgYXJlIG1ha2luZyBhIG9mZnNldCBydW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGlyZWN0aW9uXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc09mZnNldDogZnVuY3Rpb24gaXNPZmZzZXQoKSB7XG4gICAgICB2YXIgZGlyZWN0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICghZGlyZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX28pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSAvLyBkaWQgd2UgdmlldyB0byB0aGUgcmlnaHQ/XG5cblxuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ3w+Jykge1xuICAgICAgICByZXR1cm4gdGhpcy5tb3ZlLmRpcmVjdGlvbiA9PT0gJ3wnICYmIHRoaXMubW92ZS5zdGVwcyA9PT0gJz4nO1xuICAgICAgfSAvLyBkaWQgd2UgdmlldyB0byB0aGUgbGVmdD9cblxuXG4gICAgICBpZiAoZGlyZWN0aW9uID09PSAnfDwnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vdmUuZGlyZWN0aW9uID09PSAnfCcgJiYgdGhpcy5tb3ZlLnN0ZXBzID09PSAnPCc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLm1vdmUuZGlyZWN0aW9uID09PSBkaXJlY3Rpb247XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBib3VuZCBtb2RlIGlzIGFjdGl2ZVxuICAgICAqXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0JvdW5kOiBmdW5jdGlvbiBpc0JvdW5kKCkge1xuICAgICAgcmV0dXJuIEdsaWRlLmlzVHlwZSgnc2xpZGVyJykgJiYgR2xpZGUuc2V0dGluZ3MuZm9jdXNBdCAhPT0gJ2NlbnRlcicgJiYgR2xpZGUuc2V0dGluZ3MuYm91bmQ7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogUmV0dXJucyBpbmRleCB2YWx1ZSB0byBtb3ZlIGZvcndhcmQvdG8gdGhlIHJpZ2h0XG4gICAqXG4gICAqIEBwYXJhbSB2aWV3U2l6ZVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKi9cblxuICBmdW5jdGlvbiBjYWxjdWxhdGVGb3J3YXJkSW5kZXgodmlld1NpemUpIHtcbiAgICB2YXIgaW5kZXggPSBHbGlkZS5pbmRleDtcblxuICAgIGlmIChHbGlkZS5pc1R5cGUoJ2Nhcm91c2VsJykpIHtcbiAgICAgIHJldHVybiBpbmRleCArIHZpZXdTaXplO1xuICAgIH1cblxuICAgIHJldHVybiBpbmRleCArICh2aWV3U2l6ZSAtIGluZGV4ICUgdmlld1NpemUpO1xuICB9XG4gIC8qKlxuICAgKiBOb3JtYWxpemVzIHRoZSBnaXZlbiBmb3J3YXJkIGluZGV4IGJhc2VkIG9uIGdsaWRlIHNldHRpbmdzLCBwcmV2ZW50aW5nIGl0IHRvIGV4Y2VlZCBjZXJ0YWluIGJvdW5kYXJpZXNcbiAgICpcbiAgICogQHBhcmFtIGluZGV4XG4gICAqIEBwYXJhbSBsZW5ndGhcbiAgICogQHBhcmFtIHZpZXdTaXplXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplRm9yd2FyZEluZGV4KGluZGV4LCB2aWV3U2l6ZSkge1xuICAgIHZhciBsZW5ndGggPSBSdW4ubGVuZ3RoO1xuXG4gICAgaWYgKGluZGV4IDw9IGxlbmd0aCkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cblxuICAgIGlmIChHbGlkZS5pc1R5cGUoJ2Nhcm91c2VsJykpIHtcbiAgICAgIHJldHVybiBpbmRleCAtIChsZW5ndGggKyAxKTtcbiAgICB9XG5cbiAgICBpZiAoR2xpZGUuc2V0dGluZ3MucmV3aW5kKSB7XG4gICAgICAvLyBib3VuZCBkb2VzIGZ1bm55IHRoaW5ncyB3aXRoIHRoZSBsZW5ndGgsIHRoZXJlZm9yIHdlIGhhdmUgdG8gYmUgY2VydGFpblxuICAgICAgLy8gdGhhdCB3ZSBhcmUgb24gdGhlIGxhc3QgcG9zc2libGUgaW5kZXggdmFsdWUgZ2l2ZW4gYnkgYm91bmRcbiAgICAgIGlmIChSdW4uaXNCb3VuZCgpICYmICFSdW4uaXNFbmQoKSkge1xuICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAoUnVuLmlzQm91bmQoKSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gTWF0aC5mbG9vcihsZW5ndGggLyB2aWV3U2l6ZSkgKiB2aWV3U2l6ZTtcbiAgfVxuICAvKipcbiAgICogQ2FsY3VsYXRlcyBpbmRleCB2YWx1ZSB0byBtb3ZlIGJhY2t3YXJkL3RvIHRoZSBsZWZ0XG4gICAqXG4gICAqIEBwYXJhbSB2aWV3U2l6ZVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZUJhY2t3YXJkSW5kZXgodmlld1NpemUpIHtcbiAgICB2YXIgaW5kZXggPSBHbGlkZS5pbmRleDtcblxuICAgIGlmIChHbGlkZS5pc1R5cGUoJ2Nhcm91c2VsJykpIHtcbiAgICAgIHJldHVybiBpbmRleCAtIHZpZXdTaXplO1xuICAgIH0gLy8gZW5zdXJlIG91ciBiYWNrIG5hdmlnYXRpb24gcmVzdWx0cyBpbiB0aGUgc2FtZSBpbmRleCBhcyBhIGZvcndhcmQgbmF2aWdhdGlvblxuICAgIC8vIHRvIGV4cGVyaWVuY2UgYSBob21vZ2VuZW91cyBwYWdpbmdcblxuXG4gICAgdmFyIHZpZXcgPSBNYXRoLmNlaWwoaW5kZXggLyB2aWV3U2l6ZSk7XG4gICAgcmV0dXJuICh2aWV3IC0gMSkgKiB2aWV3U2l6ZTtcbiAgfVxuICAvKipcbiAgICogTm9ybWFsaXplcyB0aGUgZ2l2ZW4gYmFja3dhcmQgaW5kZXggYmFzZWQgb24gZ2xpZGUgc2V0dGluZ3MsIHByZXZlbnRpbmcgaXQgdG8gZXhjZWVkIGNlcnRhaW4gYm91bmRhcmllc1xuICAgKlxuICAgKiBAcGFyYW0gaW5kZXhcbiAgICogQHBhcmFtIGxlbmd0aFxuICAgKiBAcGFyYW0gdmlld1NpemVcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplQmFja3dhcmRJbmRleChpbmRleCwgdmlld1NpemUpIHtcbiAgICB2YXIgbGVuZ3RoID0gUnVuLmxlbmd0aDtcblxuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuXG4gICAgaWYgKEdsaWRlLmlzVHlwZSgnY2Fyb3VzZWwnKSkge1xuICAgICAgcmV0dXJuIGluZGV4ICsgKGxlbmd0aCArIDEpO1xuICAgIH1cblxuICAgIGlmIChHbGlkZS5zZXR0aW5ncy5yZXdpbmQpIHtcbiAgICAgIC8vIGJvdW5kIGRvZXMgZnVubnkgdGhpbmdzIHdpdGggdGhlIGxlbmd0aCwgdGhlcmVmb3Igd2UgaGF2ZSB0byBiZSBjZXJ0YWluXG4gICAgICAvLyB0aGF0IHdlIGFyZSBvbiBmaXJzdCBwb3NzaWJsZSBpbmRleCB2YWx1ZSBiZWZvcmUgd2UgdG8gcmV3aW5kIHRvIHRoZSBsZW5ndGggZ2l2ZW4gYnkgYm91bmRcbiAgICAgIGlmIChSdW4uaXNCb3VuZCgpICYmIFJ1bi5pc1N0YXJ0KCkpIHtcbiAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE1hdGguZmxvb3IobGVuZ3RoIC8gdmlld1NpemUpICogdmlld1NpemU7XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBkZWZpbmUoUnVuLCAnbW92ZScsIHtcbiAgICAvKipcbiAgICAgKiBHZXRzIHZhbHVlIG9mIHRoZSBtb3ZlIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB2YWx1ZSBvZiB0aGUgbW92ZSBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB2YXIgc3RlcCA9IHZhbHVlLnN1YnN0cigxKTtcbiAgICAgIHRoaXMuX20gPSB7XG4gICAgICAgIGRpcmVjdGlvbjogdmFsdWUuc3Vic3RyKDAsIDEpLFxuICAgICAgICBzdGVwczogc3RlcCA/IHRvSW50KHN0ZXApID8gdG9JbnQoc3RlcCkgOiBzdGVwIDogMFxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuICBkZWZpbmUoUnVuLCAnbGVuZ3RoJywge1xuICAgIC8qKlxuICAgICAqIEdldHMgdmFsdWUgb2YgdGhlIHJ1bm5pbmcgZGlzdGFuY2UgYmFzZWRcbiAgICAgKiBvbiB6ZXJvLWluZGV4aW5nIG51bWJlciBvZiBzbGlkZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgc2V0dGluZ3MgPSBHbGlkZS5zZXR0aW5ncztcbiAgICAgIHZhciBsZW5ndGggPSBDb21wb25lbnRzLkh0bWwuc2xpZGVzLmxlbmd0aDsgLy8gSWYgdGhlIGBib3VuZGAgb3B0aW9uIGlzIGFjdGl2ZSwgYSBtYXhpbXVtIHJ1bm5pbmcgZGlzdGFuY2Ugc2hvdWxkIGJlXG4gICAgICAvLyByZWR1Y2VkIGJ5IGBwZXJWaWV3YCBhbmQgYGZvY3VzQXRgIHNldHRpbmdzLiBSdW5uaW5nIGRpc3RhbmNlXG4gICAgICAvLyBzaG91bGQgZW5kIGJlZm9yZSBjcmVhdGluZyBhbiBlbXB0eSBzcGFjZSBhZnRlciBpbnN0YW5jZS5cblxuICAgICAgaWYgKHRoaXMuaXNCb3VuZCgpKSB7XG4gICAgICAgIHJldHVybiBsZW5ndGggLSAxIC0gKHRvSW50KHNldHRpbmdzLnBlclZpZXcpIC0gMSkgKyB0b0ludChzZXR0aW5ncy5mb2N1c0F0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxlbmd0aCAtIDE7XG4gICAgfVxuICB9KTtcbiAgZGVmaW5lKFJ1biwgJ29mZnNldCcsIHtcbiAgICAvKipcbiAgICAgKiBHZXRzIHN0YXR1cyBvZiB0aGUgb2Zmc2V0dGluZyBmbGFnLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBSdW47XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGN1cnJlbnQgdGltZS5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIG5vdygpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgd2hlbiBpbnZva2VkLCB3aWxsIG9ubHkgYmUgdHJpZ2dlcmVkXG4gKiBhdCBtb3N0IG9uY2UgZHVyaW5nIGEgZ2l2ZW4gd2luZG93IG9mIHRpbWUuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY1xuICogQHBhcmFtIHtOdW1iZXJ9IHdhaXRcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmVcbiAqL1xuXG5mdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciB0aW1lb3V0LCBjb250ZXh0LCBhcmdzLCByZXN1bHQ7XG4gIHZhciBwcmV2aW91cyA9IDA7XG4gIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuXG4gIHZhciBsYXRlciA9IGZ1bmN0aW9uIGxhdGVyKCkge1xuICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBub3coKTtcbiAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICB9O1xuXG4gIHZhciB0aHJvdHRsZWQgPSBmdW5jdGlvbiB0aHJvdHRsZWQoKSB7XG4gICAgdmFyIGF0ID0gbm93KCk7XG4gICAgaWYgKCFwcmV2aW91cyAmJiBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlKSBwcmV2aW91cyA9IGF0O1xuICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKGF0IC0gcHJldmlvdXMpO1xuICAgIGNvbnRleHQgPSB0aGlzO1xuICAgIGFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICBpZiAocmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gd2FpdCkge1xuICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcHJldmlvdXMgPSBhdDtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKCF0aW1lb3V0ICYmIG9wdGlvbnMudHJhaWxpbmcgIT09IGZhbHNlKSB7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgcmVtYWluaW5nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHRocm90dGxlZC5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIHByZXZpb3VzID0gMDtcbiAgICB0aW1lb3V0ID0gY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICB9O1xuXG4gIHJldHVybiB0aHJvdHRsZWQ7XG59XG5cbnZhciBNQVJHSU5fVFlQRSA9IHtcbiAgbHRyOiBbJ21hcmdpbkxlZnQnLCAnbWFyZ2luUmlnaHQnXSxcbiAgcnRsOiBbJ21hcmdpblJpZ2h0JywgJ21hcmdpbkxlZnQnXVxufTtcbmZ1bmN0aW9uIEdhcHMgKEdsaWRlLCBDb21wb25lbnRzLCBFdmVudHMpIHtcbiAgdmFyIEdhcHMgPSB7XG4gICAgLyoqXG4gICAgICogQXBwbGllcyBnYXBzIGJldHdlZW4gc2xpZGVzLiBGaXJzdCBhbmQgbGFzdFxuICAgICAqIHNsaWRlcyBkbyBub3QgcmVjZWl2ZSBpdCdzIGVkZ2UgbWFyZ2lucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTENvbGxlY3Rpb259IHNsaWRlc1xuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgYXBwbHk6IGZ1bmN0aW9uIGFwcGx5KHNsaWRlcykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNsaWRlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgc3R5bGUgPSBzbGlkZXNbaV0uc3R5bGU7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBDb21wb25lbnRzLkRpcmVjdGlvbi52YWx1ZTtcblxuICAgICAgICBpZiAoaSAhPT0gMCkge1xuICAgICAgICAgIHN0eWxlW01BUkdJTl9UWVBFW2RpcmVjdGlvbl1bMF1dID0gXCJcIi5jb25jYXQodGhpcy52YWx1ZSAvIDIsIFwicHhcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3R5bGVbTUFSR0lOX1RZUEVbZGlyZWN0aW9uXVswXV0gPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpICE9PSBzbGlkZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIHN0eWxlW01BUkdJTl9UWVBFW2RpcmVjdGlvbl1bMV1dID0gXCJcIi5jb25jYXQodGhpcy52YWx1ZSAvIDIsIFwicHhcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3R5bGVbTUFSR0lOX1RZUEVbZGlyZWN0aW9uXVsxXV0gPSAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGdhcHMgZnJvbSB0aGUgc2xpZGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MQ29sbGVjdGlvbn0gc2xpZGVzXG4gICAgICogQHJldHVybnMge1ZvaWR9XG4gICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShzbGlkZXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzbGlkZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIHN0eWxlID0gc2xpZGVzW2ldLnN0eWxlO1xuICAgICAgICBzdHlsZS5tYXJnaW5MZWZ0ID0gJyc7XG4gICAgICAgIHN0eWxlLm1hcmdpblJpZ2h0ID0gJyc7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBkZWZpbmUoR2FwcywgJ3ZhbHVlJywge1xuICAgIC8qKlxuICAgICAqIEdldHMgdmFsdWUgb2YgdGhlIGdhcC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdG9JbnQoR2xpZGUuc2V0dGluZ3MuZ2FwKTtcbiAgICB9XG4gIH0pO1xuICBkZWZpbmUoR2FwcywgJ2dyb3cnLCB7XG4gICAgLyoqXG4gICAgICogR2V0cyBhZGRpdGlvbmFsIGRpbWVuc2lvbnMgdmFsdWUgY2F1c2VkIGJ5IGdhcHMuXG4gICAgICogVXNlZCB0byBpbmNyZWFzZSB3aWR0aCBvZiB0aGUgc2xpZGVzIHdyYXBwZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIEdhcHMudmFsdWUgKiBDb21wb25lbnRzLlNpemVzLmxlbmd0aDtcbiAgICB9XG4gIH0pO1xuICBkZWZpbmUoR2FwcywgJ3JlZHVjdG9yJywge1xuICAgIC8qKlxuICAgICAqIEdldHMgcmVkdWN0aW9uIHZhbHVlIGNhdXNlZCBieSBnYXBzLlxuICAgICAqIFVzZWQgdG8gc3VidHJhY3Qgd2lkdGggb2YgdGhlIHNsaWRlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgcGVyVmlldyA9IEdsaWRlLnNldHRpbmdzLnBlclZpZXc7XG4gICAgICByZXR1cm4gR2Fwcy52YWx1ZSAqIChwZXJWaWV3IC0gMSkgLyBwZXJWaWV3O1xuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgKiBBcHBseSBjYWxjdWxhdGVkIGdhcHM6XG4gICAqIC0gYWZ0ZXIgYnVpbGRpbmcsIHNvIHNsaWRlcyAoaW5jbHVkaW5nIGNsb25lcykgd2lsbCByZWNlaXZlIHByb3BlciBtYXJnaW5zXG4gICAqIC0gb24gdXBkYXRpbmcgdmlhIEFQSSwgdG8gcmVjYWxjdWxhdGUgZ2FwcyB3aXRoIG5ldyBvcHRpb25zXG4gICAqL1xuXG4gIEV2ZW50cy5vbihbJ2J1aWxkLmFmdGVyJywgJ3VwZGF0ZSddLCB0aHJvdHRsZShmdW5jdGlvbiAoKSB7XG4gICAgR2Fwcy5hcHBseShDb21wb25lbnRzLkh0bWwud3JhcHBlci5jaGlsZHJlbik7XG4gIH0sIDMwKSk7XG4gIC8qKlxuICAgKiBSZW1vdmUgZ2FwczpcbiAgICogLSBvbiBkZXN0cm95aW5nIHRvIGJyaW5nIG1hcmt1cCB0byBpdHMgaW5pdGFsIHN0YXRlXG4gICAqL1xuXG4gIEV2ZW50cy5vbignZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICBHYXBzLnJlbW92ZShDb21wb25lbnRzLkh0bWwud3JhcHBlci5jaGlsZHJlbik7XG4gIH0pO1xuICByZXR1cm4gR2Fwcztcbn1cblxuLyoqXG4gKiBGaW5kcyBzaWJsaW5ncyBub2RlcyBvZiB0aGUgcGFzc2VkIG5vZGUuXG4gKlxuICogQHBhcmFtICB7RWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHNpYmxpbmdzKG5vZGUpIHtcbiAgaWYgKG5vZGUgJiYgbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgdmFyIG4gPSBub2RlLnBhcmVudE5vZGUuZmlyc3RDaGlsZDtcbiAgICB2YXIgbWF0Y2hlZCA9IFtdO1xuXG4gICAgZm9yICg7IG47IG4gPSBuLm5leHRTaWJsaW5nKSB7XG4gICAgICBpZiAobi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBub2RlKSB7XG4gICAgICAgIG1hdGNoZWQucHVzaChuKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWF0Y2hlZDtcbiAgfVxuXG4gIHJldHVybiBbXTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIHBhc3NlZCBub2RlIGV4aXN0IGFuZCBpcyBhIHZhbGlkIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtICB7RWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBleGlzdChub2RlKSB7XG4gIGlmIChub2RlICYmIG5vZGUgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTEVsZW1lbnQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogQ29lcmNlcyBhIE5vZGVMaXN0IHRvIGFuIEFycmF5LlxuICpcbiAqIEBwYXJhbSAge05vZGVMaXN0fSBub2RlTGlzdFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuZnVuY3Rpb24gdG9BcnJheShub2RlTGlzdCkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobm9kZUxpc3QpO1xufVxuXG52YXIgVFJBQ0tfU0VMRUNUT1IgPSAnW2RhdGEtZ2xpZGUtZWw9XCJ0cmFja1wiXSc7XG5mdW5jdGlvbiBIdG1sIChHbGlkZSwgQ29tcG9uZW50cywgRXZlbnRzKSB7XG4gIHZhciBIdG1sID0ge1xuICAgIC8qKlxuICAgICAqIFNldHVwIHNsaWRlciBIVE1MIG5vZGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtHbGlkZX0gZ2xpZGVcbiAgICAgKi9cbiAgICBtb3VudDogZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgICB0aGlzLnJvb3QgPSBHbGlkZS5zZWxlY3RvcjtcbiAgICAgIHRoaXMudHJhY2sgPSB0aGlzLnJvb3QucXVlcnlTZWxlY3RvcihUUkFDS19TRUxFQ1RPUik7XG4gICAgICB0aGlzLmNvbGxlY3RTbGlkZXMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29sbGVjdCBzbGlkZXNcbiAgICAgKi9cbiAgICBjb2xsZWN0U2xpZGVzOiBmdW5jdGlvbiBjb2xsZWN0U2xpZGVzKCkge1xuICAgICAgdGhpcy5zbGlkZXMgPSB0b0FycmF5KHRoaXMud3JhcHBlci5jaGlsZHJlbikuZmlsdGVyKGZ1bmN0aW9uIChzbGlkZSkge1xuICAgICAgICByZXR1cm4gIXNsaWRlLmNsYXNzTGlzdC5jb250YWlucyhHbGlkZS5zZXR0aW5ncy5jbGFzc2VzLnNsaWRlLmNsb25lKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgZGVmaW5lKEh0bWwsICdyb290Jywge1xuICAgIC8qKlxuICAgICAqIEdldHMgbm9kZSBvZiB0aGUgZ2xpZGUgbWFpbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIEh0bWwuX3I7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgbm9kZSBvZiB0aGUgZ2xpZGUgbWFpbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24gc2V0KHIpIHtcbiAgICAgIGlmIChpc1N0cmluZyhyKSkge1xuICAgICAgICByID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGV4aXN0KHIpKSB7XG4gICAgICAgIEh0bWwuX3IgPSByO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybignUm9vdCBlbGVtZW50IG11c3QgYmUgYSBleGlzdGluZyBIdG1sIG5vZGUnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBkZWZpbmUoSHRtbCwgJ3RyYWNrJywge1xuICAgIC8qKlxuICAgICAqIEdldHMgbm9kZSBvZiB0aGUgZ2xpZGUgdHJhY2sgd2l0aCBzbGlkZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gSHRtbC5fdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBub2RlIG9mIHRoZSBnbGlkZSB0cmFjayB3aXRoIHNsaWRlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh0KSB7XG4gICAgICBpZiAoZXhpc3QodCkpIHtcbiAgICAgICAgSHRtbC5fdCA9IHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKFwiQ291bGQgbm90IGZpbmQgdHJhY2sgZWxlbWVudC4gUGxlYXNlIHVzZSBcIi5jb25jYXQoVFJBQ0tfU0VMRUNUT1IsIFwiIGF0dHJpYnV0ZS5cIikpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGRlZmluZShIdG1sLCAnd3JhcHBlcicsIHtcbiAgICAvKipcbiAgICAgKiBHZXRzIG5vZGUgb2YgdGhlIHNsaWRlcyB3cmFwcGVyLlxuICAgICAqXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIEh0bWwudHJhY2suY2hpbGRyZW5bMF07XG4gICAgfVxuICB9KTtcbiAgLyoqXG4gICAqIEFkZC9yZW1vdmUvcmVvcmRlciBkeW5hbWljIHNsaWRlc1xuICAgKi9cblxuICBFdmVudHMub24oJ3VwZGF0ZScsIGZ1bmN0aW9uICgpIHtcbiAgICBIdG1sLmNvbGxlY3RTbGlkZXMoKTtcbiAgfSk7XG4gIHJldHVybiBIdG1sO1xufVxuXG5mdW5jdGlvbiBQZWVrIChHbGlkZSwgQ29tcG9uZW50cywgRXZlbnRzKSB7XG4gIHZhciBQZWVrID0ge1xuICAgIC8qKlxuICAgICAqIFNldHVwcyBob3cgbXVjaCB0byBwZWVrIGJhc2VkIG9uIHNldHRpbmdzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICBtb3VudDogZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgICB0aGlzLnZhbHVlID0gR2xpZGUuc2V0dGluZ3MucGVlaztcbiAgICB9XG4gIH07XG4gIGRlZmluZShQZWVrLCAndmFsdWUnLCB7XG4gICAgLyoqXG4gICAgICogR2V0cyB2YWx1ZSBvZiB0aGUgcGVlay5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8T2JqZWN0fVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIFBlZWsuX3Y7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdmFsdWUgb2YgdGhlIHBlZWsuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcnxPYmplY3R9IHZhbHVlXG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5iZWZvcmUgPSB0b0ludCh2YWx1ZS5iZWZvcmUpO1xuICAgICAgICB2YWx1ZS5hZnRlciA9IHRvSW50KHZhbHVlLmFmdGVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gdG9JbnQodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBQZWVrLl92ID0gdmFsdWU7XG4gICAgfVxuICB9KTtcbiAgZGVmaW5lKFBlZWssICdyZWR1Y3RvcicsIHtcbiAgICAvKipcbiAgICAgKiBHZXRzIHJlZHVjdGlvbiB2YWx1ZSBjYXVzZWQgYnkgcGVlay5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBQZWVrLnZhbHVlO1xuICAgICAgdmFyIHBlclZpZXcgPSBHbGlkZS5zZXR0aW5ncy5wZXJWaWV3O1xuXG4gICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5iZWZvcmUgLyBwZXJWaWV3ICsgdmFsdWUuYWZ0ZXIgLyBwZXJWaWV3O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWUgKiAyIC8gcGVyVmlldztcbiAgICB9XG4gIH0pO1xuICAvKipcbiAgICogUmVjYWxjdWxhdGUgcGVla2luZyBzaXplcyBvbjpcbiAgICogLSB3aGVuIHJlc2l6aW5nIHdpbmRvdyB0byB1cGRhdGUgdG8gcHJvcGVyIHBlcmNlbnRzXG4gICAqL1xuXG4gIEV2ZW50cy5vbihbJ3Jlc2l6ZScsICd1cGRhdGUnXSwgZnVuY3Rpb24gKCkge1xuICAgIFBlZWsubW91bnQoKTtcbiAgfSk7XG4gIHJldHVybiBQZWVrO1xufVxuXG5mdW5jdGlvbiBNb3ZlIChHbGlkZSwgQ29tcG9uZW50cywgRXZlbnRzKSB7XG4gIHZhciBNb3ZlID0ge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgbW92ZSBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Vm9pZH1cbiAgICAgKi9cbiAgICBtb3VudDogZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgICB0aGlzLl9vID0gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyBhIG1vdmVtZW50IHZhbHVlIGJhc2VkIG9uIHBhc3NlZCBvZmZzZXQgYW5kIGN1cnJlbnRseSBhY3RpdmUgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IG9mZnNldFxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgbWFrZTogZnVuY3Rpb24gbWFrZSgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBvZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgIEV2ZW50cy5lbWl0KCdtb3ZlJywge1xuICAgICAgICBtb3ZlbWVudDogdGhpcy52YWx1ZVxuICAgICAgfSk7XG4gICAgICBDb21wb25lbnRzLlRyYW5zaXRpb24uYWZ0ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICBFdmVudHMuZW1pdCgnbW92ZS5hZnRlcicsIHtcbiAgICAgICAgICBtb3ZlbWVudDogX3RoaXMudmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIGRlZmluZShNb3ZlLCAnb2Zmc2V0Jywge1xuICAgIC8qKlxuICAgICAqIEdldHMgYW4gb2Zmc2V0IHZhbHVlIHVzZWQgdG8gbW9kaWZ5IGN1cnJlbnQgdHJhbnNsYXRlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIE1vdmUuX287XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgYW4gb2Zmc2V0IHZhbHVlIHVzZWQgdG8gbW9kaWZ5IGN1cnJlbnQgdHJhbnNsYXRlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICBNb3ZlLl9vID0gIWlzVW5kZWZpbmVkKHZhbHVlKSA/IHRvSW50KHZhbHVlKSA6IDA7XG4gICAgfVxuICB9KTtcbiAgZGVmaW5lKE1vdmUsICd0cmFuc2xhdGUnLCB7XG4gICAgLyoqXG4gICAgICogR2V0cyBhIHJhdyBtb3ZlbWVudCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBDb21wb25lbnRzLlNpemVzLnNsaWRlV2lkdGggKiBHbGlkZS5pbmRleDtcbiAgICB9XG4gIH0pO1xuICBkZWZpbmUoTW92ZSwgJ3ZhbHVlJywge1xuICAgIC8qKlxuICAgICAqIEdldHMgYW4gYWN0dWFsIG1vdmVtZW50IHZhbHVlIGNvcnJlY3RlZCBieSBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICB2YXIgdHJhbnNsYXRlID0gdGhpcy50cmFuc2xhdGU7XG5cbiAgICAgIGlmIChDb21wb25lbnRzLkRpcmVjdGlvbi5pcygncnRsJykpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zbGF0ZSArIG9mZnNldDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRyYW5zbGF0ZSAtIG9mZnNldDtcbiAgICB9XG4gIH0pO1xuICAvKipcbiAgICogTWFrZSBtb3ZlbWVudCB0byBwcm9wZXIgc2xpZGUgb246XG4gICAqIC0gYmVmb3JlIGJ1aWxkLCBzbyBnbGlkZSB3aWxsIHN0YXJ0IGF0IGBzdGFydEF0YCBpbmRleFxuICAgKiAtIG9uIGVhY2ggc3RhbmRhcmQgcnVuIHRvIG1vdmUgdG8gbmV3bHkgY2FsY3VsYXRlZCBpbmRleFxuICAgKi9cblxuICBFdmVudHMub24oWydidWlsZC5iZWZvcmUnLCAncnVuJ10sIGZ1bmN0aW9uICgpIHtcbiAgICBNb3ZlLm1ha2UoKTtcbiAgfSk7XG4gIHJldHVybiBNb3ZlO1xufVxuXG5mdW5jdGlvbiBTaXplcyAoR2xpZGUsIENvbXBvbmVudHMsIEV2ZW50cykge1xuICB2YXIgU2l6ZXMgPSB7XG4gICAgLyoqXG4gICAgICogU2V0dXBzIGRpbWVuc2lvbnMgb2Ygc2xpZGVzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICBzZXR1cFNsaWRlczogZnVuY3Rpb24gc2V0dXBTbGlkZXMoKSB7XG4gICAgICB2YXIgd2lkdGggPSBcIlwiLmNvbmNhdCh0aGlzLnNsaWRlV2lkdGgsIFwicHhcIik7XG4gICAgICB2YXIgc2xpZGVzID0gQ29tcG9uZW50cy5IdG1sLnNsaWRlcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGlkZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2xpZGVzW2ldLnN0eWxlLndpZHRoID0gd2lkdGg7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHVwcyBkaW1lbnNpb25zIG9mIHNsaWRlcyB3cmFwcGVyLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICBzZXR1cFdyYXBwZXI6IGZ1bmN0aW9uIHNldHVwV3JhcHBlcigpIHtcbiAgICAgIENvbXBvbmVudHMuSHRtbC53cmFwcGVyLnN0eWxlLndpZHRoID0gXCJcIi5jb25jYXQodGhpcy53cmFwcGVyU2l6ZSwgXCJweFwiKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhcHBsaWVkIHN0eWxlcyBmcm9tIEhUTUwgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Vm9pZH1cbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHZhciBzbGlkZXMgPSBDb21wb25lbnRzLkh0bWwuc2xpZGVzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzbGlkZXNbaV0uc3R5bGUud2lkdGggPSAnJztcbiAgICAgIH1cblxuICAgICAgQ29tcG9uZW50cy5IdG1sLndyYXBwZXIuc3R5bGUud2lkdGggPSAnJztcbiAgICB9XG4gIH07XG4gIGRlZmluZShTaXplcywgJ2xlbmd0aCcsIHtcbiAgICAvKipcbiAgICAgKiBHZXRzIGNvdW50IG51bWJlciBvZiB0aGUgc2xpZGVzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIENvbXBvbmVudHMuSHRtbC5zbGlkZXMubGVuZ3RoO1xuICAgIH1cbiAgfSk7XG4gIGRlZmluZShTaXplcywgJ3dpZHRoJywge1xuICAgIC8qKlxuICAgICAqIEdldHMgd2lkdGggdmFsdWUgb2YgdGhlIHNsaWRlciAodmlzaWJsZSBhcmVhKS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBDb21wb25lbnRzLkh0bWwudHJhY2sub2Zmc2V0V2lkdGg7XG4gICAgfVxuICB9KTtcbiAgZGVmaW5lKFNpemVzLCAnd3JhcHBlclNpemUnLCB7XG4gICAgLyoqXG4gICAgICogR2V0cyBzaXplIG9mIHRoZSBzbGlkZXMgd3JhcHBlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBTaXplcy5zbGlkZVdpZHRoICogU2l6ZXMubGVuZ3RoICsgQ29tcG9uZW50cy5HYXBzLmdyb3cgKyBDb21wb25lbnRzLkNsb25lcy5ncm93O1xuICAgIH1cbiAgfSk7XG4gIGRlZmluZShTaXplcywgJ3NsaWRlV2lkdGgnLCB7XG4gICAgLyoqXG4gICAgICogR2V0cyB3aWR0aCB2YWx1ZSBvZiBhIHNpbmdsZSBzbGlkZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBTaXplcy53aWR0aCAvIEdsaWRlLnNldHRpbmdzLnBlclZpZXcgLSBDb21wb25lbnRzLlBlZWsucmVkdWN0b3IgLSBDb21wb25lbnRzLkdhcHMucmVkdWN0b3I7XG4gICAgfVxuICB9KTtcbiAgLyoqXG4gICAqIEFwcGx5IGNhbGN1bGF0ZWQgZ2xpZGUncyBkaW1lbnNpb25zOlxuICAgKiAtIGJlZm9yZSBidWlsZGluZywgc28gb3RoZXIgZGltZW5zaW9ucyAoZS5nLiB0cmFuc2xhdGUpIHdpbGwgYmUgY2FsY3VsYXRlZCBwcm9wZXJ0bHlcbiAgICogLSB3aGVuIHJlc2l6aW5nIHdpbmRvdyB0byByZWNhbGN1bGF0ZSBzaWxkZXMgZGltZW5zaW9uc1xuICAgKiAtIG9uIHVwZGF0aW5nIHZpYSBBUEksIHRvIGNhbGN1bGF0ZSBkaW1lbnNpb25zIGJhc2VkIG9uIG5ldyBvcHRpb25zXG4gICAqL1xuXG4gIEV2ZW50cy5vbihbJ2J1aWxkLmJlZm9yZScsICdyZXNpemUnLCAndXBkYXRlJ10sIGZ1bmN0aW9uICgpIHtcbiAgICBTaXplcy5zZXR1cFNsaWRlcygpO1xuICAgIFNpemVzLnNldHVwV3JhcHBlcigpO1xuICB9KTtcbiAgLyoqXG4gICAqIFJlbW92ZSBjYWxjdWxhdGVkIGdsaWRlJ3MgZGltZW5zaW9uczpcbiAgICogLSBvbiBkZXN0b3RpbmcgdG8gYnJpbmcgbWFya3VwIHRvIGl0cyBpbml0YWwgc3RhdGVcbiAgICovXG5cbiAgRXZlbnRzLm9uKCdkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgIFNpemVzLnJlbW92ZSgpO1xuICB9KTtcbiAgcmV0dXJuIFNpemVzO1xufVxuXG5mdW5jdGlvbiBCdWlsZCAoR2xpZGUsIENvbXBvbmVudHMsIEV2ZW50cykge1xuICB2YXIgQnVpbGQgPSB7XG4gICAgLyoqXG4gICAgICogSW5pdCBnbGlkZSBidWlsZGluZy4gQWRkcyBjbGFzc2VzLCBzZXRzXG4gICAgICogZGltZW5zaW9ucyBhbmQgc2V0dXBzIGluaXRpYWwgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIG1vdW50OiBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICAgIEV2ZW50cy5lbWl0KCdidWlsZC5iZWZvcmUnKTtcbiAgICAgIHRoaXMudHlwZUNsYXNzKCk7XG4gICAgICB0aGlzLmFjdGl2ZUNsYXNzKCk7XG4gICAgICBFdmVudHMuZW1pdCgnYnVpbGQuYWZ0ZXInKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBgdHlwZWAgY2xhc3MgdG8gdGhlIGdsaWRlIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIHR5cGVDbGFzczogZnVuY3Rpb24gdHlwZUNsYXNzKCkge1xuICAgICAgQ29tcG9uZW50cy5IdG1sLnJvb3QuY2xhc3NMaXN0LmFkZChHbGlkZS5zZXR0aW5ncy5jbGFzc2VzLnR5cGVbR2xpZGUuc2V0dGluZ3MudHlwZV0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGFjdGl2ZSBjbGFzcyB0byBjdXJyZW50IHNsaWRlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICBhY3RpdmVDbGFzczogZnVuY3Rpb24gYWN0aXZlQ2xhc3MoKSB7XG4gICAgICB2YXIgY2xhc3NlcyA9IEdsaWRlLnNldHRpbmdzLmNsYXNzZXM7XG4gICAgICB2YXIgc2xpZGUgPSBDb21wb25lbnRzLkh0bWwuc2xpZGVzW0dsaWRlLmluZGV4XTtcblxuICAgICAgaWYgKHNsaWRlKSB7XG4gICAgICAgIHNsaWRlLmNsYXNzTGlzdC5hZGQoY2xhc3Nlcy5zbGlkZS5hY3RpdmUpO1xuICAgICAgICBzaWJsaW5ncyhzbGlkZSkuZm9yRWFjaChmdW5jdGlvbiAoc2libGluZykge1xuICAgICAgICAgIHNpYmxpbmcuY2xhc3NMaXN0LnJlbW92ZShjbGFzc2VzLnNsaWRlLmFjdGl2ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIEhUTUwgY2xhc3NlcyBhcHBsaWVkIGF0IGJ1aWxkaW5nLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICByZW1vdmVDbGFzc2VzOiBmdW5jdGlvbiByZW1vdmVDbGFzc2VzKCkge1xuICAgICAgdmFyIF9HbGlkZSRzZXR0aW5ncyRjbGFzcyA9IEdsaWRlLnNldHRpbmdzLmNsYXNzZXMsXG4gICAgICAgICAgdHlwZSA9IF9HbGlkZSRzZXR0aW5ncyRjbGFzcy50eXBlLFxuICAgICAgICAgIHNsaWRlID0gX0dsaWRlJHNldHRpbmdzJGNsYXNzLnNsaWRlO1xuICAgICAgQ29tcG9uZW50cy5IdG1sLnJvb3QuY2xhc3NMaXN0LnJlbW92ZSh0eXBlW0dsaWRlLnNldHRpbmdzLnR5cGVdKTtcbiAgICAgIENvbXBvbmVudHMuSHRtbC5zbGlkZXMuZm9yRWFjaChmdW5jdGlvbiAoc2libGluZykge1xuICAgICAgICBzaWJsaW5nLmNsYXNzTGlzdC5yZW1vdmUoc2xpZGUuYWN0aXZlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIENsZWFyIGJ1aWxkaW5nIGNsYXNzZXM6XG4gICAqIC0gb24gZGVzdHJveWluZyB0byBicmluZyBIVE1MIHRvIGl0cyBpbml0aWFsIHN0YXRlXG4gICAqIC0gb24gdXBkYXRpbmcgdG8gcmVtb3ZlIGNsYXNzZXMgYmVmb3JlIHJlbW91bnRpbmcgY29tcG9uZW50XG4gICAqL1xuXG4gIEV2ZW50cy5vbihbJ2Rlc3Ryb3knLCAndXBkYXRlJ10sIGZ1bmN0aW9uICgpIHtcbiAgICBCdWlsZC5yZW1vdmVDbGFzc2VzKCk7XG4gIH0pO1xuICAvKipcbiAgICogUmVtb3VudCBjb21wb25lbnQ6XG4gICAqIC0gb24gcmVzaXppbmcgb2YgdGhlIHdpbmRvdyB0byBjYWxjdWxhdGUgbmV3IGRpbWVuc2lvbnNcbiAgICogLSBvbiB1cGRhdGluZyBzZXR0aW5ncyB2aWEgQVBJXG4gICAqL1xuXG4gIEV2ZW50cy5vbihbJ3Jlc2l6ZScsICd1cGRhdGUnXSwgZnVuY3Rpb24gKCkge1xuICAgIEJ1aWxkLm1vdW50KCk7XG4gIH0pO1xuICAvKipcbiAgICogU3dhcCBhY3RpdmUgY2xhc3Mgb2YgY3VycmVudCBzbGlkZTpcbiAgICogLSBhZnRlciBlYWNoIG1vdmUgdG8gdGhlIG5ldyBpbmRleFxuICAgKi9cblxuICBFdmVudHMub24oJ21vdmUuYWZ0ZXInLCBmdW5jdGlvbiAoKSB7XG4gICAgQnVpbGQuYWN0aXZlQ2xhc3MoKTtcbiAgfSk7XG4gIHJldHVybiBCdWlsZDtcbn1cblxuZnVuY3Rpb24gQ2xvbmVzIChHbGlkZSwgQ29tcG9uZW50cywgRXZlbnRzKSB7XG4gIHZhciBDbG9uZXMgPSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHBhdHRlcm4gbWFwIGFuZCBjb2xsZWN0IHNsaWRlcyB0byBiZSBjbG9uZWQuXG4gICAgICovXG4gICAgbW91bnQ6IGZ1bmN0aW9uIG1vdW50KCkge1xuICAgICAgdGhpcy5pdGVtcyA9IFtdO1xuXG4gICAgICBpZiAoR2xpZGUuaXNUeXBlKCdjYXJvdXNlbCcpKSB7XG4gICAgICAgIHRoaXMuaXRlbXMgPSB0aGlzLmNvbGxlY3QoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29sbGVjdCBjbG9uZXMgd2l0aCBwYXR0ZXJuLlxuICAgICAqXG4gICAgICogQHJldHVybiB7W119XG4gICAgICovXG4gICAgY29sbGVjdDogZnVuY3Rpb24gY29sbGVjdCgpIHtcbiAgICAgIHZhciBpdGVtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gICAgICB2YXIgc2xpZGVzID0gQ29tcG9uZW50cy5IdG1sLnNsaWRlcztcbiAgICAgIHZhciBfR2xpZGUkc2V0dGluZ3MgPSBHbGlkZS5zZXR0aW5ncyxcbiAgICAgICAgICBwZXJWaWV3ID0gX0dsaWRlJHNldHRpbmdzLnBlclZpZXcsXG4gICAgICAgICAgY2xhc3NlcyA9IF9HbGlkZSRzZXR0aW5ncy5jbGFzc2VzLFxuICAgICAgICAgIGNsb25pbmdSYXRpbyA9IF9HbGlkZSRzZXR0aW5ncy5jbG9uaW5nUmF0aW87XG5cbiAgICAgIGlmIChzbGlkZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHZhciBwZWVrSW5jcmVtZW50ZXIgPSArISFHbGlkZS5zZXR0aW5ncy5wZWVrO1xuICAgICAgICB2YXIgY2xvbmVDb3VudCA9IHBlclZpZXcgKyBwZWVrSW5jcmVtZW50ZXIgKyBNYXRoLnJvdW5kKHBlclZpZXcgLyAyKTtcbiAgICAgICAgdmFyIGFwcGVuZCA9IHNsaWRlcy5zbGljZSgwLCBjbG9uZUNvdW50KS5yZXZlcnNlKCk7XG4gICAgICAgIHZhciBwcmVwZW5kID0gc2xpZGVzLnNsaWNlKGNsb25lQ291bnQgKiAtMSk7XG5cbiAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBNYXRoLm1heChjbG9uaW5nUmF0aW8sIE1hdGguZmxvb3IocGVyVmlldyAvIHNsaWRlcy5sZW5ndGgpKTsgcisrKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcHBlbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjbG9uZSA9IGFwcGVuZFtpXS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgICAgICBjbG9uZS5jbGFzc0xpc3QuYWRkKGNsYXNzZXMuc2xpZGUuY2xvbmUpO1xuICAgICAgICAgICAgaXRlbXMucHVzaChjbG9uZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHByZXBlbmQubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgX2Nsb25lID0gcHJlcGVuZFtfaV0uY2xvbmVOb2RlKHRydWUpO1xuXG4gICAgICAgICAgICBfY2xvbmUuY2xhc3NMaXN0LmFkZChjbGFzc2VzLnNsaWRlLmNsb25lKTtcblxuICAgICAgICAgICAgaXRlbXMudW5zaGlmdChfY2xvbmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXRlbXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGVuZCBjbG9uZWQgc2xpZGVzIHdpdGggZ2VuZXJhdGVkIHBhdHRlcm4uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIGFwcGVuZDogZnVuY3Rpb24gYXBwZW5kKCkge1xuICAgICAgdmFyIGl0ZW1zID0gdGhpcy5pdGVtcztcbiAgICAgIHZhciBfQ29tcG9uZW50cyRIdG1sID0gQ29tcG9uZW50cy5IdG1sLFxuICAgICAgICAgIHdyYXBwZXIgPSBfQ29tcG9uZW50cyRIdG1sLndyYXBwZXIsXG4gICAgICAgICAgc2xpZGVzID0gX0NvbXBvbmVudHMkSHRtbC5zbGlkZXM7XG4gICAgICB2YXIgaGFsZiA9IE1hdGguZmxvb3IoaXRlbXMubGVuZ3RoIC8gMik7XG4gICAgICB2YXIgcHJlcGVuZCA9IGl0ZW1zLnNsaWNlKDAsIGhhbGYpLnJldmVyc2UoKTtcbiAgICAgIHZhciBhcHBlbmQgPSBpdGVtcy5zbGljZShoYWxmICogLTEpLnJldmVyc2UoKTtcbiAgICAgIHZhciB3aWR0aCA9IFwiXCIuY29uY2F0KENvbXBvbmVudHMuU2l6ZXMuc2xpZGVXaWR0aCwgXCJweFwiKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcHBlbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChhcHBlbmRbaV0pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBwcmVwZW5kLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgd3JhcHBlci5pbnNlcnRCZWZvcmUocHJlcGVuZFtfaTJdLCBzbGlkZXNbMF0pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBpdGVtcy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICAgIGl0ZW1zW19pM10uc3R5bGUud2lkdGggPSB3aWR0aDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCBjbG9uZWQgc2xpZGVzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHZhciBpdGVtcyA9IHRoaXMuaXRlbXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgQ29tcG9uZW50cy5IdG1sLndyYXBwZXIucmVtb3ZlQ2hpbGQoaXRlbXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgZGVmaW5lKENsb25lcywgJ2dyb3cnLCB7XG4gICAgLyoqXG4gICAgICogR2V0cyBhZGRpdGlvbmFsIGRpbWVuc2lvbnMgdmFsdWUgY2F1c2VkIGJ5IGNsb25lcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAoQ29tcG9uZW50cy5TaXplcy5zbGlkZVdpZHRoICsgQ29tcG9uZW50cy5HYXBzLnZhbHVlKSAqIENsb25lcy5pdGVtcy5sZW5ndGg7XG4gICAgfVxuICB9KTtcbiAgLyoqXG4gICAqIEFwcGVuZCBhZGRpdGlvbmFsIHNsaWRlJ3MgY2xvbmVzOlxuICAgKiAtIHdoaWxlIGdsaWRlJ3MgdHlwZSBpcyBgY2Fyb3VzZWxgXG4gICAqL1xuXG4gIEV2ZW50cy5vbigndXBkYXRlJywgZnVuY3Rpb24gKCkge1xuICAgIENsb25lcy5yZW1vdmUoKTtcbiAgICBDbG9uZXMubW91bnQoKTtcbiAgICBDbG9uZXMuYXBwZW5kKCk7XG4gIH0pO1xuICAvKipcbiAgICogQXBwZW5kIGFkZGl0aW9uYWwgc2xpZGUncyBjbG9uZXM6XG4gICAqIC0gd2hpbGUgZ2xpZGUncyB0eXBlIGlzIGBjYXJvdXNlbGBcbiAgICovXG5cbiAgRXZlbnRzLm9uKCdidWlsZC5iZWZvcmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKEdsaWRlLmlzVHlwZSgnY2Fyb3VzZWwnKSkge1xuICAgICAgQ2xvbmVzLmFwcGVuZCgpO1xuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgKiBSZW1vdmUgY2xvbmVzIEhUTUxFbGVtZW50czpcbiAgICogLSBvbiBkZXN0cm95aW5nLCB0byBicmluZyBIVE1MIHRvIGl0cyBpbml0aWFsIHN0YXRlXG4gICAqL1xuXG4gIEV2ZW50cy5vbignZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICBDbG9uZXMucmVtb3ZlKCk7XG4gIH0pO1xuICByZXR1cm4gQ2xvbmVzO1xufVxuXG52YXIgRXZlbnRzQmluZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIEV2ZW50c0JpbmRlciBpbnN0YW5jZS5cbiAgICovXG4gIGZ1bmN0aW9uIEV2ZW50c0JpbmRlcigpIHtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFdmVudHNCaW5kZXIpO1xuXG4gICAgdGhpcy5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgZXZlbnRzIGxpc3RlbmVycyB0byBhcnJvd3MgSFRNTCBlbGVtZW50cy5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfEFycmF5fSBldmVudHNcbiAgICogQHBhcmFtICB7RWxlbWVudHxXaW5kb3d8RG9jdW1lbnR9IGVsXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjbG9zdXJlXG4gICAqIEBwYXJhbSAge0Jvb2xlYW58T2JqZWN0fSBjYXB0dXJlXG4gICAqIEByZXR1cm4ge1ZvaWR9XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEV2ZW50c0JpbmRlciwgW3tcbiAgICBrZXk6IFwib25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb24oZXZlbnRzLCBlbCwgY2xvc3VyZSkge1xuICAgICAgdmFyIGNhcHR1cmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuXG4gICAgICBpZiAoaXNTdHJpbmcoZXZlbnRzKSkge1xuICAgICAgICBldmVudHMgPSBbZXZlbnRzXTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnNbZXZlbnRzW2ldXSA9IGNsb3N1cmU7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRzW2ldLCB0aGlzLmxpc3RlbmVyc1tldmVudHNbaV1dLCBjYXB0dXJlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBldmVudCBsaXN0ZW5lcnMgZnJvbSBhcnJvd3MgSFRNTCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1N0cmluZ3xBcnJheX0gZXZlbnRzXG4gICAgICogQHBhcmFtICB7RWxlbWVudHxXaW5kb3d8RG9jdW1lbnR9IGVsXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbnxPYmplY3R9IGNhcHR1cmVcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib2ZmXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9mZihldmVudHMsIGVsKSB7XG4gICAgICB2YXIgY2FwdHVyZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgICAgIGlmIChpc1N0cmluZyhldmVudHMpKSB7XG4gICAgICAgIGV2ZW50cyA9IFtldmVudHNdO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50c1tpXSwgdGhpcy5saXN0ZW5lcnNbZXZlbnRzW2ldXSwgY2FwdHVyZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgY29sbGVjdGVkIGxpc3RlbmVycy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtWb2lkfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgZGVsZXRlIHRoaXMubGlzdGVuZXJzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFdmVudHNCaW5kZXI7XG59KCk7XG5cbmZ1bmN0aW9uIFJlc2l6ZSAoR2xpZGUsIENvbXBvbmVudHMsIEV2ZW50cykge1xuICAvKipcbiAgICogSW5zdGFuY2Ugb2YgdGhlIGJpbmRlciBmb3IgRE9NIEV2ZW50cy5cbiAgICpcbiAgICogQHR5cGUge0V2ZW50c0JpbmRlcn1cbiAgICovXG4gIHZhciBCaW5kZXIgPSBuZXcgRXZlbnRzQmluZGVyKCk7XG4gIHZhciBSZXNpemUgPSB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgd2luZG93IGJpbmRpbmdzLlxuICAgICAqL1xuICAgIG1vdW50OiBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICAgIHRoaXMuYmluZCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBCaW5kcyBgcmV6c2l6ZWAgbGlzdGVuZXIgdG8gdGhlIHdpbmRvdy5cbiAgICAgKiBJdCdzIGEgY29zdGx5IGV2ZW50LCBzbyB3ZSBhcmUgZGVib3VuY2luZyBpdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAgIEJpbmRlci5vbigncmVzaXplJywgd2luZG93LCB0aHJvdHRsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIEV2ZW50cy5lbWl0KCdyZXNpemUnKTtcbiAgICAgIH0sIEdsaWRlLnNldHRpbmdzLnRocm90dGxlKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVuYmluZHMgbGlzdGVuZXJzIGZyb20gdGhlIHdpbmRvdy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgICBCaW5kZXIub2ZmKCdyZXNpemUnLCB3aW5kb3cpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFJlbW92ZSBiaW5kaW5ncyBmcm9tIHdpbmRvdzpcbiAgICogLSBvbiBkZXN0cm95aW5nLCB0byByZW1vdmUgYWRkZWQgRXZlbnRMaXN0ZW5lclxuICAgKi9cblxuICBFdmVudHMub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG4gICAgUmVzaXplLnVuYmluZCgpO1xuICAgIEJpbmRlci5kZXN0cm95KCk7XG4gIH0pO1xuICByZXR1cm4gUmVzaXplO1xufVxuXG52YXIgVkFMSURfRElSRUNUSU9OUyA9IFsnbHRyJywgJ3J0bCddO1xudmFyIEZMSVBFRF9NT1ZFTUVOVFMgPSB7XG4gICc+JzogJzwnLFxuICAnPCc6ICc+JyxcbiAgJz0nOiAnPSdcbn07XG5mdW5jdGlvbiBEaXJlY3Rpb24gKEdsaWRlLCBDb21wb25lbnRzLCBFdmVudHMpIHtcbiAgdmFyIERpcmVjdGlvbiA9IHtcbiAgICAvKipcbiAgICAgKiBTZXR1cHMgZ2FwIHZhbHVlIGJhc2VkIG9uIHNldHRpbmdzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICBtb3VudDogZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgICB0aGlzLnZhbHVlID0gR2xpZGUuc2V0dGluZ3MuZGlyZWN0aW9uO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyBwYXR0ZXJuIGJhc2VkIG9uIGRpcmVjdGlvbiB2YWx1ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdHRlcm5cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUocGF0dGVybikge1xuICAgICAgdmFyIHRva2VuID0gcGF0dGVybi5zbGljZSgwLCAxKTtcblxuICAgICAgaWYgKHRoaXMuaXMoJ3J0bCcpKSB7XG4gICAgICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KHRva2VuKS5qb2luKEZMSVBFRF9NT1ZFTUVOVFNbdG9rZW5dKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhdHRlcm47XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB2YWx1ZSBvZiBkaXJlY3Rpb24gbW9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkaXJlY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpczogZnVuY3Rpb24gaXMoZGlyZWN0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZSA9PT0gZGlyZWN0aW9uO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGRpcmVjdGlvbiBjbGFzcyB0byB0aGUgcm9vdCBIVE1MIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIGFkZENsYXNzOiBmdW5jdGlvbiBhZGRDbGFzcygpIHtcbiAgICAgIENvbXBvbmVudHMuSHRtbC5yb290LmNsYXNzTGlzdC5hZGQoR2xpZGUuc2V0dGluZ3MuY2xhc3Nlcy5kaXJlY3Rpb25bdGhpcy52YWx1ZV0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGRpcmVjdGlvbiBjbGFzcyBmcm9tIHRoZSByb290IEhUTUwgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKCkge1xuICAgICAgQ29tcG9uZW50cy5IdG1sLnJvb3QuY2xhc3NMaXN0LnJlbW92ZShHbGlkZS5zZXR0aW5ncy5jbGFzc2VzLmRpcmVjdGlvblt0aGlzLnZhbHVlXSk7XG4gICAgfVxuICB9O1xuICBkZWZpbmUoRGlyZWN0aW9uLCAndmFsdWUnLCB7XG4gICAgLyoqXG4gICAgICogR2V0cyB2YWx1ZSBvZiB0aGUgZGlyZWN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBEaXJlY3Rpb24uX3Y7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdmFsdWUgb2YgdGhlIGRpcmVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIGlmIChWQUxJRF9ESVJFQ1RJT05TLmluZGV4T2YodmFsdWUpID4gLTEpIHtcbiAgICAgICAgRGlyZWN0aW9uLl92ID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKCdEaXJlY3Rpb24gdmFsdWUgbXVzdCBiZSBgbHRyYCBvciBgcnRsYCcpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgKiBDbGVhciBkaXJlY3Rpb24gY2xhc3M6XG4gICAqIC0gb24gZGVzdHJveSB0byBicmluZyBIVE1MIHRvIGl0cyBpbml0aWFsIHN0YXRlXG4gICAqIC0gb24gdXBkYXRlIHRvIHJlbW92ZSBjbGFzcyBiZWZvcmUgcmVhcHBsaW5nIGJlbGxvd1xuICAgKi9cblxuICBFdmVudHMub24oWydkZXN0cm95JywgJ3VwZGF0ZSddLCBmdW5jdGlvbiAoKSB7XG4gICAgRGlyZWN0aW9uLnJlbW92ZUNsYXNzKCk7XG4gIH0pO1xuICAvKipcbiAgICogUmVtb3VudCBjb21wb25lbnQ6XG4gICAqIC0gb24gdXBkYXRlIHRvIHJlZmxlY3QgY2hhbmdlcyBpbiBkaXJlY3Rpb24gdmFsdWVcbiAgICovXG5cbiAgRXZlbnRzLm9uKCd1cGRhdGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgRGlyZWN0aW9uLm1vdW50KCk7XG4gIH0pO1xuICAvKipcbiAgICogQXBwbHkgZGlyZWN0aW9uIGNsYXNzOlxuICAgKiAtIGJlZm9yZSBidWlsZGluZyB0byBhcHBseSBjbGFzcyBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICogLSBvbiB1cGRhdGluZyB0byByZWFwcGx5IGRpcmVjdGlvbiBjbGFzcyB0aGF0IG1heSBjaGFuZ2VkXG4gICAqL1xuXG4gIEV2ZW50cy5vbihbJ2J1aWxkLmJlZm9yZScsICd1cGRhdGUnXSwgZnVuY3Rpb24gKCkge1xuICAgIERpcmVjdGlvbi5hZGRDbGFzcygpO1xuICB9KTtcbiAgcmV0dXJuIERpcmVjdGlvbjtcbn1cblxuLyoqXG4gKiBSZWZsZWN0cyB2YWx1ZSBvZiBnbGlkZSBtb3ZlbWVudC5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IEdsaWRlXG4gKiBAcGFyYW0gIHtPYmplY3R9IENvbXBvbmVudHNcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gUnRsIChHbGlkZSwgQ29tcG9uZW50cykge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIE5lZ2F0ZXMgdGhlIHBhc3NlZCB0cmFuc2xhdGUgaWYgZ2xpZGUgaXMgaW4gUlRMIG9wdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gdHJhbnNsYXRlXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIG1vZGlmeTogZnVuY3Rpb24gbW9kaWZ5KHRyYW5zbGF0ZSkge1xuICAgICAgaWYgKENvbXBvbmVudHMuRGlyZWN0aW9uLmlzKCdydGwnKSkge1xuICAgICAgICByZXR1cm4gLXRyYW5zbGF0ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRyYW5zbGF0ZTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogVXBkYXRlcyBnbGlkZSBtb3ZlbWVudCB3aXRoIGEgYGdhcGAgc2V0dGluZ3MuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBHbGlkZVxuICogQHBhcmFtICB7T2JqZWN0fSBDb21wb25lbnRzXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIEdhcCAoR2xpZGUsIENvbXBvbmVudHMpIHtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBNb2RpZmllcyBwYXNzZWQgdHJhbnNsYXRlIHZhbHVlIHdpdGggbnVtYmVyIGluIHRoZSBgZ2FwYCBzZXR0aW5ncy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gdHJhbnNsYXRlXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIG1vZGlmeTogZnVuY3Rpb24gbW9kaWZ5KHRyYW5zbGF0ZSkge1xuICAgICAgdmFyIG11bHRpcGxpZXIgPSBNYXRoLmZsb29yKHRyYW5zbGF0ZSAvIENvbXBvbmVudHMuU2l6ZXMuc2xpZGVXaWR0aCk7XG4gICAgICByZXR1cm4gdHJhbnNsYXRlICsgQ29tcG9uZW50cy5HYXBzLnZhbHVlICogbXVsdGlwbGllcjtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogVXBkYXRlcyBnbGlkZSBtb3ZlbWVudCB3aXRoIHdpZHRoIG9mIGFkZGl0aW9uYWwgY2xvbmVzIHdpZHRoLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gR2xpZGVcbiAqIEBwYXJhbSAge09iamVjdH0gQ29tcG9uZW50c1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBHcm93IChHbGlkZSwgQ29tcG9uZW50cykge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIEFkZHMgdG8gdGhlIHBhc3NlZCB0cmFuc2xhdGUgd2lkdGggb2YgdGhlIGhhbGYgb2YgY2xvbmVzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSB0cmFuc2xhdGVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgbW9kaWZ5OiBmdW5jdGlvbiBtb2RpZnkodHJhbnNsYXRlKSB7XG4gICAgICByZXR1cm4gdHJhbnNsYXRlICsgQ29tcG9uZW50cy5DbG9uZXMuZ3JvdyAvIDI7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgZ2xpZGUgbW92ZW1lbnQgd2l0aCBhIGBwZWVrYCBzZXR0aW5ncy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IEdsaWRlXG4gKiBAcGFyYW0gIHtPYmplY3R9IENvbXBvbmVudHNcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBQZWVraW5nIChHbGlkZSwgQ29tcG9uZW50cykge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIE1vZGlmaWVzIHBhc3NlZCB0cmFuc2xhdGUgdmFsdWUgd2l0aCBhIGBwZWVrYCBzZXR0aW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSB0cmFuc2xhdGVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgbW9kaWZ5OiBmdW5jdGlvbiBtb2RpZnkodHJhbnNsYXRlKSB7XG4gICAgICBpZiAoR2xpZGUuc2V0dGluZ3MuZm9jdXNBdCA+PSAwKSB7XG4gICAgICAgIHZhciBwZWVrID0gQ29tcG9uZW50cy5QZWVrLnZhbHVlO1xuXG4gICAgICAgIGlmIChpc09iamVjdChwZWVrKSkge1xuICAgICAgICAgIHJldHVybiB0cmFuc2xhdGUgLSBwZWVrLmJlZm9yZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cmFuc2xhdGUgLSBwZWVrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJhbnNsYXRlO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBVcGRhdGVzIGdsaWRlIG1vdmVtZW50IHdpdGggYSBgZm9jdXNBdGAgc2V0dGluZ3MuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBHbGlkZVxuICogQHBhcmFtICB7T2JqZWN0fSBDb21wb25lbnRzXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIEZvY3VzaW5nIChHbGlkZSwgQ29tcG9uZW50cykge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIE1vZGlmaWVzIHBhc3NlZCB0cmFuc2xhdGUgdmFsdWUgd2l0aCBpbmRleCBpbiB0aGUgYGZvY3VzQXRgIHNldHRpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHRyYW5zbGF0ZVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBtb2RpZnk6IGZ1bmN0aW9uIG1vZGlmeSh0cmFuc2xhdGUpIHtcbiAgICAgIHZhciBnYXAgPSBDb21wb25lbnRzLkdhcHMudmFsdWU7XG4gICAgICB2YXIgd2lkdGggPSBDb21wb25lbnRzLlNpemVzLndpZHRoO1xuICAgICAgdmFyIGZvY3VzQXQgPSBHbGlkZS5zZXR0aW5ncy5mb2N1c0F0O1xuICAgICAgdmFyIHNsaWRlV2lkdGggPSBDb21wb25lbnRzLlNpemVzLnNsaWRlV2lkdGg7XG5cbiAgICAgIGlmIChmb2N1c0F0ID09PSAnY2VudGVyJykge1xuICAgICAgICByZXR1cm4gdHJhbnNsYXRlIC0gKHdpZHRoIC8gMiAtIHNsaWRlV2lkdGggLyAyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRyYW5zbGF0ZSAtIHNsaWRlV2lkdGggKiBmb2N1c0F0IC0gZ2FwICogZm9jdXNBdDtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQXBwbGllcyBkaWZmcmVudCB0cmFuc2Zvcm1lcnMgb24gdHJhbnNsYXRlIHZhbHVlLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gR2xpZGVcbiAqIEBwYXJhbSAge09iamVjdH0gQ29tcG9uZW50c1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIG11dGF0b3IgKEdsaWRlLCBDb21wb25lbnRzLCBFdmVudHMpIHtcbiAgLyoqXG4gICAqIE1lcmdlIGluc3RhbmNlIHRyYW5zZm9ybWVycyB3aXRoIGNvbGxlY3Rpb24gb2YgZGVmYXVsdCB0cmFuc2Zvcm1lcnMuXG4gICAqIEl0J3MgaW1wb3J0YW50IHRoYXQgdGhlIFJ0bCBjb21wb25lbnQgYmUgbGFzdCBvbiB0aGUgbGlzdCxcbiAgICogc28gaXQgcmVmbGVjdHMgYWxsIHByZXZpb3VzIHRyYW5zZm9ybWF0aW9ucy5cbiAgICpcbiAgICogQHR5cGUge0FycmF5fVxuICAgKi9cbiAgdmFyIFRSQU5TRk9STUVSUyA9IFtHYXAsIEdyb3csIFBlZWtpbmcsIEZvY3VzaW5nXS5jb25jYXQoR2xpZGUuX3QsIFtSdGxdKTtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBQaXBsaW5lcyB0cmFuc2xhdGUgdmFsdWUgd2l0aCByZWdpc3RlcmVkIHRyYW5zZm9ybWVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gdHJhbnNsYXRlXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKHRyYW5zbGF0ZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBUUkFOU0ZPUk1FUlMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRyYW5zZm9ybWVyID0gVFJBTlNGT1JNRVJTW2ldO1xuXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHRyYW5zZm9ybWVyKSAmJiBpc0Z1bmN0aW9uKHRyYW5zZm9ybWVyKCkubW9kaWZ5KSkge1xuICAgICAgICAgIHRyYW5zbGF0ZSA9IHRyYW5zZm9ybWVyKEdsaWRlLCBDb21wb25lbnRzLCBFdmVudHMpLm1vZGlmeSh0cmFuc2xhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm4oJ1RyYW5zZm9ybWVyIHNob3VsZCBiZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBgbW9kaWZ5KClgIG1ldGhvZCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cmFuc2xhdGU7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBUcmFuc2xhdGUgKEdsaWRlLCBDb21wb25lbnRzLCBFdmVudHMpIHtcbiAgdmFyIFRyYW5zbGF0ZSA9IHtcbiAgICAvKipcbiAgICAgKiBTZXRzIHZhbHVlIG9mIHRyYW5zbGF0ZSBvbiBIVE1MIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB2YXIgdHJhbnNmb3JtID0gbXV0YXRvcihHbGlkZSwgQ29tcG9uZW50cykubXV0YXRlKHZhbHVlKTtcbiAgICAgIHZhciB0cmFuc2xhdGUzZCA9IFwidHJhbnNsYXRlM2QoXCIuY29uY2F0KC0xICogdHJhbnNmb3JtLCBcInB4LCAwcHgsIDBweClcIik7XG4gICAgICBDb21wb25lbnRzLkh0bWwud3JhcHBlci5zdHlsZS5tb3pUcmFuc2Zvcm0gPSB0cmFuc2xhdGUzZDsgLy8gbmVlZGVkIGZvciBzdXBwb3J0ZWQgRmlyZWZveCAxMC0xNVxuXG4gICAgICBDb21wb25lbnRzLkh0bWwud3JhcHBlci5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSB0cmFuc2xhdGUzZDsgLy8gbmVlZGVkIGZvciBzdXBwb3J0ZWQgQ2hyb21lIDEwLTM1LCBTYWZhcmkgNS4xLTgsIGFuZCBPcGVyYSAxNS0yMlxuXG4gICAgICBDb21wb25lbnRzLkh0bWwud3JhcHBlci5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2xhdGUzZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB2YWx1ZSBvZiB0cmFuc2xhdGUgZnJvbSBIVE1MIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgQ29tcG9uZW50cy5IdG1sLndyYXBwZXIuc3R5bGUudHJhbnNmb3JtID0gJyc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXRTdGFydEluZGV4OiBmdW5jdGlvbiBnZXRTdGFydEluZGV4KCkge1xuICAgICAgdmFyIGxlbmd0aCA9IENvbXBvbmVudHMuU2l6ZXMubGVuZ3RoO1xuICAgICAgdmFyIGluZGV4ID0gR2xpZGUuaW5kZXg7XG4gICAgICB2YXIgcGVyVmlldyA9IEdsaWRlLnNldHRpbmdzLnBlclZpZXc7XG5cbiAgICAgIGlmIChDb21wb25lbnRzLlJ1bi5pc09mZnNldCgnPicpIHx8IENvbXBvbmVudHMuUnVuLmlzT2Zmc2V0KCd8PicpKSB7XG4gICAgICAgIHJldHVybiBsZW5ndGggKyAoaW5kZXggLSBwZXJWaWV3KTtcbiAgICAgIH0gLy8gXCJtb2R1bG8gbGVuZ3RoXCIgY29udmVydHMgYW4gaW5kZXggdGhhdCBlcXVhbHMgbGVuZ3RoIHRvIHplcm9cblxuXG4gICAgICByZXR1cm4gKGluZGV4ICsgcGVyVmlldykgJSBsZW5ndGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXRUcmF2ZWxEaXN0YW5jZTogZnVuY3Rpb24gZ2V0VHJhdmVsRGlzdGFuY2UoKSB7XG4gICAgICB2YXIgdHJhdmVsRGlzdGFuY2UgPSBDb21wb25lbnRzLlNpemVzLnNsaWRlV2lkdGggKiBHbGlkZS5zZXR0aW5ncy5wZXJWaWV3O1xuXG4gICAgICBpZiAoQ29tcG9uZW50cy5SdW4uaXNPZmZzZXQoJz4nKSB8fCBDb21wb25lbnRzLlJ1bi5pc09mZnNldCgnfD4nKSkge1xuICAgICAgICAvLyByZXZlcnNlIHRyYXZlbCBkaXN0YW5jZSBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gY2hhbmdlIHN1YnRyYWN0IG9wZXJhdGlvbnNcbiAgICAgICAgcmV0dXJuIHRyYXZlbERpc3RhbmNlICogLTE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cmF2ZWxEaXN0YW5jZTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBTZXQgbmV3IHRyYW5zbGF0ZSB2YWx1ZTpcbiAgICogLSBvbiBtb3ZlIHRvIHJlZmxlY3QgaW5kZXggY2hhbmdlXG4gICAqIC0gb24gdXBkYXRpbmcgdmlhIEFQSSB0byByZWZsZWN0IHBvc3NpYmxlIGNoYW5nZXMgaW4gb3B0aW9uc1xuICAgKi9cblxuICBFdmVudHMub24oJ21vdmUnLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIGlmICghR2xpZGUuaXNUeXBlKCdjYXJvdXNlbCcpIHx8ICFDb21wb25lbnRzLlJ1bi5pc09mZnNldCgpKSB7XG4gICAgICByZXR1cm4gVHJhbnNsYXRlLnNldChjb250ZXh0Lm1vdmVtZW50KTtcbiAgICB9XG5cbiAgICBDb21wb25lbnRzLlRyYW5zaXRpb24uYWZ0ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgRXZlbnRzLmVtaXQoJ3RyYW5zbGF0ZS5qdW1wJyk7XG4gICAgICBUcmFuc2xhdGUuc2V0KENvbXBvbmVudHMuU2l6ZXMuc2xpZGVXaWR0aCAqIEdsaWRlLmluZGV4KTtcbiAgICB9KTtcbiAgICB2YXIgc3RhcnRXaWR0aCA9IENvbXBvbmVudHMuU2l6ZXMuc2xpZGVXaWR0aCAqIENvbXBvbmVudHMuVHJhbnNsYXRlLmdldFN0YXJ0SW5kZXgoKTtcbiAgICByZXR1cm4gVHJhbnNsYXRlLnNldChzdGFydFdpZHRoIC0gQ29tcG9uZW50cy5UcmFuc2xhdGUuZ2V0VHJhdmVsRGlzdGFuY2UoKSk7XG4gIH0pO1xuICAvKipcbiAgICogUmVtb3ZlIHRyYW5zbGF0ZTpcbiAgICogLSBvbiBkZXN0cm95aW5nIHRvIGJyaW5nIG1hcmt1cCB0byBpdHMgaW5pdGFsIHN0YXRlXG4gICAqL1xuXG4gIEV2ZW50cy5vbignZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICBUcmFuc2xhdGUucmVtb3ZlKCk7XG4gIH0pO1xuICByZXR1cm4gVHJhbnNsYXRlO1xufVxuXG5mdW5jdGlvbiBUcmFuc2l0aW9uIChHbGlkZSwgQ29tcG9uZW50cywgRXZlbnRzKSB7XG4gIC8qKlxuICAgKiBIb2xkcyBpbmFjdGl2aXR5IHN0YXR1cyBvZiB0cmFuc2l0aW9uLlxuICAgKiBXaGVuIHRydWUgdHJhbnNpdGlvbiBpcyBub3QgYXBwbGllZC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICB2YXIgZGlzYWJsZWQgPSBmYWxzZTtcbiAgdmFyIFRyYW5zaXRpb24gPSB7XG4gICAgLyoqXG4gICAgICogQ29tcG9zZXMgc3RyaW5nIG9mIHRoZSBDU1MgdHJhbnNpdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBjb21wb3NlOiBmdW5jdGlvbiBjb21wb3NlKHByb3BlcnR5KSB7XG4gICAgICB2YXIgc2V0dGluZ3MgPSBHbGlkZS5zZXR0aW5ncztcblxuICAgICAgaWYgKCFkaXNhYmxlZCkge1xuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQocHJvcGVydHksIFwiIFwiKS5jb25jYXQodGhpcy5kdXJhdGlvbiwgXCJtcyBcIikuY29uY2F0KHNldHRpbmdzLmFuaW1hdGlvblRpbWluZ0Z1bmMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQocHJvcGVydHksIFwiIDBtcyBcIikuY29uY2F0KHNldHRpbmdzLmFuaW1hdGlvblRpbWluZ0Z1bmMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHZhbHVlIG9mIHRyYW5zaXRpb24gb24gSFRNTCBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmc9fSBwcm9wZXJ0eVxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoKSB7XG4gICAgICB2YXIgcHJvcGVydHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICd0cmFuc2Zvcm0nO1xuICAgICAgQ29tcG9uZW50cy5IdG1sLndyYXBwZXIuc3R5bGUudHJhbnNpdGlvbiA9IHRoaXMuY29tcG9zZShwcm9wZXJ0eSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdmFsdWUgb2YgdHJhbnNpdGlvbiBmcm9tIEhUTUwgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICBDb21wb25lbnRzLkh0bWwud3JhcHBlci5zdHlsZS50cmFuc2l0aW9uID0gJyc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJ1bnMgY2FsbGJhY2sgYWZ0ZXIgYW5pbWF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICBhZnRlcjogZnVuY3Rpb24gYWZ0ZXIoY2FsbGJhY2spIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfSwgdGhpcy5kdXJhdGlvbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVuYWJsZSB0cmFuc2l0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICBlbmFibGU6IGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICAgIGRpc2FibGVkID0gZmFsc2U7XG4gICAgICB0aGlzLnNldCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXNhYmxlIHRyYW5zaXRpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIGRpc2FibGU6IGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgICBkaXNhYmxlZCA9IHRydWU7XG4gICAgICB0aGlzLnNldCgpO1xuICAgIH1cbiAgfTtcbiAgZGVmaW5lKFRyYW5zaXRpb24sICdkdXJhdGlvbicsIHtcbiAgICAvKipcbiAgICAgKiBHZXRzIGR1cmF0aW9uIG9mIHRoZSB0cmFuc2l0aW9uIGJhc2VkXG4gICAgICogb24gY3VycmVudGx5IHJ1bm5pbmcgYW5pbWF0aW9uIHR5cGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgc2V0dGluZ3MgPSBHbGlkZS5zZXR0aW5ncztcblxuICAgICAgaWYgKEdsaWRlLmlzVHlwZSgnc2xpZGVyJykgJiYgQ29tcG9uZW50cy5SdW4ub2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBzZXR0aW5ncy5yZXdpbmREdXJhdGlvbjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNldHRpbmdzLmFuaW1hdGlvbkR1cmF0aW9uO1xuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgKiBTZXQgdHJhbnNpdGlvbiBgc3R5bGVgIHZhbHVlOlxuICAgKiAtIG9uIGVhY2ggbW92aW5nLCBiZWNhdXNlIGl0IG1heSBiZSBjbGVhcmVkIGJ5IG9mZnNldCBtb3ZlXG4gICAqL1xuXG4gIEV2ZW50cy5vbignbW92ZScsIGZ1bmN0aW9uICgpIHtcbiAgICBUcmFuc2l0aW9uLnNldCgpO1xuICB9KTtcbiAgLyoqXG4gICAqIERpc2FibGUgdHJhbnNpdGlvbjpcbiAgICogLSBiZWZvcmUgaW5pdGlhbCBidWlsZCB0byBhdm9pZCB0cmFuc2l0aW9uaW5nIGZyb20gYDBgIHRvIGBzdGFydEF0YCBpbmRleFxuICAgKiAtIHdoaWxlIHJlc2l6aW5nIHdpbmRvdyBhbmQgcmVjYWxjdWxhdGluZyBkaW1lbnNpb25zXG4gICAqIC0gb24ganVtcGluZyBmcm9tIG9mZnNldCB0cmFuc2l0aW9uIGF0IHN0YXJ0IGFuZCBlbmQgZWRnZXMgaW4gYGNhcm91c2VsYCB0eXBlXG4gICAqL1xuXG4gIEV2ZW50cy5vbihbJ2J1aWxkLmJlZm9yZScsICdyZXNpemUnLCAndHJhbnNsYXRlLmp1bXAnXSwgZnVuY3Rpb24gKCkge1xuICAgIFRyYW5zaXRpb24uZGlzYWJsZSgpO1xuICB9KTtcbiAgLyoqXG4gICAqIEVuYWJsZSB0cmFuc2l0aW9uOlxuICAgKiAtIG9uIGVhY2ggcnVubmluZywgYmVjYXVzZSBpdCBtYXkgYmUgZGlzYWJsZWQgYnkgb2Zmc2V0IG1vdmVcbiAgICovXG5cbiAgRXZlbnRzLm9uKCdydW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgVHJhbnNpdGlvbi5lbmFibGUoKTtcbiAgfSk7XG4gIC8qKlxuICAgKiBSZW1vdmUgdHJhbnNpdGlvbjpcbiAgICogLSBvbiBkZXN0cm95aW5nIHRvIGJyaW5nIG1hcmt1cCB0byBpdHMgaW5pdGFsIHN0YXRlXG4gICAqL1xuXG4gIEV2ZW50cy5vbignZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICBUcmFuc2l0aW9uLnJlbW92ZSgpO1xuICB9KTtcbiAgcmV0dXJuIFRyYW5zaXRpb247XG59XG5cbi8qKlxuICogVGVzdCB2aWEgYSBnZXR0ZXIgaW4gdGhlIG9wdGlvbnMgb2JqZWN0IHRvIHNlZVxuICogaWYgdGhlIHBhc3NpdmUgcHJvcGVydHkgaXMgYWNjZXNzZWQuXG4gKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vV0lDRy9FdmVudExpc3RlbmVyT3B0aW9ucy9ibG9iL2doLXBhZ2VzL2V4cGxhaW5lci5tZCNmZWF0dXJlLWRldGVjdGlvblxuICovXG52YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG5cbnRyeSB7XG4gIHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgfVxuICB9KTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3RQYXNzaXZlJywgbnVsbCwgb3B0cyk7XG4gIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0UGFzc2l2ZScsIG51bGwsIG9wdHMpO1xufSBjYXRjaCAoZSkge31cblxudmFyIHN1cHBvcnRzUGFzc2l2ZSQxID0gc3VwcG9ydHNQYXNzaXZlO1xuXG52YXIgU1RBUlRfRVZFTlRTID0gWyd0b3VjaHN0YXJ0JywgJ21vdXNlZG93biddO1xudmFyIE1PVkVfRVZFTlRTID0gWyd0b3VjaG1vdmUnLCAnbW91c2Vtb3ZlJ107XG52YXIgRU5EX0VWRU5UUyA9IFsndG91Y2hlbmQnLCAndG91Y2hjYW5jZWwnLCAnbW91c2V1cCcsICdtb3VzZWxlYXZlJ107XG52YXIgTU9VU0VfRVZFTlRTID0gWydtb3VzZWRvd24nLCAnbW91c2Vtb3ZlJywgJ21vdXNldXAnLCAnbW91c2VsZWF2ZSddO1xuZnVuY3Rpb24gU3dpcGUgKEdsaWRlLCBDb21wb25lbnRzLCBFdmVudHMpIHtcbiAgLyoqXG4gICAqIEluc3RhbmNlIG9mIHRoZSBiaW5kZXIgZm9yIERPTSBFdmVudHMuXG4gICAqXG4gICAqIEB0eXBlIHtFdmVudHNCaW5kZXJ9XG4gICAqL1xuICB2YXIgQmluZGVyID0gbmV3IEV2ZW50c0JpbmRlcigpO1xuICB2YXIgc3dpcGVTaW4gPSAwO1xuICB2YXIgc3dpcGVTdGFydFggPSAwO1xuICB2YXIgc3dpcGVTdGFydFkgPSAwO1xuICB2YXIgZGlzYWJsZWQgPSBmYWxzZTtcbiAgdmFyIGNhcHR1cmUgPSBzdXBwb3J0c1Bhc3NpdmUkMSA/IHtcbiAgICBwYXNzaXZlOiB0cnVlXG4gIH0gOiBmYWxzZTtcbiAgdmFyIFN3aXBlID0ge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHN3aXBlIGJpbmRpbmdzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICBtb3VudDogZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgICB0aGlzLmJpbmRTd2lwZVN0YXJ0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yIGBzd2lwZXN0YXJ0YCBldmVudC4gQ2FsY3VsYXRlcyBlbnRyeSBwb2ludHMgb2YgdGhlIHVzZXIncyB0YXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydChldmVudCkge1xuICAgICAgaWYgKCFkaXNhYmxlZCAmJiAhR2xpZGUuZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgICAgIHZhciBzd2lwZSA9IHRoaXMudG91Y2hlcyhldmVudCk7XG4gICAgICAgIHN3aXBlU2luID0gbnVsbDtcbiAgICAgICAgc3dpcGVTdGFydFggPSB0b0ludChzd2lwZS5wYWdlWCk7XG4gICAgICAgIHN3aXBlU3RhcnRZID0gdG9JbnQoc3dpcGUucGFnZVkpO1xuICAgICAgICB0aGlzLmJpbmRTd2lwZU1vdmUoKTtcbiAgICAgICAgdGhpcy5iaW5kU3dpcGVFbmQoKTtcbiAgICAgICAgRXZlbnRzLmVtaXQoJ3N3aXBlLnN0YXJ0Jyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yIGBzd2lwZW1vdmVgIGV2ZW50LiBDYWxjdWxhdGVzIHVzZXIncyB0YXAgYW5nbGUgYW5kIGRpc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAgICovXG4gICAgbW92ZTogZnVuY3Rpb24gbW92ZShldmVudCkge1xuICAgICAgaWYgKCFHbGlkZS5kaXNhYmxlZCkge1xuICAgICAgICB2YXIgX0dsaWRlJHNldHRpbmdzID0gR2xpZGUuc2V0dGluZ3MsXG4gICAgICAgICAgICB0b3VjaEFuZ2xlID0gX0dsaWRlJHNldHRpbmdzLnRvdWNoQW5nbGUsXG4gICAgICAgICAgICB0b3VjaFJhdGlvID0gX0dsaWRlJHNldHRpbmdzLnRvdWNoUmF0aW8sXG4gICAgICAgICAgICBjbGFzc2VzID0gX0dsaWRlJHNldHRpbmdzLmNsYXNzZXM7XG4gICAgICAgIHZhciBzd2lwZSA9IHRoaXMudG91Y2hlcyhldmVudCk7XG4gICAgICAgIHZhciBzdWJFeFN4ID0gdG9JbnQoc3dpcGUucGFnZVgpIC0gc3dpcGVTdGFydFg7XG4gICAgICAgIHZhciBzdWJFeVN5ID0gdG9JbnQoc3dpcGUucGFnZVkpIC0gc3dpcGVTdGFydFk7XG4gICAgICAgIHZhciBwb3dFWCA9IE1hdGguYWJzKHN1YkV4U3ggPDwgMik7XG4gICAgICAgIHZhciBwb3dFWSA9IE1hdGguYWJzKHN1YkV5U3kgPDwgMik7XG4gICAgICAgIHZhciBzd2lwZUh5cG90ZW51c2UgPSBNYXRoLnNxcnQocG93RVggKyBwb3dFWSk7XG4gICAgICAgIHZhciBzd2lwZUNhdGhldHVzID0gTWF0aC5zcXJ0KHBvd0VZKTtcbiAgICAgICAgc3dpcGVTaW4gPSBNYXRoLmFzaW4oc3dpcGVDYXRoZXR1cyAvIHN3aXBlSHlwb3RlbnVzZSk7XG5cbiAgICAgICAgaWYgKHN3aXBlU2luICogMTgwIC8gTWF0aC5QSSA8IHRvdWNoQW5nbGUpIHtcbiAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICBDb21wb25lbnRzLk1vdmUubWFrZShzdWJFeFN4ICogdG9GbG9hdCh0b3VjaFJhdGlvKSk7XG4gICAgICAgICAgQ29tcG9uZW50cy5IdG1sLnJvb3QuY2xhc3NMaXN0LmFkZChjbGFzc2VzLmRyYWdnaW5nKTtcbiAgICAgICAgICBFdmVudHMuZW1pdCgnc3dpcGUubW92ZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciBgc3dpcGVlbmRgIGV2ZW50LiBGaW5pdGlhbGl6ZXMgdXNlcidzIHRhcCBhbmQgZGVjaWRlcyBhYm91dCBnbGlkZSBtb3ZlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICBlbmQ6IGZ1bmN0aW9uIGVuZChldmVudCkge1xuICAgICAgaWYgKCFHbGlkZS5kaXNhYmxlZCkge1xuICAgICAgICB2YXIgX0dsaWRlJHNldHRpbmdzMiA9IEdsaWRlLnNldHRpbmdzLFxuICAgICAgICAgICAgcGVyU3dpcGUgPSBfR2xpZGUkc2V0dGluZ3MyLnBlclN3aXBlLFxuICAgICAgICAgICAgdG91Y2hBbmdsZSA9IF9HbGlkZSRzZXR0aW5nczIudG91Y2hBbmdsZSxcbiAgICAgICAgICAgIGNsYXNzZXMgPSBfR2xpZGUkc2V0dGluZ3MyLmNsYXNzZXM7XG4gICAgICAgIHZhciBzd2lwZSA9IHRoaXMudG91Y2hlcyhldmVudCk7XG4gICAgICAgIHZhciB0aHJlc2hvbGQgPSB0aGlzLnRocmVzaG9sZChldmVudCk7XG4gICAgICAgIHZhciBzd2lwZURpc3RhbmNlID0gc3dpcGUucGFnZVggLSBzd2lwZVN0YXJ0WDtcbiAgICAgICAgdmFyIHN3aXBlRGVnID0gc3dpcGVTaW4gKiAxODAgLyBNYXRoLlBJO1xuICAgICAgICB0aGlzLmVuYWJsZSgpO1xuXG4gICAgICAgIGlmIChzd2lwZURpc3RhbmNlID4gdGhyZXNob2xkICYmIHN3aXBlRGVnIDwgdG91Y2hBbmdsZSkge1xuICAgICAgICAgIENvbXBvbmVudHMuUnVuLm1ha2UoQ29tcG9uZW50cy5EaXJlY3Rpb24ucmVzb2x2ZShcIlwiLmNvbmNhdChwZXJTd2lwZSwgXCI8XCIpKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3dpcGVEaXN0YW5jZSA8IC10aHJlc2hvbGQgJiYgc3dpcGVEZWcgPCB0b3VjaEFuZ2xlKSB7XG4gICAgICAgICAgQ29tcG9uZW50cy5SdW4ubWFrZShDb21wb25lbnRzLkRpcmVjdGlvbi5yZXNvbHZlKFwiXCIuY29uY2F0KHBlclN3aXBlLCBcIj5cIikpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBXaGlsZSBzd2lwZSBkb24ndCByZWFjaCBkaXN0YW5jZSBhcHBseSBwcmV2aW91cyB0cmFuc2Zvcm0uXG4gICAgICAgICAgQ29tcG9uZW50cy5Nb3ZlLm1ha2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIENvbXBvbmVudHMuSHRtbC5yb290LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3Nlcy5kcmFnZ2luZyk7XG4gICAgICAgIHRoaXMudW5iaW5kU3dpcGVNb3ZlKCk7XG4gICAgICAgIHRoaXMudW5iaW5kU3dpcGVFbmQoKTtcbiAgICAgICAgRXZlbnRzLmVtaXQoJ3N3aXBlLmVuZCcpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBCaW5kcyBzd2lwZSdzIHN0YXJ0aW5nIGV2ZW50LlxuICAgICAqXG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICBiaW5kU3dpcGVTdGFydDogZnVuY3Rpb24gYmluZFN3aXBlU3RhcnQoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgX0dsaWRlJHNldHRpbmdzMyA9IEdsaWRlLnNldHRpbmdzLFxuICAgICAgICAgIHN3aXBlVGhyZXNob2xkID0gX0dsaWRlJHNldHRpbmdzMy5zd2lwZVRocmVzaG9sZCxcbiAgICAgICAgICBkcmFnVGhyZXNob2xkID0gX0dsaWRlJHNldHRpbmdzMy5kcmFnVGhyZXNob2xkO1xuXG4gICAgICBpZiAoc3dpcGVUaHJlc2hvbGQpIHtcbiAgICAgICAgQmluZGVyLm9uKFNUQVJUX0VWRU5UU1swXSwgQ29tcG9uZW50cy5IdG1sLndyYXBwZXIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIF90aGlzLnN0YXJ0KGV2ZW50KTtcbiAgICAgICAgfSwgY2FwdHVyZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkcmFnVGhyZXNob2xkKSB7XG4gICAgICAgIEJpbmRlci5vbihTVEFSVF9FVkVOVFNbMV0sIENvbXBvbmVudHMuSHRtbC53cmFwcGVyLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBfdGhpcy5zdGFydChldmVudCk7XG4gICAgICAgIH0sIGNhcHR1cmUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbmJpbmRzIHN3aXBlJ3Mgc3RhcnRpbmcgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIHVuYmluZFN3aXBlU3RhcnQ6IGZ1bmN0aW9uIHVuYmluZFN3aXBlU3RhcnQoKSB7XG4gICAgICBCaW5kZXIub2ZmKFNUQVJUX0VWRU5UU1swXSwgQ29tcG9uZW50cy5IdG1sLndyYXBwZXIsIGNhcHR1cmUpO1xuICAgICAgQmluZGVyLm9mZihTVEFSVF9FVkVOVFNbMV0sIENvbXBvbmVudHMuSHRtbC53cmFwcGVyLCBjYXB0dXJlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQmluZHMgc3dpcGUncyBtb3ZpbmcgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIGJpbmRTd2lwZU1vdmU6IGZ1bmN0aW9uIGJpbmRTd2lwZU1vdmUoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgQmluZGVyLm9uKE1PVkVfRVZFTlRTLCBDb21wb25lbnRzLkh0bWwud3JhcHBlciwgdGhyb3R0bGUoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMi5tb3ZlKGV2ZW50KTtcbiAgICAgIH0sIEdsaWRlLnNldHRpbmdzLnRocm90dGxlKSwgY2FwdHVyZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVuYmluZHMgc3dpcGUncyBtb3ZpbmcgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIHVuYmluZFN3aXBlTW92ZTogZnVuY3Rpb24gdW5iaW5kU3dpcGVNb3ZlKCkge1xuICAgICAgQmluZGVyLm9mZihNT1ZFX0VWRU5UUywgQ29tcG9uZW50cy5IdG1sLndyYXBwZXIsIGNhcHR1cmUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBCaW5kcyBzd2lwZSdzIGVuZGluZyBldmVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgYmluZFN3aXBlRW5kOiBmdW5jdGlvbiBiaW5kU3dpcGVFbmQoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgQmluZGVyLm9uKEVORF9FVkVOVFMsIENvbXBvbmVudHMuSHRtbC53cmFwcGVyLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMzLmVuZChldmVudCk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5iaW5kcyBzd2lwZSdzIGVuZGluZyBldmVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgdW5iaW5kU3dpcGVFbmQ6IGZ1bmN0aW9uIHVuYmluZFN3aXBlRW5kKCkge1xuICAgICAgQmluZGVyLm9mZihFTkRfRVZFTlRTLCBDb21wb25lbnRzLkh0bWwud3JhcHBlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZXMgZXZlbnQgdG91Y2hlcyBwb2ludHMgYWNjb3J0aW5nIHRvIGRpZmZlcmVudCB0eXBlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAqL1xuICAgIHRvdWNoZXM6IGZ1bmN0aW9uIHRvdWNoZXMoZXZlbnQpIHtcbiAgICAgIGlmIChNT1VTRV9FVkVOVFMuaW5kZXhPZihldmVudC50eXBlKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV2ZW50LnRvdWNoZXNbMF0gfHwgZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgdmFsdWUgb2YgbWluaW11bSBzd2lwZSBkaXN0YW5jZSBzZXR0aW5ncyBiYXNlZCBvbiBldmVudCB0eXBlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRocmVzaG9sZDogZnVuY3Rpb24gdGhyZXNob2xkKGV2ZW50KSB7XG4gICAgICB2YXIgc2V0dGluZ3MgPSBHbGlkZS5zZXR0aW5ncztcblxuICAgICAgaWYgKE1PVVNFX0VWRU5UUy5pbmRleE9mKGV2ZW50LnR5cGUpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHNldHRpbmdzLmRyYWdUaHJlc2hvbGQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZXR0aW5ncy5zd2lwZVRocmVzaG9sZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlcyBzd2lwZSBldmVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3NlbGZ9XG4gICAgICovXG4gICAgZW5hYmxlOiBmdW5jdGlvbiBlbmFibGUoKSB7XG4gICAgICBkaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgQ29tcG9uZW50cy5UcmFuc2l0aW9uLmVuYWJsZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpc2FibGVzIHN3aXBlIGV2ZW50LlxuICAgICAqXG4gICAgICogQHJldHVybiB7c2VsZn1cbiAgICAgKi9cbiAgICBkaXNhYmxlOiBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgICAgZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgQ29tcG9uZW50cy5UcmFuc2l0aW9uLmRpc2FibGUoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEFkZCBjb21wb25lbnQgY2xhc3M6XG4gICAqIC0gYWZ0ZXIgaW5pdGlhbCBidWlsZGluZ1xuICAgKi9cblxuICBFdmVudHMub24oJ2J1aWxkLmFmdGVyJywgZnVuY3Rpb24gKCkge1xuICAgIENvbXBvbmVudHMuSHRtbC5yb290LmNsYXNzTGlzdC5hZGQoR2xpZGUuc2V0dGluZ3MuY2xhc3Nlcy5zd2lwZWFibGUpO1xuICB9KTtcbiAgLyoqXG4gICAqIFJlbW92ZSBzd2lwaW5nIGJpbmRpbmdzOlxuICAgKiAtIG9uIGRlc3Ryb3lpbmcsIHRvIHJlbW92ZSBhZGRlZCBFdmVudExpc3RlbmVyc1xuICAgKi9cblxuICBFdmVudHMub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG4gICAgU3dpcGUudW5iaW5kU3dpcGVTdGFydCgpO1xuICAgIFN3aXBlLnVuYmluZFN3aXBlTW92ZSgpO1xuICAgIFN3aXBlLnVuYmluZFN3aXBlRW5kKCk7XG4gICAgQmluZGVyLmRlc3Ryb3koKTtcbiAgfSk7XG4gIHJldHVybiBTd2lwZTtcbn1cblxuZnVuY3Rpb24gSW1hZ2VzIChHbGlkZSwgQ29tcG9uZW50cywgRXZlbnRzKSB7XG4gIC8qKlxuICAgKiBJbnN0YW5jZSBvZiB0aGUgYmluZGVyIGZvciBET00gRXZlbnRzLlxuICAgKlxuICAgKiBAdHlwZSB7RXZlbnRzQmluZGVyfVxuICAgKi9cbiAgdmFyIEJpbmRlciA9IG5ldyBFdmVudHNCaW5kZXIoKTtcbiAgdmFyIEltYWdlcyA9IHtcbiAgICAvKipcbiAgICAgKiBCaW5kcyBsaXN0ZW5lciB0byBnbGlkZSB3cmFwcGVyLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICBtb3VudDogZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgICB0aGlzLmJpbmQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQmluZHMgYGRyYWdzdGFydGAgZXZlbnQgb24gd3JhcHBlciB0byBwcmV2ZW50IGRyYWdnaW5nIGltYWdlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAgIEJpbmRlci5vbignZHJhZ3N0YXJ0JywgQ29tcG9uZW50cy5IdG1sLndyYXBwZXIsIHRoaXMuZHJhZ3N0YXJ0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5iaW5kcyBgZHJhZ3N0YXJ0YCBldmVudCBvbiB3cmFwcGVyLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICAgIEJpbmRlci5vZmYoJ2RyYWdzdGFydCcsIENvbXBvbmVudHMuSHRtbC53cmFwcGVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRXZlbnQgaGFuZGxlci4gUHJldmVudHMgZHJhZ2dpbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIGRyYWdzdGFydDogZnVuY3Rpb24gZHJhZ3N0YXJ0KGV2ZW50KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFJlbW92ZSBiaW5kaW5ncyBmcm9tIGltYWdlczpcbiAgICogLSBvbiBkZXN0cm95aW5nLCB0byByZW1vdmUgYWRkZWQgRXZlbnRMaXN0ZW5lcnNcbiAgICovXG5cbiAgRXZlbnRzLm9uKCdkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgIEltYWdlcy51bmJpbmQoKTtcbiAgICBCaW5kZXIuZGVzdHJveSgpO1xuICB9KTtcbiAgcmV0dXJuIEltYWdlcztcbn1cblxuZnVuY3Rpb24gQW5jaG9ycyAoR2xpZGUsIENvbXBvbmVudHMsIEV2ZW50cykge1xuICAvKipcbiAgICogSW5zdGFuY2Ugb2YgdGhlIGJpbmRlciBmb3IgRE9NIEV2ZW50cy5cbiAgICpcbiAgICogQHR5cGUge0V2ZW50c0JpbmRlcn1cbiAgICovXG4gIHZhciBCaW5kZXIgPSBuZXcgRXZlbnRzQmluZGVyKCk7XG4gIC8qKlxuICAgKiBIb2xkcyBkZXRhY2hpbmcgc3RhdHVzIG9mIGFuY2hvcnMuXG4gICAqIFByZXZlbnRzIGRldGFjaGluZyBvZiBhbHJlYWR5IGRldGFjaGVkIGFuY2hvcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cblxuICB2YXIgZGV0YWNoZWQgPSBmYWxzZTtcbiAgLyoqXG4gICAqIEhvbGRzIHByZXZlbnRpbmcgc3RhdHVzIG9mIGFuY2hvcnMuXG4gICAqIElmIGB0cnVlYCByZWRpcmVjdGlvbiBhZnRlciBjbGljayB3aWxsIGJlIGRpc2FibGVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG5cbiAgdmFyIHByZXZlbnRlZCA9IGZhbHNlO1xuICB2YXIgQW5jaG9ycyA9IHtcbiAgICAvKipcbiAgICAgKiBTZXR1cHMgYSBpbml0aWFsIHN0YXRlIG9mIGFuY2hvcnMgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHJldHVybnMge1ZvaWR9XG4gICAgICovXG4gICAgbW91bnQ6IGZ1bmN0aW9uIG1vdW50KCkge1xuICAgICAgLyoqXG4gICAgICAgKiBIb2xkcyBjb2xsZWN0aW9uIG9mIGFuY2hvcnMgZWxlbWVudHMuXG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqIEB0eXBlIHtIVE1MQ29sbGVjdGlvbn1cbiAgICAgICAqL1xuICAgICAgdGhpcy5fYSA9IENvbXBvbmVudHMuSHRtbC53cmFwcGVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ2EnKTtcbiAgICAgIHRoaXMuYmluZCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBCaW5kcyBldmVudHMgdG8gYW5jaG9ycyBpbnNpZGUgYSB0cmFjay5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAgIEJpbmRlci5vbignY2xpY2snLCBDb21wb25lbnRzLkh0bWwud3JhcHBlciwgdGhpcy5jbGljayk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVuYmluZHMgZXZlbnRzIGF0dGFjaGVkIHRvIGFuY2hvcnMgaW5zaWRlIGEgdHJhY2suXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgICAgQmluZGVyLm9mZignY2xpY2snLCBDb21wb25lbnRzLkh0bWwud3JhcHBlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yIGNsaWNrIGV2ZW50LiBQcmV2ZW50cyBjbGlja3Mgd2hlbiBnbGlkZSBpcyBpbiBgcHJldmVudGAgc3RhdHVzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBldmVudFxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgY2xpY2s6IGZ1bmN0aW9uIGNsaWNrKGV2ZW50KSB7XG4gICAgICBpZiAocHJldmVudGVkKSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRhY2hlcyBhbmNob3JzIGNsaWNrIGV2ZW50IGluc2lkZSBnbGlkZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3NlbGZ9XG4gICAgICovXG4gICAgZGV0YWNoOiBmdW5jdGlvbiBkZXRhY2goKSB7XG4gICAgICBwcmV2ZW50ZWQgPSB0cnVlO1xuXG4gICAgICBpZiAoIWRldGFjaGVkKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuaXRlbXNbaV0uZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBkZXRhY2hlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyBhbmNob3JzIGNsaWNrIGV2ZW50cyBpbnNpZGUgZ2xpZGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtzZWxmfVxuICAgICAqL1xuICAgIGF0dGFjaDogZnVuY3Rpb24gYXR0YWNoKCkge1xuICAgICAgcHJldmVudGVkID0gZmFsc2U7XG5cbiAgICAgIGlmIChkZXRhY2hlZCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLml0ZW1zW2ldLmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBkZXRhY2hlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG4gIGRlZmluZShBbmNob3JzLCAnaXRlbXMnLCB7XG4gICAgLyoqXG4gICAgICogR2V0cyBjb2xsZWN0aW9uIG9mIHRoZSBhcnJvd3MgSFRNTCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0hUTUxFbGVtZW50W119XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gQW5jaG9ycy5fYTtcbiAgICB9XG4gIH0pO1xuICAvKipcbiAgICogRGV0YWNoIGFuY2hvcnMgaW5zaWRlIHNsaWRlczpcbiAgICogLSBvbiBzd2lwaW5nLCBzbyB0aGV5IHdvbid0IHJlZGlyZWN0IHRvIGl0cyBgaHJlZmAgYXR0cmlidXRlc1xuICAgKi9cblxuICBFdmVudHMub24oJ3N3aXBlLm1vdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgQW5jaG9ycy5kZXRhY2goKTtcbiAgfSk7XG4gIC8qKlxuICAgKiBBdHRhY2ggYW5jaG9ycyBpbnNpZGUgc2xpZGVzOlxuICAgKiAtIGFmdGVyIHN3aXBpbmcgYW5kIHRyYW5zaXRpb25zIGVuZHMsIHNvIHRoZXkgY2FuIHJlZGlyZWN0IGFmdGVyIGNsaWNrIGFnYWluXG4gICAqL1xuXG4gIEV2ZW50cy5vbignc3dpcGUuZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIENvbXBvbmVudHMuVHJhbnNpdGlvbi5hZnRlcihmdW5jdGlvbiAoKSB7XG4gICAgICBBbmNob3JzLmF0dGFjaCgpO1xuICAgIH0pO1xuICB9KTtcbiAgLyoqXG4gICAqIFVuYmluZCBhbmNob3JzIGluc2lkZSBzbGlkZXM6XG4gICAqIC0gb24gZGVzdHJveWluZywgdG8gYnJpbmcgYW5jaG9ycyB0byBpdHMgaW5pdGlhbCBzdGF0ZVxuICAgKi9cblxuICBFdmVudHMub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG4gICAgQW5jaG9ycy5hdHRhY2goKTtcbiAgICBBbmNob3JzLnVuYmluZCgpO1xuICAgIEJpbmRlci5kZXN0cm95KCk7XG4gIH0pO1xuICByZXR1cm4gQW5jaG9ycztcbn1cblxudmFyIE5BVl9TRUxFQ1RPUiA9ICdbZGF0YS1nbGlkZS1lbD1cImNvbnRyb2xzW25hdl1cIl0nO1xudmFyIENPTlRST0xTX1NFTEVDVE9SID0gJ1tkYXRhLWdsaWRlLWVsXj1cImNvbnRyb2xzXCJdJztcbnZhciBQUkVWSU9VU19DT05UUk9MU19TRUxFQ1RPUiA9IFwiXCIuY29uY2F0KENPTlRST0xTX1NFTEVDVE9SLCBcIiBbZGF0YS1nbGlkZS1kaXIqPVxcXCI8XFxcIl1cIik7XG52YXIgTkVYVF9DT05UUk9MU19TRUxFQ1RPUiA9IFwiXCIuY29uY2F0KENPTlRST0xTX1NFTEVDVE9SLCBcIiBbZGF0YS1nbGlkZS1kaXIqPVxcXCI+XFxcIl1cIik7XG5mdW5jdGlvbiBDb250cm9scyAoR2xpZGUsIENvbXBvbmVudHMsIEV2ZW50cykge1xuICAvKipcbiAgICogSW5zdGFuY2Ugb2YgdGhlIGJpbmRlciBmb3IgRE9NIEV2ZW50cy5cbiAgICpcbiAgICogQHR5cGUge0V2ZW50c0JpbmRlcn1cbiAgICovXG4gIHZhciBCaW5kZXIgPSBuZXcgRXZlbnRzQmluZGVyKCk7XG4gIHZhciBjYXB0dXJlID0gc3VwcG9ydHNQYXNzaXZlJDEgPyB7XG4gICAgcGFzc2l2ZTogdHJ1ZVxuICB9IDogZmFsc2U7XG4gIHZhciBDb250cm9scyA9IHtcbiAgICAvKipcbiAgICAgKiBJbml0cyBhcnJvd3MuIEJpbmRzIGV2ZW50cyBsaXN0ZW5lcnNcbiAgICAgKiB0byB0aGUgYXJyb3dzIEhUTUwgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIG1vdW50OiBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICAgIC8qKlxuICAgICAgICogQ29sbGVjdGlvbiBvZiBuYXZpZ2F0aW9uIEhUTUwgZWxlbWVudHMuXG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqIEB0eXBlIHtIVE1MQ29sbGVjdGlvbn1cbiAgICAgICAqL1xuICAgICAgdGhpcy5fbiA9IENvbXBvbmVudHMuSHRtbC5yb290LnF1ZXJ5U2VsZWN0b3JBbGwoTkFWX1NFTEVDVE9SKTtcbiAgICAgIC8qKlxuICAgICAgICogQ29sbGVjdGlvbiBvZiBjb250cm9scyBIVE1MIGVsZW1lbnRzLlxuICAgICAgICpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKiBAdHlwZSB7SFRNTENvbGxlY3Rpb259XG4gICAgICAgKi9cblxuICAgICAgdGhpcy5fYyA9IENvbXBvbmVudHMuSHRtbC5yb290LnF1ZXJ5U2VsZWN0b3JBbGwoQ09OVFJPTFNfU0VMRUNUT1IpO1xuICAgICAgLyoqXG4gICAgICAgKiBDb2xsZWN0aW9uIG9mIGFycm93IGNvbnRyb2wgSFRNTCBlbGVtZW50cy5cbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqL1xuXG4gICAgICB0aGlzLl9hcnJvd0NvbnRyb2xzID0ge1xuICAgICAgICBwcmV2aW91czogQ29tcG9uZW50cy5IdG1sLnJvb3QucXVlcnlTZWxlY3RvckFsbChQUkVWSU9VU19DT05UUk9MU19TRUxFQ1RPUiksXG4gICAgICAgIG5leHQ6IENvbXBvbmVudHMuSHRtbC5yb290LnF1ZXJ5U2VsZWN0b3JBbGwoTkVYVF9DT05UUk9MU19TRUxFQ1RPUilcbiAgICAgIH07XG4gICAgICB0aGlzLmFkZEJpbmRpbmdzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgYWN0aXZlIGNsYXNzIHRvIGN1cnJlbnQgc2xpZGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIHNldEFjdGl2ZTogZnVuY3Rpb24gc2V0QWN0aXZlKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuYWRkQ2xhc3ModGhpcy5fbltpXS5jaGlsZHJlbik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWN0aXZlIGNsYXNzIHRvIGN1cnJlbnQgc2xpZGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIHJlbW92ZUFjdGl2ZTogZnVuY3Rpb24gcmVtb3ZlQWN0aXZlKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQ2xhc3ModGhpcy5fbltpXS5jaGlsZHJlbik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgYWN0aXZlIGNsYXNzIG9uIGl0ZW1zIGluc2lkZSBuYXZpZ2F0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGNvbnRyb2xzXG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICBhZGRDbGFzczogZnVuY3Rpb24gYWRkQ2xhc3MoY29udHJvbHMpIHtcbiAgICAgIHZhciBzZXR0aW5ncyA9IEdsaWRlLnNldHRpbmdzO1xuICAgICAgdmFyIGl0ZW0gPSBjb250cm9sc1tHbGlkZS5pbmRleF07XG5cbiAgICAgIGlmICghaXRlbSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgIGl0ZW0uY2xhc3NMaXN0LmFkZChzZXR0aW5ncy5jbGFzc2VzLm5hdi5hY3RpdmUpO1xuICAgICAgICBzaWJsaW5ncyhpdGVtKS5mb3JFYWNoKGZ1bmN0aW9uIChzaWJsaW5nKSB7XG4gICAgICAgICAgc2libGluZy5jbGFzc0xpc3QucmVtb3ZlKHNldHRpbmdzLmNsYXNzZXMubmF2LmFjdGl2ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFjdGl2ZSBjbGFzcyBmcm9tIGFjdGl2ZSBjb250cm9sLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGNvbnRyb2xzXG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICByZW1vdmVDbGFzczogZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoY29udHJvbHMpIHtcbiAgICAgIHZhciBpdGVtID0gY29udHJvbHNbR2xpZGUuaW5kZXhdO1xuXG4gICAgICBpZiAoaXRlbSkge1xuICAgICAgICBpdGVtLmNsYXNzTGlzdC5yZW1vdmUoR2xpZGUuc2V0dGluZ3MuY2xhc3Nlcy5uYXYuYWN0aXZlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcywgcmVtb3ZlcyBvciBhZGRzIGBHbGlkZS5zZXR0aW5ncy5jbGFzc2VzLmRpc2FibGVkQXJyb3dgIGNsYXNzIG9uIHRoZSBjb250cm9sIGFycm93c1xuICAgICAqL1xuICAgIHNldEFycm93U3RhdGU6IGZ1bmN0aW9uIHNldEFycm93U3RhdGUoKSB7XG4gICAgICBpZiAoR2xpZGUuc2V0dGluZ3MucmV3aW5kKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG5leHQgPSBDb250cm9scy5fYXJyb3dDb250cm9scy5uZXh0O1xuICAgICAgdmFyIHByZXZpb3VzID0gQ29udHJvbHMuX2Fycm93Q29udHJvbHMucHJldmlvdXM7XG4gICAgICB0aGlzLnJlc2V0QXJyb3dTdGF0ZShuZXh0LCBwcmV2aW91cyk7XG5cbiAgICAgIGlmIChHbGlkZS5pbmRleCA9PT0gMCkge1xuICAgICAgICB0aGlzLmRpc2FibGVBcnJvdyhwcmV2aW91cyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChHbGlkZS5pbmRleCA9PT0gQ29tcG9uZW50cy5SdW4ubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZUFycm93KG5leHQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGBHbGlkZS5zZXR0aW5ncy5jbGFzc2VzLmRpc2FibGVkQXJyb3dgIGZyb20gZ2l2ZW4gTm9kZUxpc3QgZWxlbWVudHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZUxpc3RbXX0gbGlzdHNcbiAgICAgKi9cbiAgICByZXNldEFycm93U3RhdGU6IGZ1bmN0aW9uIHJlc2V0QXJyb3dTdGF0ZSgpIHtcbiAgICAgIHZhciBzZXR0aW5ncyA9IEdsaWRlLnNldHRpbmdzO1xuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbGlzdHMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGxpc3RzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBsaXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICAgIHRvQXJyYXkobGlzdCkuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShzZXR0aW5ncy5jbGFzc2VzLmFycm93LmRpc2FibGVkKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBgR2xpZGUuc2V0dGluZ3MuY2xhc3Nlcy5kaXNhYmxlZEFycm93YCB0byBnaXZlbiBOb2RlTGlzdCBlbGVtZW50c1xuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlTGlzdFtdfSBsaXN0c1xuICAgICAqL1xuICAgIGRpc2FibGVBcnJvdzogZnVuY3Rpb24gZGlzYWJsZUFycm93KCkge1xuICAgICAgdmFyIHNldHRpbmdzID0gR2xpZGUuc2V0dGluZ3M7XG5cbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgbGlzdHMgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgbGlzdHNbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgbGlzdHMuZm9yRWFjaChmdW5jdGlvbiAobGlzdCkge1xuICAgICAgICB0b0FycmF5KGxpc3QpLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoc2V0dGluZ3MuY2xhc3Nlcy5hcnJvdy5kaXNhYmxlZCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgaGFuZGxlcyB0byB0aGUgZWFjaCBncm91cCBvZiBjb250cm9scy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgYWRkQmluZGluZ3M6IGZ1bmN0aW9uIGFkZEJpbmRpbmdzKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuYmluZCh0aGlzLl9jW2ldLmNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBoYW5kbGVzIGZyb20gdGhlIGVhY2ggZ3JvdXAgb2YgY29udHJvbHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIHJlbW92ZUJpbmRpbmdzOiBmdW5jdGlvbiByZW1vdmVCaW5kaW5ncygpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fYy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnVuYmluZCh0aGlzLl9jW2ldLmNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQmluZHMgZXZlbnRzIHRvIGFycm93cyBIVE1MIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MQ29sbGVjdGlvbn0gZWxlbWVudHNcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoZWxlbWVudHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgQmluZGVyLm9uKCdjbGljaycsIGVsZW1lbnRzW2ldLCB0aGlzLmNsaWNrKTtcbiAgICAgICAgQmluZGVyLm9uKCd0b3VjaHN0YXJ0JywgZWxlbWVudHNbaV0sIHRoaXMuY2xpY2ssIGNhcHR1cmUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbmJpbmRzIGV2ZW50cyBiaW5kZWQgdG8gdGhlIGFycm93cyBIVE1MIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MQ29sbGVjdGlvbn0gZWxlbWVudHNcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKGVsZW1lbnRzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIEJpbmRlci5vZmYoWydjbGljaycsICd0b3VjaHN0YXJ0J10sIGVsZW1lbnRzW2ldKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBgY2xpY2tgIGV2ZW50IG9uIHRoZSBhcnJvd3MgSFRNTCBlbGVtZW50cy5cbiAgICAgKiBNb3ZlcyBzbGlkZXIgaW4gZGlyZWN0aW9uIGdpdmVuIHZpYSB0aGVcbiAgICAgKiBgZGF0YS1nbGlkZS1kaXJgIGF0dHJpYnV0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgY2xpY2s6IGZ1bmN0aW9uIGNsaWNrKGV2ZW50KSB7XG4gICAgICBpZiAoIXN1cHBvcnRzUGFzc2l2ZSQxICYmIGV2ZW50LnR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGlyZWN0aW9uID0gZXZlbnQuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZ2xpZGUtZGlyJyk7XG4gICAgICBDb21wb25lbnRzLlJ1bi5tYWtlKENvbXBvbmVudHMuRGlyZWN0aW9uLnJlc29sdmUoZGlyZWN0aW9uKSk7XG4gICAgfVxuICB9O1xuICBkZWZpbmUoQ29udHJvbHMsICdpdGVtcycsIHtcbiAgICAvKipcbiAgICAgKiBHZXRzIGNvbGxlY3Rpb24gb2YgdGhlIGNvbnRyb2xzIEhUTUwgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudFtdfVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIENvbnRyb2xzLl9jO1xuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgKiBTd2FwIGFjdGl2ZSBjbGFzcyBvZiBjdXJyZW50IG5hdmlnYXRpb24gaXRlbTpcbiAgICogLSBhZnRlciBtb3VudGluZyB0byBzZXQgaXQgdG8gaW5pdGlhbCBpbmRleFxuICAgKiAtIGFmdGVyIGVhY2ggbW92ZSB0byB0aGUgbmV3IGluZGV4XG4gICAqL1xuXG4gIEV2ZW50cy5vbihbJ21vdW50LmFmdGVyJywgJ21vdmUuYWZ0ZXInXSwgZnVuY3Rpb24gKCkge1xuICAgIENvbnRyb2xzLnNldEFjdGl2ZSgpO1xuICB9KTtcbiAgLyoqXG4gICAqIEFkZCBvciByZW1vdmUgZGlzYWJsZWQgY2xhc3Mgb2YgYXJyb3cgZWxlbWVudHNcbiAgICovXG5cbiAgRXZlbnRzLm9uKFsnbW91bnQuYWZ0ZXInLCAncnVuJ10sIGZ1bmN0aW9uICgpIHtcbiAgICBDb250cm9scy5zZXRBcnJvd1N0YXRlKCk7XG4gIH0pO1xuICAvKipcbiAgICogUmVtb3ZlIGJpbmRpbmdzIGFuZCBIVE1MIENsYXNzZXM6XG4gICAqIC0gb24gZGVzdHJveWluZywgdG8gYnJpbmcgbWFya3VwIHRvIGl0cyBpbml0aWFsIHN0YXRlXG4gICAqL1xuXG4gIEV2ZW50cy5vbignZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICBDb250cm9scy5yZW1vdmVCaW5kaW5ncygpO1xuICAgIENvbnRyb2xzLnJlbW92ZUFjdGl2ZSgpO1xuICAgIEJpbmRlci5kZXN0cm95KCk7XG4gIH0pO1xuICByZXR1cm4gQ29udHJvbHM7XG59XG5cbmZ1bmN0aW9uIEtleWJvYXJkIChHbGlkZSwgQ29tcG9uZW50cywgRXZlbnRzKSB7XG4gIC8qKlxuICAgKiBJbnN0YW5jZSBvZiB0aGUgYmluZGVyIGZvciBET00gRXZlbnRzLlxuICAgKlxuICAgKiBAdHlwZSB7RXZlbnRzQmluZGVyfVxuICAgKi9cbiAgdmFyIEJpbmRlciA9IG5ldyBFdmVudHNCaW5kZXIoKTtcbiAgdmFyIEtleWJvYXJkID0ge1xuICAgIC8qKlxuICAgICAqIEJpbmRzIGtleWJvYXJkIGV2ZW50cyBvbiBjb21wb25lbnQgbW91bnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIG1vdW50OiBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICAgIGlmIChHbGlkZS5zZXR0aW5ncy5rZXlib2FyZCkge1xuICAgICAgICB0aGlzLmJpbmQoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBrZXlib2FyZCBwcmVzcyBldmVudHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgICBCaW5kZXIub24oJ2tleXVwJywgZG9jdW1lbnQsIHRoaXMucHJlc3MpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGtleWJvYXJkIHByZXNzIGV2ZW50cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgICBCaW5kZXIub2ZmKCdrZXl1cCcsIGRvY3VtZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBrZXlib2FyZCdzIGFycm93cyBwcmVzcyBhbmQgbW92aW5nIGdsaWRlIGZvd2FyZCBhbmQgYmFja3dhcmQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGV2ZW50XG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICBwcmVzczogZnVuY3Rpb24gcHJlc3MoZXZlbnQpIHtcbiAgICAgIHZhciBwZXJTd2lwZSA9IEdsaWRlLnNldHRpbmdzLnBlclN3aXBlO1xuXG4gICAgICBpZiAoZXZlbnQuY29kZSA9PT0gJ0Fycm93UmlnaHQnKSB7XG4gICAgICAgIENvbXBvbmVudHMuUnVuLm1ha2UoQ29tcG9uZW50cy5EaXJlY3Rpb24ucmVzb2x2ZShcIlwiLmNvbmNhdChwZXJTd2lwZSwgXCI+XCIpKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudC5jb2RlID09PSAnQXJyb3dMZWZ0Jykge1xuICAgICAgICBDb21wb25lbnRzLlJ1bi5tYWtlKENvbXBvbmVudHMuRGlyZWN0aW9uLnJlc29sdmUoXCJcIi5jb25jYXQocGVyU3dpcGUsIFwiPFwiKSkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFJlbW92ZSBiaW5kaW5ncyBmcm9tIGtleWJvYXJkOlxuICAgKiAtIG9uIGRlc3Ryb3lpbmcgdG8gcmVtb3ZlIGFkZGVkIGV2ZW50c1xuICAgKiAtIG9uIHVwZGF0aW5nIHRvIHJlbW92ZSBldmVudHMgYmVmb3JlIHJlbW91bnRpbmdcbiAgICovXG5cbiAgRXZlbnRzLm9uKFsnZGVzdHJveScsICd1cGRhdGUnXSwgZnVuY3Rpb24gKCkge1xuICAgIEtleWJvYXJkLnVuYmluZCgpO1xuICB9KTtcbiAgLyoqXG4gICAqIFJlbW91bnQgY29tcG9uZW50XG4gICAqIC0gb24gdXBkYXRpbmcgdG8gcmVmbGVjdCBwb3RlbnRpYWwgY2hhbmdlcyBpbiBzZXR0aW5nc1xuICAgKi9cblxuICBFdmVudHMub24oJ3VwZGF0ZScsIGZ1bmN0aW9uICgpIHtcbiAgICBLZXlib2FyZC5tb3VudCgpO1xuICB9KTtcbiAgLyoqXG4gICAqIERlc3Ryb3kgYmluZGVyOlxuICAgKiAtIG9uIGRlc3Ryb3lpbmcgdG8gcmVtb3ZlIGxpc3RlbmVyc1xuICAgKi9cblxuICBFdmVudHMub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG4gICAgQmluZGVyLmRlc3Ryb3koKTtcbiAgfSk7XG4gIHJldHVybiBLZXlib2FyZDtcbn1cblxuZnVuY3Rpb24gQXV0b3BsYXkgKEdsaWRlLCBDb21wb25lbnRzLCBFdmVudHMpIHtcbiAgLyoqXG4gICAqIEluc3RhbmNlIG9mIHRoZSBiaW5kZXIgZm9yIERPTSBFdmVudHMuXG4gICAqXG4gICAqIEB0eXBlIHtFdmVudHNCaW5kZXJ9XG4gICAqL1xuICB2YXIgQmluZGVyID0gbmV3IEV2ZW50c0JpbmRlcigpO1xuICB2YXIgQXV0b3BsYXkgPSB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYXV0b3BsYXlpbmcgYW5kIGV2ZW50cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgbW91bnQ6IGZ1bmN0aW9uIG1vdW50KCkge1xuICAgICAgdGhpcy5lbmFibGUoKTtcbiAgICAgIHRoaXMuc3RhcnQoKTtcblxuICAgICAgaWYgKEdsaWRlLnNldHRpbmdzLmhvdmVycGF1c2UpIHtcbiAgICAgICAgdGhpcy5iaW5kKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgYXV0b3BsYXlpbmdcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtWb2lkfVxuICAgICAqL1xuICAgIGVuYWJsZTogZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgICAgdGhpcy5fZSA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpc2FibGVzIGF1dG9wbGF5aW5nLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1ZvaWR9XG4gICAgICovXG4gICAgZGlzYWJsZTogZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICAgIHRoaXMuX2UgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RhcnRzIGF1dG9wbGF5aW5nIGluIGNvbmZpZ3VyZWQgaW50ZXJ2YWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW58TnVtYmVyfSBmb3JjZSBSdW4gYXV0b3BsYXlpbmcgd2l0aCBwYXNzZWQgaW50ZXJ2YWwgcmVnYXJkbGVzcyBvZiBgYXV0b3BsYXlgIHNldHRpbmdzXG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoaXMuX2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVuYWJsZSgpO1xuXG4gICAgICBpZiAoR2xpZGUuc2V0dGluZ3MuYXV0b3BsYXkpIHtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRoaXMuX2kpKSB7XG4gICAgICAgICAgdGhpcy5faSA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnN0b3AoKTtcblxuICAgICAgICAgICAgQ29tcG9uZW50cy5SdW4ubWFrZSgnPicpO1xuXG4gICAgICAgICAgICBfdGhpcy5zdGFydCgpO1xuXG4gICAgICAgICAgICBFdmVudHMuZW1pdCgnYXV0b3BsYXknKTtcbiAgICAgICAgICB9LCB0aGlzLnRpbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0b3BzIGF1dG9ydW5uaW5nIG9mIHRoZSBnbGlkZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgIHRoaXMuX2kgPSBjbGVhckludGVydmFsKHRoaXMuX2kpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdG9wcyBhdXRvcGxheWluZyB3aGlsZSBtb3VzZSBpcyBvdmVyIGdsaWRlJ3MgYXJlYS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBCaW5kZXIub24oJ21vdXNlb3ZlcicsIENvbXBvbmVudHMuSHRtbC5yb290LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpczIuX2UpIHtcbiAgICAgICAgICBfdGhpczIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIEJpbmRlci5vbignbW91c2VvdXQnLCBDb21wb25lbnRzLkh0bWwucm9vdCwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXMyLl9lKSB7XG4gICAgICAgICAgX3RoaXMyLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbmJpbmQgbW91c2VvdmVyIGV2ZW50cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtWb2lkfVxuICAgICAqL1xuICAgIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgICAgQmluZGVyLm9mZihbJ21vdXNlb3ZlcicsICdtb3VzZW91dCddLCBDb21wb25lbnRzLkh0bWwucm9vdCk7XG4gICAgfVxuICB9O1xuICBkZWZpbmUoQXV0b3BsYXksICd0aW1lJywge1xuICAgIC8qKlxuICAgICAqIEdldHMgdGltZSBwZXJpb2QgdmFsdWUgZm9yIHRoZSBhdXRvcGxheSBpbnRlcnZhbC4gUHJpb3JpdGl6ZXNcbiAgICAgKiB0aW1lcyBpbiBgZGF0YS1nbGlkZS1hdXRvcGxheWAgYXR0cnVidXRlcyBvdmVyIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgYXV0b3BsYXkgPSBDb21wb25lbnRzLkh0bWwuc2xpZGVzW0dsaWRlLmluZGV4XS5nZXRBdHRyaWJ1dGUoJ2RhdGEtZ2xpZGUtYXV0b3BsYXknKTtcblxuICAgICAgaWYgKGF1dG9wbGF5KSB7XG4gICAgICAgIHJldHVybiB0b0ludChhdXRvcGxheSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0b0ludChHbGlkZS5zZXR0aW5ncy5hdXRvcGxheSk7XG4gICAgfVxuICB9KTtcbiAgLyoqXG4gICAqIFN0b3AgYXV0b3BsYXlpbmcgYW5kIHVuYmluZCBldmVudHM6XG4gICAqIC0gb24gZGVzdHJveWluZywgdG8gY2xlYXIgZGVmaW5lZCBpbnRlcnZhbFxuICAgKiAtIG9uIHVwZGF0aW5nIHZpYSBBUEkgdG8gcmVzZXQgaW50ZXJ2YWwgdGhhdCBtYXkgY2hhbmdlZFxuICAgKi9cblxuICBFdmVudHMub24oWydkZXN0cm95JywgJ3VwZGF0ZSddLCBmdW5jdGlvbiAoKSB7XG4gICAgQXV0b3BsYXkudW5iaW5kKCk7XG4gIH0pO1xuICAvKipcbiAgICogU3RvcCBhdXRvcGxheWluZzpcbiAgICogLSBiZWZvcmUgZWFjaCBydW4sIHRvIHJlc3RhcnQgYXV0b3BsYXlpbmdcbiAgICogLSBvbiBwYXVzaW5nIHZpYSBBUElcbiAgICogLSBvbiBkZXN0cm95aW5nLCB0byBjbGVhciBkZWZpbmVkIGludGVydmFsXG4gICAqIC0gd2hpbGUgc3RhcnRpbmcgYSBzd2lwZVxuICAgKiAtIG9uIHVwZGF0aW5nIHZpYSBBUEkgdG8gcmVzZXQgaW50ZXJ2YWwgdGhhdCBtYXkgY2hhbmdlZFxuICAgKi9cblxuICBFdmVudHMub24oWydydW4uYmVmb3JlJywgJ3N3aXBlLnN0YXJ0JywgJ3VwZGF0ZSddLCBmdW5jdGlvbiAoKSB7XG4gICAgQXV0b3BsYXkuc3RvcCgpO1xuICB9KTtcbiAgRXZlbnRzLm9uKFsncGF1c2UnLCAnZGVzdHJveSddLCBmdW5jdGlvbiAoKSB7XG4gICAgQXV0b3BsYXkuZGlzYWJsZSgpO1xuICAgIEF1dG9wbGF5LnN0b3AoKTtcbiAgfSk7XG4gIC8qKlxuICAgKiBTdGFydCBhdXRvcGxheWluZzpcbiAgICogLSBhZnRlciBlYWNoIHJ1biwgdG8gcmVzdGFydCBhdXRvcGxheWluZ1xuICAgKiAtIG9uIHBsYXlpbmcgdmlhIEFQSVxuICAgKiAtIHdoaWxlIGVuZGluZyBhIHN3aXBlXG4gICAqL1xuXG4gIEV2ZW50cy5vbihbJ3J1bi5hZnRlcicsICdzd2lwZS5lbmQnXSwgZnVuY3Rpb24gKCkge1xuICAgIEF1dG9wbGF5LnN0YXJ0KCk7XG4gIH0pO1xuICAvKipcbiAgICogU3RhcnQgYXV0b3BsYXlpbmc6XG4gICAqIC0gYWZ0ZXIgZWFjaCBydW4sIHRvIHJlc3RhcnQgYXV0b3BsYXlpbmdcbiAgICogLSBvbiBwbGF5aW5nIHZpYSBBUElcbiAgICogLSB3aGlsZSBlbmRpbmcgYSBzd2lwZVxuICAgKi9cblxuICBFdmVudHMub24oWydwbGF5J10sIGZ1bmN0aW9uICgpIHtcbiAgICBBdXRvcGxheS5lbmFibGUoKTtcbiAgICBBdXRvcGxheS5zdGFydCgpO1xuICB9KTtcbiAgLyoqXG4gICAqIFJlbW91bnQgYXV0b3BsYXlpbmc6XG4gICAqIC0gb24gdXBkYXRpbmcgdmlhIEFQSSB0byByZXNldCBpbnRlcnZhbCB0aGF0IG1heSBjaGFuZ2VkXG4gICAqL1xuXG4gIEV2ZW50cy5vbigndXBkYXRlJywgZnVuY3Rpb24gKCkge1xuICAgIEF1dG9wbGF5Lm1vdW50KCk7XG4gIH0pO1xuICAvKipcbiAgICogRGVzdHJveSBhIGJpbmRlcjpcbiAgICogLSBvbiBkZXN0cm95aW5nIGdsaWRlIGluc3RhbmNlIHRvIGNsZWFydXAgbGlzdGVuZXJzXG4gICAqL1xuXG4gIEV2ZW50cy5vbignZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICBCaW5kZXIuZGVzdHJveSgpO1xuICB9KTtcbiAgcmV0dXJuIEF1dG9wbGF5O1xufVxuXG4vKipcbiAqIFNvcnRzIGtleXMgb2YgYnJlYWtwb2ludCBvYmplY3Qgc28gdGhleSB3aWxsIGJlIG9yZGVyZWQgZnJvbSBsb3dlciB0byBiaWdnZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBvaW50c1xuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBzb3J0QnJlYWtwb2ludHMocG9pbnRzKSB7XG4gIGlmIChpc09iamVjdChwb2ludHMpKSB7XG4gICAgcmV0dXJuIHNvcnRLZXlzKHBvaW50cyk7XG4gIH0gZWxzZSB7XG4gICAgd2FybihcIkJyZWFrcG9pbnRzIG9wdGlvbiBtdXN0IGJlIGFuIG9iamVjdFwiKTtcbiAgfVxuXG4gIHJldHVybiB7fTtcbn1cblxuZnVuY3Rpb24gQnJlYWtwb2ludHMgKEdsaWRlLCBDb21wb25lbnRzLCBFdmVudHMpIHtcbiAgLyoqXG4gICAqIEluc3RhbmNlIG9mIHRoZSBiaW5kZXIgZm9yIERPTSBFdmVudHMuXG4gICAqXG4gICAqIEB0eXBlIHtFdmVudHNCaW5kZXJ9XG4gICAqL1xuICB2YXIgQmluZGVyID0gbmV3IEV2ZW50c0JpbmRlcigpO1xuICAvKipcbiAgICogSG9sZHMgcmVmZXJlbmNlIHRvIHNldHRpbmdzLlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cblxuICB2YXIgc2V0dGluZ3MgPSBHbGlkZS5zZXR0aW5ncztcbiAgLyoqXG4gICAqIEhvbGRzIHJlZmVyZW5jZSB0byBicmVha3BvaW50cyBvYmplY3QgaW4gc2V0dGluZ3MuIFNvcnRzIGJyZWFrcG9pbnRzXG4gICAqIGZyb20gc21hbGxlciB0byBsYXJnZXIuIEl0IGlzIHJlcXVpcmVkIGluIG9yZGVyIHRvIHByb3BlclxuICAgKiBtYXRjaGluZyBjdXJyZW50bHkgYWN0aXZlIGJyZWFrcG9pbnQgc2V0dGluZ3MuXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuXG4gIHZhciBwb2ludHMgPSBzb3J0QnJlYWtwb2ludHMoc2V0dGluZ3MuYnJlYWtwb2ludHMpO1xuICAvKipcbiAgICogQ2FjaGUgaW5pdGlhbCBzZXR0aW5ncyBiZWZvcmUgb3ZlcndyaXR0aW5nLlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cblxuICB2YXIgZGVmYXVsdHMgPSBPYmplY3QuYXNzaWduKHt9LCBzZXR0aW5ncyk7XG4gIHZhciBCcmVha3BvaW50cyA9IHtcbiAgICAvKipcbiAgICAgKiBNYXRjaGVzIHNldHRpbmdzIGZvciBjdXJyZWN0bHkgbWF0Y2hpbmcgbWVkaWEgYnJlYWtwb2ludC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludHNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChwb2ludHMpIHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93Lm1hdGNoTWVkaWEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGZvciAodmFyIHBvaW50IGluIHBvaW50cykge1xuICAgICAgICAgIGlmIChwb2ludHMuaGFzT3duUHJvcGVydHkocG9pbnQpKSB7XG4gICAgICAgICAgICBpZiAod2luZG93Lm1hdGNoTWVkaWEoXCIobWF4LXdpZHRoOiBcIi5jb25jYXQocG9pbnQsIFwicHgpXCIpKS5tYXRjaGVzKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwb2ludHNbcG9pbnRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVmYXVsdHM7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogT3ZlcndyaXRlIGluc3RhbmNlIHNldHRpbmdzIHdpdGggY3VycmVudGx5IG1hdGNoaW5nIGJyZWFrcG9pbnQgc2V0dGluZ3MuXG4gICAqIFRoaXMgaGFwcGVucyByaWdodCBhZnRlciBjb21wb25lbnQgaW5pdGlhbGl6YXRpb24uXG4gICAqL1xuXG4gIE9iamVjdC5hc3NpZ24oc2V0dGluZ3MsIEJyZWFrcG9pbnRzLm1hdGNoKHBvaW50cykpO1xuICAvKipcbiAgICogVXBkYXRlIGdsaWRlIHdpdGggc2V0dGluZ3Mgb2YgbWF0Y2hlZCBicmVrcG9pbnQ6XG4gICAqIC0gd2luZG93IHJlc2l6ZSB0byB1cGRhdGUgc2xpZGVyXG4gICAqL1xuXG4gIEJpbmRlci5vbigncmVzaXplJywgd2luZG93LCB0aHJvdHRsZShmdW5jdGlvbiAoKSB7XG4gICAgR2xpZGUuc2V0dGluZ3MgPSBtZXJnZU9wdGlvbnMoc2V0dGluZ3MsIEJyZWFrcG9pbnRzLm1hdGNoKHBvaW50cykpO1xuICB9LCBHbGlkZS5zZXR0aW5ncy50aHJvdHRsZSkpO1xuICAvKipcbiAgICogUmVzb3J0IGFuZCB1cGRhdGUgZGVmYXVsdCBzZXR0aW5nczpcbiAgICogLSBvbiByZWluaXQgdmlhIEFQSSwgc28gYnJlYWtwb2ludCBtYXRjaGluZyB3aWxsIGJlIHBlcmZvcm1lZCB3aXRoIG9wdGlvbnNcbiAgICovXG5cbiAgRXZlbnRzLm9uKCd1cGRhdGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgcG9pbnRzID0gc29ydEJyZWFrcG9pbnRzKHBvaW50cyk7XG4gICAgZGVmYXVsdHMgPSBPYmplY3QuYXNzaWduKHt9LCBzZXR0aW5ncyk7XG4gIH0pO1xuICAvKipcbiAgICogVW5iaW5kIHJlc2l6ZSBsaXN0ZW5lcjpcbiAgICogLSBvbiBkZXN0cm95aW5nLCB0byBicmluZyBtYXJrdXAgdG8gaXRzIGluaXRpYWwgc3RhdGVcbiAgICovXG5cbiAgRXZlbnRzLm9uKCdkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgIEJpbmRlci5vZmYoJ3Jlc2l6ZScsIHdpbmRvdyk7XG4gIH0pO1xuICByZXR1cm4gQnJlYWtwb2ludHM7XG59XG5cbnZhciBDT01QT05FTlRTID0ge1xuICAvLyBSZXF1aXJlZFxuICBIdG1sOiBIdG1sLFxuICBUcmFuc2xhdGU6IFRyYW5zbGF0ZSxcbiAgVHJhbnNpdGlvbjogVHJhbnNpdGlvbixcbiAgRGlyZWN0aW9uOiBEaXJlY3Rpb24sXG4gIFBlZWs6IFBlZWssXG4gIFNpemVzOiBTaXplcyxcbiAgR2FwczogR2FwcyxcbiAgTW92ZTogTW92ZSxcbiAgQ2xvbmVzOiBDbG9uZXMsXG4gIFJlc2l6ZTogUmVzaXplLFxuICBCdWlsZDogQnVpbGQsXG4gIFJ1bjogUnVuLFxuICAvLyBPcHRpb25hbFxuICBTd2lwZTogU3dpcGUsXG4gIEltYWdlczogSW1hZ2VzLFxuICBBbmNob3JzOiBBbmNob3JzLFxuICBDb250cm9sczogQ29udHJvbHMsXG4gIEtleWJvYXJkOiBLZXlib2FyZCxcbiAgQXV0b3BsYXk6IEF1dG9wbGF5LFxuICBCcmVha3BvaW50czogQnJlYWtwb2ludHNcbn07XG5cbnZhciBHbGlkZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NvcmUpIHtcbiAgX2luaGVyaXRzKEdsaWRlLCBfQ29yZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihHbGlkZSk7XG5cbiAgZnVuY3Rpb24gR2xpZGUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEdsaWRlKTtcblxuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhHbGlkZSwgW3tcbiAgICBrZXk6IFwibW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgICB2YXIgZXh0ZW5zaW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICByZXR1cm4gX2dldChfZ2V0UHJvdG90eXBlT2YoR2xpZGUucHJvdG90eXBlKSwgXCJtb3VudFwiLCB0aGlzKS5jYWxsKHRoaXMsIE9iamVjdC5hc3NpZ24oe30sIENPTVBPTkVOVFMsIGV4dGVuc2lvbnMpKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gR2xpZGU7XG59KEdsaWRlJDEpO1xuXG5leHBvcnQgeyBHbGlkZSBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOlsiX3R5cGVvZiIsIm9iaiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJ2YWx1ZSIsIl9zZXRQcm90b3R5cGVPZiIsIl9nZXRQcm90b3R5cGVPZiIsIm8iLCJzZXRQcm90b3R5cGVPZiIsImdldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwicCIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJSZWZsZWN0IiwiY29uc3RydWN0Iiwic2hhbSIsIlByb3h5IiwiQm9vbGVhbiIsInZhbHVlT2YiLCJjYWxsIiwiZSIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJzZWxmIiwiUmVmZXJlbmNlRXJyb3IiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsIl9jcmVhdGVTdXBlciIsIkRlcml2ZWQiLCJoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiX2NyZWF0ZVN1cGVySW50ZXJuYWwiLCJTdXBlciIsInJlc3VsdCIsIk5ld1RhcmdldCIsImFyZ3VtZW50cyIsImFwcGx5IiwiX3N1cGVyUHJvcEJhc2UiLCJvYmplY3QiLCJwcm9wZXJ0eSIsImhhc093blByb3BlcnR5IiwiX2dldCIsImdldCIsInJlY2VpdmVyIiwiYmFzZSIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJkZWZhdWx0cyIsInR5cGUiLCJzdGFydEF0IiwicGVyVmlldyIsImZvY3VzQXQiLCJnYXAiLCJhdXRvcGxheSIsImhvdmVycGF1c2UiLCJrZXlib2FyZCIsImJvdW5kIiwic3dpcGVUaHJlc2hvbGQiLCJkcmFnVGhyZXNob2xkIiwicGVyU3dpcGUiLCJ0b3VjaFJhdGlvIiwidG91Y2hBbmdsZSIsImFuaW1hdGlvbkR1cmF0aW9uIiwicmV3aW5kIiwicmV3aW5kRHVyYXRpb24iLCJhbmltYXRpb25UaW1pbmdGdW5jIiwid2FpdEZvclRyYW5zaXRpb24iLCJ0aHJvdHRsZSIsImRpcmVjdGlvbiIsInBlZWsiLCJjbG9uaW5nUmF0aW8iLCJicmVha3BvaW50cyIsImNsYXNzZXMiLCJzd2lwZWFibGUiLCJkcmFnZ2luZyIsImx0ciIsInJ0bCIsInNsaWRlciIsImNhcm91c2VsIiwic2xpZGUiLCJjbG9uZSIsImFjdGl2ZSIsImFycm93IiwiZGlzYWJsZWQiLCJuYXYiLCJ3YXJuIiwibXNnIiwiY29uc29sZSIsImVycm9yIiwiY29uY2F0IiwidG9JbnQiLCJwYXJzZUludCIsInRvRmxvYXQiLCJwYXJzZUZsb2F0IiwiaXNTdHJpbmciLCJpc09iamVjdCIsImlzRnVuY3Rpb24iLCJpc1VuZGVmaW5lZCIsImlzQXJyYXkiLCJBcnJheSIsIm1vdW50IiwiZ2xpZGUiLCJleHRlbnNpb25zIiwiZXZlbnRzIiwiY29tcG9uZW50cyIsIm5hbWUiLCJfbmFtZSIsImRlZmluZSIsInByb3AiLCJkZWZpbml0aW9uIiwic29ydEtleXMiLCJrZXlzIiwic29ydCIsInJlZHVjZSIsInIiLCJrIiwibWVyZ2VPcHRpb25zIiwic2V0dGluZ3MiLCJvcHRpb25zIiwiYXNzaWduIiwiRXZlbnRzQnVzIiwidW5kZWZpbmVkIiwiaG9wIiwib24iLCJldmVudCIsImhhbmRsZXIiLCJpbmRleCIsInB1c2giLCJyZW1vdmUiLCJlbWl0IiwiY29udGV4dCIsImZvckVhY2giLCJpdGVtIiwiR2xpZGUkMSIsIkdsaWRlIiwic2VsZWN0b3IiLCJfYyIsIl90IiwiX2UiLCJtb3VudCQxIiwibXV0YXRlIiwidHJhbnNmb3JtZXJzIiwidXBkYXRlIiwiZ28iLCJwYXR0ZXJuIiwiUnVuIiwibWFrZSIsIm1vdmUiLCJkaXN0YW5jZSIsIlRyYW5zaXRpb24iLCJkaXNhYmxlIiwiTW92ZSIsImRlc3Ryb3kiLCJwbGF5IiwiaW50ZXJ2YWwiLCJwYXVzZSIsImVuYWJsZSIsImlzVHlwZSIsIl9vIiwic2V0IiwiX2kiLCJfZCIsInN0YXR1cyIsIkNvbXBvbmVudHMiLCJFdmVudHMiLCJfdGhpcyIsImNhbGN1bGF0ZSIsImFmdGVyIiwiaXNTdGFydCIsImlzRW5kIiwiaXNPZmZzZXQiLCJzdGVwcyIsInZpZXdTaXplIiwiY2FsY3VsYXRlRm9yd2FyZEluZGV4Iiwibm9ybWFsaXplRm9yd2FyZEluZGV4IiwiX2luZGV4IiwiY2FsY3VsYXRlQmFja3dhcmRJbmRleCIsIm5vcm1hbGl6ZUJhY2t3YXJkSW5kZXgiLCJpc0JvdW5kIiwiTWF0aCIsImZsb29yIiwidmlldyIsImNlaWwiLCJfbSIsInN0ZXAiLCJzdWJzdHIiLCJIdG1sIiwic2xpZGVzIiwibm93IiwiRGF0ZSIsImdldFRpbWUiLCJmdW5jIiwid2FpdCIsInRpbWVvdXQiLCJhcmdzIiwicHJldmlvdXMiLCJsYXRlciIsImxlYWRpbmciLCJ0aHJvdHRsZWQiLCJhdCIsInJlbWFpbmluZyIsImNsZWFyVGltZW91dCIsInRyYWlsaW5nIiwic2V0VGltZW91dCIsImNhbmNlbCIsIk1BUkdJTl9UWVBFIiwiR2FwcyIsImxlbiIsInN0eWxlIiwiRGlyZWN0aW9uIiwibWFyZ2luTGVmdCIsIm1hcmdpblJpZ2h0IiwiU2l6ZXMiLCJ3cmFwcGVyIiwiY2hpbGRyZW4iLCJzaWJsaW5ncyIsIm5vZGUiLCJwYXJlbnROb2RlIiwibiIsImZpcnN0Q2hpbGQiLCJtYXRjaGVkIiwibmV4dFNpYmxpbmciLCJub2RlVHlwZSIsImV4aXN0Iiwid2luZG93IiwiSFRNTEVsZW1lbnQiLCJ0b0FycmF5Iiwibm9kZUxpc3QiLCJzbGljZSIsIlRSQUNLX1NFTEVDVE9SIiwicm9vdCIsInRyYWNrIiwicXVlcnlTZWxlY3RvciIsImNvbGxlY3RTbGlkZXMiLCJmaWx0ZXIiLCJjbGFzc0xpc3QiLCJjb250YWlucyIsIl9yIiwiZG9jdW1lbnQiLCJ0IiwiUGVlayIsIl92IiwiYmVmb3JlIiwib2Zmc2V0IiwibW92ZW1lbnQiLCJzbGlkZVdpZHRoIiwidHJhbnNsYXRlIiwiaXMiLCJzZXR1cFNsaWRlcyIsIndpZHRoIiwic2V0dXBXcmFwcGVyIiwid3JhcHBlclNpemUiLCJvZmZzZXRXaWR0aCIsImdyb3ciLCJDbG9uZXMiLCJyZWR1Y3RvciIsIkJ1aWxkIiwidHlwZUNsYXNzIiwiYWN0aXZlQ2xhc3MiLCJhZGQiLCJzaWJsaW5nIiwicmVtb3ZlQ2xhc3NlcyIsIl9HbGlkZSRzZXR0aW5ncyRjbGFzcyIsIml0ZW1zIiwiY29sbGVjdCIsIl9HbGlkZSRzZXR0aW5ncyIsInBlZWtJbmNyZW1lbnRlciIsImNsb25lQ291bnQiLCJyb3VuZCIsImFwcGVuZCIsInJldmVyc2UiLCJwcmVwZW5kIiwibWF4IiwiY2xvbmVOb2RlIiwiX2Nsb25lIiwidW5zaGlmdCIsIl9Db21wb25lbnRzJEh0bWwiLCJoYWxmIiwiYXBwZW5kQ2hpbGQiLCJfaTIiLCJpbnNlcnRCZWZvcmUiLCJfaTMiLCJyZW1vdmVDaGlsZCIsIkV2ZW50c0JpbmRlciIsImxpc3RlbmVycyIsImVsIiwiY2xvc3VyZSIsImNhcHR1cmUiLCJhZGRFdmVudExpc3RlbmVyIiwib2ZmIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIlJlc2l6ZSIsIkJpbmRlciIsImJpbmQiLCJ1bmJpbmQiLCJWQUxJRF9ESVJFQ1RJT05TIiwiRkxJUEVEX01PVkVNRU5UUyIsInJlc29sdmUiLCJ0b2tlbiIsInNwbGl0Iiwiam9pbiIsImFkZENsYXNzIiwicmVtb3ZlQ2xhc3MiLCJpbmRleE9mIiwiUnRsIiwibW9kaWZ5IiwiR2FwIiwibXVsdGlwbGllciIsIkdyb3ciLCJQZWVraW5nIiwiRm9jdXNpbmciLCJtdXRhdG9yIiwiVFJBTlNGT1JNRVJTIiwidHJhbnNmb3JtZXIiLCJUcmFuc2xhdGUiLCJ0cmFuc2Zvcm0iLCJ0cmFuc2xhdGUzZCIsIm1velRyYW5zZm9ybSIsIndlYmtpdFRyYW5zZm9ybSIsImdldFN0YXJ0SW5kZXgiLCJnZXRUcmF2ZWxEaXN0YW5jZSIsInRyYXZlbERpc3RhbmNlIiwic3RhcnRXaWR0aCIsImNvbXBvc2UiLCJkdXJhdGlvbiIsInRyYW5zaXRpb24iLCJjYWxsYmFjayIsInN1cHBvcnRzUGFzc2l2ZSIsIm9wdHMiLCJzdXBwb3J0c1Bhc3NpdmUkMSIsIlNUQVJUX0VWRU5UUyIsIk1PVkVfRVZFTlRTIiwiRU5EX0VWRU5UUyIsIk1PVVNFX0VWRU5UUyIsIlN3aXBlIiwic3dpcGVTaW4iLCJzd2lwZVN0YXJ0WCIsInN3aXBlU3RhcnRZIiwicGFzc2l2ZSIsImJpbmRTd2lwZVN0YXJ0Iiwic3RhcnQiLCJzd2lwZSIsInRvdWNoZXMiLCJwYWdlWCIsInBhZ2VZIiwiYmluZFN3aXBlTW92ZSIsImJpbmRTd2lwZUVuZCIsInN1YkV4U3giLCJzdWJFeVN5IiwicG93RVgiLCJhYnMiLCJwb3dFWSIsInN3aXBlSHlwb3RlbnVzZSIsInNxcnQiLCJzd2lwZUNhdGhldHVzIiwiYXNpbiIsIlBJIiwic3RvcFByb3BhZ2F0aW9uIiwiZW5kIiwiX0dsaWRlJHNldHRpbmdzMiIsInRocmVzaG9sZCIsInN3aXBlRGlzdGFuY2UiLCJzd2lwZURlZyIsInVuYmluZFN3aXBlTW92ZSIsInVuYmluZFN3aXBlRW5kIiwiX0dsaWRlJHNldHRpbmdzMyIsInVuYmluZFN3aXBlU3RhcnQiLCJfdGhpczIiLCJfdGhpczMiLCJjaGFuZ2VkVG91Y2hlcyIsIkltYWdlcyIsImRyYWdzdGFydCIsInByZXZlbnREZWZhdWx0IiwiQW5jaG9ycyIsImRldGFjaGVkIiwicHJldmVudGVkIiwiX2EiLCJxdWVyeVNlbGVjdG9yQWxsIiwiY2xpY2siLCJkZXRhY2giLCJkcmFnZ2FibGUiLCJhdHRhY2giLCJOQVZfU0VMRUNUT1IiLCJDT05UUk9MU19TRUxFQ1RPUiIsIlBSRVZJT1VTX0NPTlRST0xTX1NFTEVDVE9SIiwiTkVYVF9DT05UUk9MU19TRUxFQ1RPUiIsIkNvbnRyb2xzIiwiX24iLCJfYXJyb3dDb250cm9scyIsIm5leHQiLCJhZGRCaW5kaW5ncyIsInNldEFjdGl2ZSIsInJlbW92ZUFjdGl2ZSIsImNvbnRyb2xzIiwic2V0QXJyb3dTdGF0ZSIsInJlc2V0QXJyb3dTdGF0ZSIsImRpc2FibGVBcnJvdyIsIl9sZW4iLCJsaXN0cyIsIl9rZXkiLCJsaXN0IiwiZWxlbWVudCIsIl9sZW4yIiwiX2tleTIiLCJyZW1vdmVCaW5kaW5ncyIsImVsZW1lbnRzIiwiY3VycmVudFRhcmdldCIsImdldEF0dHJpYnV0ZSIsIktleWJvYXJkIiwicHJlc3MiLCJjb2RlIiwiQXV0b3BsYXkiLCJzZXRJbnRlcnZhbCIsInN0b3AiLCJ0aW1lIiwiY2xlYXJJbnRlcnZhbCIsInNvcnRCcmVha3BvaW50cyIsInBvaW50cyIsIkJyZWFrcG9pbnRzIiwibWF0Y2giLCJtYXRjaE1lZGlhIiwicG9pbnQiLCJtYXRjaGVzIiwiQ09NUE9ORU5UUyIsIl9Db3JlIiwiX3N1cGVyIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glidejs/glide/dist/glide.esm.js\n");

/***/ })

};
;